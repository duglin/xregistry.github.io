<h1 id="xregistry-service---version-10-rc1"><a class="anchor" href="#xregistry-service---version-10-rc1">☍</a> xRegistry Service - Version 1.0-rc1</h1>
<h2 id="abstract"><a class="anchor" href="#abstract">☍</a> Abstract</h2>
<p>A Registry Service exposes Resources and their metadata, for the purpose
of enabling discovery of those Resources for either end-user consumption or
automation and tooling.</p>
<h2 id="table-of-contents"><a class="anchor" href="#table-of-contents">☍</a> Table of Contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#notations-and-terminology">Notations and Terminology</a>
<ul>
<li><a href="#notational-conventions">Notational Conventions</a></li>
<li><a href="#terminology">Terminology</a></li>
</ul>
</li>
<li><a href="#registry-attributes-and-apis">Registry Attributes and APIs</a>
<ul>
<li><a href="#implementation-customizations">Implementation Customizations</a></li>
<li><a href="#attributes-and-extensions">Attributes and Extensions</a></li>
<li><a href="#registry-apis">Registry APIs</a>
<ul>
<li><a href="#registry-collections">Registry Collections</a></li>
<li><a href="#entity-processing-rules">Entity Processing Rules</a></li>
</ul>
</li>
<li><a href="#registry-entity">Registry Entity</a>
<ul>
<li><a href="#retrieving-the-registry">Retrieving the Registry</a></li>
<li><a href="#updating-the-registry-entity">Updating the Registry Entity</a></li>
</ul>
</li>
<li><a href="#registry-capabilities">Registry Capabilities</a></li>
<li><a href="#registry-model">Registry Model</a>
<ul>
<li><a href="#retrieving-the-registry-model">Retrieving the Registry Model</a></li>
<li><a href="#updating-the-registry-model">Updating the Registry Model</a></li>
</ul>
</li>
<li><a href="#groups">Groups</a>
<ul>
<li><a href="#retrieving-a-group-collection">Retrieving a Group Collection</a></li>
<li><a href="#creating-or-updating-groups">Creating or Updating Groups</a></li>
<li><a href="#retrieving-a-group">Retrieving a Group</a></li>
<li><a href="#deleting-groups">Deleting Groups</a></li>
</ul>
</li>
<li><a href="#resources">Resources</a>
<ul>
<li><a href="#retrieving-a-resource-collection">Retrieving a Resource Collection</a></li>
<li><a href="#creating-or-updating-resources-and-versions">Creating or Updating Resources and
Versions</a></li>
<li><a href="#retrieving-a-resource">Retrieving a Resource</a></li>
<li><a href="#deleting-resources">Deleting Resources</a></li>
</ul>
</li>
<li><a href="#versions">Versions</a>
<ul>
<li><a href="#retrieving-all-versions">Retrieving all Versions</a></li>
<li><a href="#creating-or-updating-versions">Creating or Updating Versions</a></li>
<li><a href="#retrieving-a-version">Retrieving a Version</a></li>
<li><a href="#deleting-versions">Deleting Versions</a></li>
</ul>
</li>
<li><a href="#configuring-responses">Configuring Responses</a>
<ul>
<li><a href="#collections-flag">Collections Flag</a></li>
<li><a href="#doc-flag">Doc Flag</a></li>
<li><a href="#filter-flag">Filter Flag</a></li>
<li><a href="#inline-flag">Inline Flag</a></li>
</ul>
</li>
<li><a href="#http-header-values">HTTP Header Values</a></li>
<li><a href="#error-processing">Error Processing</a></li>
</ul>
</li>
</ul>
<h2 id="overview"><a class="anchor" href="#overview">☍</a> Overview</h2>
<p>A Registry Service is one that manages metadata about Resources. At its core,
the management of an individual Resource is simply a REST-based interface for
creating, modifying, and deleting the Resource. However, many Resource models
share a common pattern of grouping Resources and can optionally support
versioning of those Resources. This specification aims to provide a common
interaction pattern for these types of services with the goal of providing an
interoperable framework that will enable common tooling and automation to be
created.</p>
<p>This document is meant to be a framework from which additional specifications
can be defined that expose model-specific Resources and metadata.</p>
<p>As of today, this specification only specifies an HTTP-based interaction model.
This is not meant to imply that other protocols cannot be supported, and
other protocols will likely be added in the future. When that happens, this
specification will be restructured to have clean separation between a
protocol-agnostic core and protocol-specific requirements.</p>
<p>A Registry consists of two main types of entities: Groups and Resources.</p>
<p>Groups, as the name implies, is a mechanism by which related Resources are
arranged together under a single collection - the Group. The reason for the
grouping is not defined by this specification, so the owners of the Registry
can choose to define (or enforce) any pattern they wish. In this sense, a
Group is similar to a &quot;directory&quot; on a filesystem.</p>
<p>Resources represent the main data of interest for the Registry. In the
filesystem analogy, these would be the &quot;files&quot;. All Resources exist under a
single Group and, similar to Groups, have a set of Registry metadata.
However, unlike a Group which only has Registry metadata, each Resource can
also have a &quot;document&quot; associated with it. For example, a &quot;schema&quot; Resource
might have a &quot;schema document&quot; as its &quot;document&quot;. This specification places no
restriction on the type of content stored in the Resource's document.</p>
<p>This specification defines a set of common metadata that can appear on both
Groups and Resources, and allows for domain-specific extensions to be added.</p>
<p>The following 3 diagrams show (from left to right):<br>
1 - The core concepts of the Registry in its most abstract form.<br>
2 - A Registry concept model with multiple types of Groups/Resources.<br>
3 - A concrete sample usage of Registry that includes the use of an attribute
on &quot;Message Definition&quot; that is a reference to a &quot;Schema&quot; document - all
within the same Registry instance.</p>
<p><img src="./xregbasicmodel.png"
height="300">   <img
src="./xregfullmodel.png" height="300">   <img
src="./sample.png" height="300"></p>
<p>For easy reference, the JSON serialization of a Registry adheres to this form:</p>
<pre><code class="language-yaml">{
  &quot;specversion&quot;: &quot;STRING&quot;,
  &quot;registryid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,
  &quot;epoch&quot;: UINTEGER,
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,

  &quot;capabilities&quot;: {                     # Supported capabilities/options
    &quot;flags&quot;: [                          # Query parameters
      &quot;collections&quot;,? &quot;doc&quot;,? &quot;epoch&quot;,? &quot;filter&quot;,? &quot;inline&quot;,?
      &quot;nodefaultversionid&quot;,? &quot;nodefaultversionsticky&quot;,? &quot;noepoch&quot;,?
      &quot;noreadonly&quot;,?  &quot;offered&quot;,? &quot;schema&quot;,? &quot;setdefaultversionid&quot;,?
      &quot;specversion&quot;,?
      &quot;STRING&quot; *
    ],
    &quot;mutable&quot;: [                        # What is mutable in the Registry
      &quot;capabilities&quot;,? &quot;entities&quot;,? &quot;model&quot;,? &quot;STRING&quot;*
    ], ?
    &quot;pagination&quot;: BOOLEAN, ?
    &quot;schemas&quot;: [ &quot;xRegistry-json/1.0-rc1&quot;, &quot;STRING&quot; * ], ?
    &quot;shortself&quot;: BOOLEAN, ?
    &quot;specversions&quot;: [ &quot;1.0-rc1&quot;, &quot;STRING&quot;* ], ?
    &quot;sticky&quot;: BOOLEAN, ?

    &quot;STRING&quot;: ... *                     # Extension capabilities
  }, ?

  &quot;model&quot;: {                            # Only if inlined
    &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
    &quot;attributes&quot;: {                     # Registry level attributes/extensions
      &quot;STRING&quot;: {                       # Attribute name (case-sensitive)
        &quot;name&quot;: &quot;STRING&quot;,               # Same as attribute's key
        &quot;type&quot;: &quot;TYPE&quot;,                 # string, decimal, array, object, ...
        &quot;target&quot;: &quot;STRING&quot;, ?           # If &quot;type&quot; is &quot;xid&quot;
        &quot;namecharset&quot;: &quot;STRING&quot;, ?      # If &quot;type&quot; is &quot;object&quot;
        &quot;description&quot;: &quot;STRING&quot;, ?
        &quot;enum&quot;: [ VALUE * ], ?          # Array of scalar values of type &quot;TYPE&quot;
        &quot;strict&quot;: BOOLEAN, ?            # Just &quot;enum&quot; values? Default=true
        &quot;readonly&quot;: BOOLEAN, ?          # From client's POV. Default=false
        &quot;immutable&quot;: BOOLEAN, ?         # Once set, can't change. Default=false
        &quot;required&quot;: BOOLEAN, ?          # Default=false
        &quot;default&quot;: VALUE, ?             # Scalar attribute's default value

        &quot;attributes&quot;: { ... }, ?        # If &quot;type&quot; above is object
        &quot;item&quot;: {                       # If &quot;type&quot; above is map,array
          &quot;type&quot;: &quot;TYPE&quot;, ?             # map value type, or array type
          &quot;namecharset&quot;: &quot;STRING&quot;, ?    # If this item &quot;type&quot; is object
          &quot;attributes&quot;: { ... }, ?      # If this item &quot;type&quot; is object
          &quot;item&quot;: { ... } ?             # If this item &quot;type&quot; is map,array
        } ?

        &quot;ifvalues&quot;: {                   # If &quot;type&quot; is scalar
          &quot;VALUE&quot;: {                    # Possible attribute value
            &quot;siblingattributes&quot;: { ... } # See &quot;attributes&quot; above
          } *
        } ?
      } *
    },

    &quot;groups&quot;: {
      &quot;STRING&quot;: {                       # Key=plural name, e.g. &quot;endpoints&quot;
        &quot;plural&quot;: &quot;STRING&quot;,             # e.g. &quot;endpoints&quot;
        &quot;singular&quot;: &quot;STRING&quot;,           # e.g. &quot;endpoint&quot;
        &quot;description&quot;: &quot;STRING&quot;, ?
        &quot;modelversion&quot;: &quot;STRING&quot;, ?     # Version of the group model
        &quot;compatiblewith&quot;: &quot;URI&quot;, ?      # Statement of compatibility with model spec
        &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
        &quot;attributes&quot;: { ... }, ?        # Group level attributes/extensions

        &quot;resources&quot;: {
          &quot;STRING&quot;: {                   # Key=plural name, e.g. &quot;messages&quot;
            &quot;plural&quot;: &quot;STRING&quot;,         # e.g. &quot;messages&quot;
            &quot;singular&quot;: &quot;STRING&quot;,       # e.g. &quot;message&quot;
            &quot;description&quot;: &quot;STRING&quot;, ?
            &quot;maxversions&quot;: UINTEGER, ?  # Num Vers(&gt;=0). Default=0, 0=unlimited
            &quot;setversionid&quot;: BOOLEAN, ?  # vid settable? Default=true
            &quot;setdefaultversionsticky&quot;: BOOLEAN, ? # sticky settable? Default=true
            &quot;hasdocument&quot;: BOOLEAN, ?     # Has separate document. Default=true
            &quot;singleversionroot&quot;: BOOLEAN, ? # Default=false&quot;
            &quot;typemap&quot;: MAP, ?             # contenttype mappings
            &quot;modelversion&quot;: &quot;STRING&quot;, ?   # Version of the resource model
            &quot;compatiblewith&quot;: &quot;URI&quot;, ?    # Statement of compatibility with model spec
            &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
            &quot;attributes&quot;: { ... }, ?      # Version attributes/extensions
            &quot;metaattributes&quot;: { ... } ?   # Resource attributes/extensions
          } *
        } ?
      } *
    } ?
  }, ?

  # Repeat for each Group type
  &quot;GROUPSurl&quot;: &quot;URL&quot;,                              # e.g. &quot;endpointsurl&quot;
  &quot;GROUPScount&quot;: UINTEGER,                         # e.g. &quot;endpointscount&quot;
  &quot;GROUPS&quot;: {                                      # Only if inlined
    &quot;KEY&quot;: {                                       # Key=the Group id
      &quot;GROUPid&quot;: &quot;STRING&quot;,                         # The Group ID
      &quot;self&quot;: &quot;URL&quot;,
      &quot;shortself&quot;: &quot;URL&quot;, ?
      &quot;xid&quot;: &quot;XID&quot;,
      &quot;epoch&quot;: UINTEGER,
      &quot;name&quot;: &quot;STRING&quot;, ?
      &quot;description&quot;: &quot;STRING&quot;, ?
      &quot;documentation&quot;: &quot;URL&quot;, ?
      &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
      &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
      &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,

      # Repeat for each Resource type in the Group
      &quot;RESOURCESurl&quot;: &quot;URL&quot;,                       # e.g. &quot;messagesurl&quot;
      &quot;RESOURCEScount&quot;: UINTEGER,                  # e.g. &quot;messagescount&quot;
      &quot;RESOURCES&quot;: {                               # Only if inlined
        &quot;KEY&quot;: {                                   # The Resource id
          &quot;RESOURCEid&quot;: &quot;STRING&quot;,
          &quot;versionid&quot;: &quot;STRING&quot;,                   # Default Version's ID
          &quot;self&quot;: &quot;URL&quot;,                           # Resource URL, not Version
          &quot;shortself&quot;: &quot;URL&quot;, ?
          &quot;xid&quot;: &quot;XID&quot;,                            # Resource XID, not Version
          &quot;epoch&quot;: UINTEGER,                       # Start of default Ver attrs
          &quot;name&quot;: &quot;STRING&quot;, ?
          &quot;isdefault&quot;: true,
          &quot;description&quot;: &quot;STRING&quot;, ?
          &quot;documentation&quot;: &quot;URL&quot;, ?
          &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
          &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
          &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,
          &quot;ancestor&quot;: &quot;STRING&quot;,
          &quot;contenttype&quot;: &quot;STRING, ?                # Add default Ver extensions

          &quot;RESOURCEurl&quot;: &quot;URL&quot;, ?                  # If not local
          &quot;RESOURCE&quot;: ... Resource document ..., ? # If local &amp; inlined &amp; JSON
          &quot;RESOURCEbase64&quot;: &quot;STRING&quot;, ?            # If local &amp; inlined &amp; ~JSON
                                                   # End of default Ver attrs
          # Resource level helper attributes
          &quot;metaurl&quot;: &quot;URL&quot;,
          &quot;meta&quot;: {                                # Only if inlined
            &quot;RESOURCEid&quot;: &quot;STRING&quot;,
            &quot;self&quot;: &quot;URL&quot;,                         # URL to &quot;meta&quot; object
            &quot;shortself&quot;: &quot;URL&quot;, ?
            &quot;xid&quot;: &quot;XID&quot;,
            &quot;xref&quot;: &quot;URL&quot;, ?                       # xid of linked Resource
            &quot;epoch&quot;: UINTEGER,                     # Resource's epoch
            &quot;createdat&quot;: &quot;TIMESTAMP&quot;,              # Resource's
            &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,             # Resource's
            &quot;readonly&quot;: BOOLEAN,                   # Default=false
            &quot;compatibility&quot;: &quot;STRING&quot;,             # Default=none
            &quot;compatibilityauthority&quot;: &quot;STRING&quot;, ?  # Default=external
            &quot;deprecated&quot;: {
              &quot;effective&quot;: &quot;TIMESTAMP&quot;, ?
              &quot;removal&quot;: &quot;TIMESTAMP&quot;, ?
              &quot;alternative&quot;: &quot;URL&quot;, ?
              &quot;docs&quot;: &quot;URL&quot;?
            }, ?

            &quot;defaultversionid&quot;: &quot;STRING&quot;,
            &quot;defaultversionurl&quot;: &quot;URL&quot;,
            &quot;defaultversionsticky&quot;: BOOLEAN        # Default=false
          }, ?
          &quot;versionsurl&quot;: &quot;URL&quot;,
          &quot;versionscount&quot;: UINTEGER,
          &quot;versions&quot;: {                            # Only if inlined
            &quot;KEY&quot;: {                               # The Version's versionid
              &quot;RESOURCEid&quot;: &quot;STRING&quot;,              # The Resource id
              &quot;versionid&quot;: &quot;STRING&quot;,               # The Version id
              &quot;self&quot;: &quot;URL&quot;,                       # Version URL
              &quot;shortself&quot;: &quot;URL&quot;, ?
              &quot;xid&quot;: &quot;XID&quot;,
              &quot;epoch&quot;: UINTEGER,                   # Version's epoch
              &quot;name&quot;: &quot;STRING&quot;, ?
              &quot;isdefault&quot;: BOOLEAN,                # Default=false
              &quot;description&quot;: &quot;STRING&quot;, ?
              &quot;documentation&quot;: &quot;URL&quot;, ?
              &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
              &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
              &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,
              &quot;ancestor&quot;: &quot;STRING&quot;,                    # Ancestor's versionid
              &quot;contenttype&quot;: &quot;STRING&quot;, ?

              &quot;RESOURCEurl&quot;: &quot;URL&quot;, ?                  # If not local
              &quot;RESOURCE&quot;: ... Resource document ..., ? # If inlined &amp; JSON
              &quot;RESOURCEbase64&quot;: &quot;STRING&quot; ?             # If inlined &amp; ~JSON
            } *
          } ?
        } *
      } ?
    } *
  } ?
}
</code></pre>
<h2 id="notations-and-terminology"><a class="anchor" href="#notations-and-terminology">☍</a> Notations and Terminology</h2>
<h3 id="notational-conventions"><a class="anchor" href="#notational-conventions">☍</a> Notational Conventions</h3>
<p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;,
&quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
interpreted as described in <a href="https://tools.ietf.org/html/rfc2119">RFC 2119</a>.</p>
<p>For clarity, OPTIONAL attributes (specification-defined and extensions) are
OPTIONAL for clients to use, but the servers' responsibility will vary.
Server-unknown extension attributes MUST be silently stored in the backing
datastore. Specification-defined, and server-known extension attributes MUST
generate an error if the corresponding feature is not supported or enabled.
However, as with all attributes, if accepting the attribute results in a
bad state (such as exceeding a size limit, or results in a security issue),
then the server MAY choose to reject the request.</p>
<p>In the pseudo JSON format snippets <code>?</code> means the preceding item is OPTIONAL,
<code>*</code> means the preceding item MAY appear zero or more times, and <code>+</code> means the
preceding item MUST appear at least once. The presence of the <code>#</code> character
means the remaining portion of the line is a comment. Whitespace characters in
the JSON snippets are used for readability and are not normative.</p>
<p>When HTTP query parameters are discussed, they are presented as <code>?NAME</code> where
<code>NAME</code> is the name of the query parameter.</p>
<p>Use of the words <code>GROUP</code> and <code>RESOURCE</code> are meant to represent the singular
name of a Group and Resource type being used. While <code>GROUPS</code> and <code>RESOURCES</code>
are the plural name of those respective types. Use of the word <code>SINGULAR</code>
represents the singular name of the entity being referenced. For example,
for a &quot;schema document&quot; Resource type where its plural name is defined as
<code>schemas</code> and its singular name is defined as <code>schema</code>, the <code>SINGULAR</code>
value would be <code>schema</code>.</p>
<p>Use of acronyms and words in all capital letters (e.g. <code>KEY</code>) typically
represent a field that will be replaced by its real value at runtime.
Additionally, the following acronyms are defined:</p>
<ul>
<li><code>gID</code> is the <code>SINGULARid</code> of a single Group.</li>
<li><code>rID</code> is the <code>SINGULARid</code> of a single Resource.</li>
<li><code>vID</code> is the <code>versionid</code> of a single Version of a Resource.</li>
</ul>
<p>The following are used to denote an instance of one of the associated data
types (see <a href="#attributes-and-extensions">Attributes and Extensions</a> for more
information about each data type):</p>
<ul>
<li><code>ARRAY</code></li>
<li><code>BOOLEAN</code></li>
<li><code>DECIMAL</code></li>
<li><code>INTEGER</code></li>
<li><code>MAP</code></li>
<li><code>OBJECT</code></li>
<li><code>STRING</code></li>
<li><code>TIMESTAMP</code></li>
<li><code>UINTEGER</code></li>
<li><code>URI</code></li>
<li><code>URIABSOLUTE</code></li>
<li><code>URIRELATIVE</code></li>
<li><code>URITEMPLATE</code></li>
<li><code>URL</code></li>
<li><code>URLABSOLUTE</code></li>
<li><code>URLRELATIVE</code></li>
<li><code>XID</code></li>
<li><code>TYPE</code> - one of the allowable data type names (MUST be in lower case) listed
in <a href="#attributes-and-extensions">Attributes and Extensions</a></li>
</ul>
<h3 id="terminology"><a class="anchor" href="#terminology">☍</a> Terminology</h3>
<p>This specification defines the following terms:</p>
<h4 id="group"><a class="anchor" href="#group">☍</a> Group</h4>
<p>An entity that acts as a collection of related Resources.</p>
<h4 id="registry"><a class="anchor" href="#registry">☍</a> Registry</h4>
<p>An implementation of this specification. Typically, the implementation would
include model-specific Groups, Resources and extension attributes.</p>
<h4 id="resource"><a class="anchor" href="#resource">☍</a> Resource</h4>
<p>A Resource is typically the main entity that is stored within a Registry
Service. A Resource MUST exist within the scope of a Group and it MAY be
versioned.</p>
<h2 id="registry-attributes-and-apis"><a class="anchor" href="#registry-attributes-and-apis">☍</a> Registry Attributes and APIs</h2>
<p>This section defines common Registry metadata attributes and APIs. It is an
explicit goal for this specification that metadata can be created and managed
in files in a file system, for instance in a Git repository, and also managed
in a Registry service that implements the API described here.</p>
<p>For instance, during development of a module, the metadata about the events
raised by the modules will best be managed in a file that resides alongside the
module's source code. When the module is ready to be deployed into a concrete
system, the metadata about the events will be registered in a Registry service
along with the endpoints where those events can be subscribed to or consumed
from, and which allows discovery of the endpoints and all related metadata by
other systems at runtime.</p>
<p>Therefore, the hierarchical structure of the Registry model is defined in such
a way that it can be represented in a single file, including but not limited
to JSON, or via the entity graph of a REST API.</p>
<p>If the processing of a request fails then an error MUST be generated and
the entire request MUST be undone. See the
<a href="#error-processing">Error Processing</a> section for more information.</p>
<p>In the remainder of this specification, in particular when defining the
attributes of the Registry entities, the terms &quot;document view&quot; or &quot;API view&quot;
will be used to indicate whether the serialization of the entity in a response
is meant for use as a stand-alone document or as part of a REST API message
exchange. The most notable differences are that in document view:</p>
<ul>
<li>References (e.g. URLs) between entities within responses will use relative
references rather than absolute ones. This is an indication to tooling that
the entity in question can be found within the current document and does not
need an additional HTTP <code>GET</code> to retrieve it.</li>
<li>Duplicate data will be removed. In particular, Resources will not include
attributes from the &quot;default&quot; Version as part of their serialization. This is
done with the assumption the nested <code>versions</code> collection will most likely
include the &quot;default&quot; Version, so duplicating that information is redundant.</li>
</ul>
<p>Most of these differences are to make it easier for tooling to use the
&quot;stand-alone&quot; document view of the Registry. For a complete list of the
differences in &quot;document view&quot; see the <a href="#doc-flag">Doc Flag</a> flag and the
<a href="#exporting">Exporting</a> section.</p>
<p>Note that &quot;document view&quot; only refers to response messages. There is no
&quot;document view&quot; concept for requests. However, &quot;document view&quot; responses
are designed such that they can be used in request messages as they still
convey the same information as an &quot;API view&quot; response.</p>
<h3 id="implementation-customizations"><a class="anchor" href="#implementation-customizations">☍</a> Implementation Customizations</h3>
<p>This specification only defines the core APIs, and their semantics, of a
Registry service. It does not address many of the details that would need to
be added for a live instance of a service; as often times these aspects are
very specific to the environment in which the service is running. For example,
this specification does not address authentication or authorization levels of
users, nor how to securely protect the APIs (aside from the implied use of
<code>https</code>), clients or servers from attacks. Implementations of this
specification are expected to add these various features as needed.</p>
<p>Additionally, implementation MAY choose to customize the data and behavior on
a per-user basis as needed. For example, the following customizations might be
implemented:</p>
<ul>
<li>User-specific capabilities - e.g. admin users might see more features than
a non-admin user.</li>
<li>User-specific attribute aspects - e.g. admin users might be able to
edit a <code>readonly</code> Resource. Note that in this case the Resource's <code>readonly</code>
aspect will likely appear with a value of <code>true</code> even for the admin.</li>
</ul>
<p>The goal of these customizations is not to allow for implementation to
violate the specification, rather it is to allow for real-world requirements
to be met while maintaining the interoperability goals of the specification.</p>
<p>Implementations are encouraged to contact the xRegistry community if it is
unclear if certain customizations would violate the specification.</p>
<h3 id="attributes-and-extensions"><a class="anchor" href="#attributes-and-extensions">☍</a> Attributes and Extensions</h3>
<p>Unless otherwise noted, all attributes and extensions MUST be mutable and MUST
be one of the following data types:</p>
<ul>
<li><code>any</code> - an attribute of this type is one whose type is not known in advance
and MUST be one of the concrete types listed here.</li>
<li><code>array</code> - an ordered list of values that are all of the same data type - one
of the types listed here.
<ul>
<li>Some serializations, such as JSON, allow for a <code>null</code> type of value to
appear in an array (e.g. <code>[ null, 2, 3 ]</code> in an array of integers). In
these cases, while it is valid for the serialization being used, it is
not valid for xRegistry since <code>null</code> is not a valid <code>integer</code>. Meaning,
the serialization of an array that is syntactically valid for the
format being used, but not semantically valid per the xRegistry model
definition MUST NOT be accepted and MUST generate an error
(<a href="#invalid_data_type">invalid_data_type</a>).</li>
</ul>
</li>
<li><code>boolean</code> - case-sensitive <code>true</code> or <code>false</code>.</li>
<li><code>decimal</code> - number (integer or floating point).</li>
<li><code>integer</code> - signed integer.</li>
<li><code>map</code> - set of key/value pairs, where the key MUST be of type string. The
value MUST be of one of the types defined here.
<ul>
<li>Each key MUST be a non-empty string consisting of only lowercase
alphanumeric characters (<code>[a-z0-9]</code>), <code>:</code>, <code>-</code>, <code>_</code> or a <code>.</code>; be no longer
than 63 characters; start with an alphanumeric character and be unique
within the scope of this map.</li>
<li>See <a href="#serializing-resource-documents">Serializing Resource Documents</a>
for more information about serializing maps as HTTP headers.</li>
</ul>
</li>
<li><code>object</code> - a nested entity made up of a set of attributes of these data types.</li>
<li><code>xid</code> - MUST be a <code>URL</code> (xid) reference to another entity defined within
the Registry. The actual entity attribute value MAY reference a non-existing
entity (i.e. dangling pointer), but the syntax MUST reference a
defined/valid type in the Registry. This type of attribute is used in
place of <code>url</code> so that the Registry can do &quot;type checking&quot; to ensure the
value references the correct type of Registry entity. See the definition of
the <a href="#model.target"><code>target</code> model attribute</a> for more information.</li>
<li><code>string</code> - sequence of Unicode characters.</li>
<li><code>timestamp</code> - an <a href="https://tools.ietf.org/html/rfc3339">RFC3339</a> timestamp.</li>
<li><code>uinteger</code> - unsigned integer.</li>
<li><code>uri</code> - a URI as defined in <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>.
Note that it can be absolute or relative.</li>
<li><code>uriabsolute</code> - absolute URI as defined in <a href="https://tools.ietf.org/html/rfc3986#section-4.3">RFC 3986 Section
4.3</a>.</li>
<li><code>urirelative</code> - relative URI as defined in <a href="https://tools.ietf.org/html/rfc3986#section-4.2">RFC 3986 Section
4.2</a>.</li>
<li><code>uritemplate</code> - URI Template as defined in
<a href="https://tools.ietf.org/html/rfc6570#section-3.2.1">RFC 6570 Section 3.2.1</a>.</li>
<li><code>url</code> - an absolute URL (<code>urlabsolute</code>) or relative URL (<code>urlrelative</code>).</li>
<li><code>urlabsolute</code> - an absolute URI as defined in <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-4.3">RFC 3986 Section
4.3</a> with the
added &quot;URL&quot; constraints mentioned in <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.3">RFC 3986 Section
1.1.3</a>.</li>
<li><code>urlrelative</code> - a relative URI as defined in <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-4.2">RFC 3986 Section
4.2</a> with the
added &quot;URL&quot; constraints mentioned in <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.3">RFC 3986 Section
1.1.3</a>.</li>
</ul>
<p>The 6 variants of URI/URL are provided to allow for strict type adherence
when needed. However, for attributes that are simply &quot;pointers&quot; that might
in practice be any of those 6 types it is RECOMMENDED that <code>uri</code> be used.</p>
<p>Attributes that are defined to be relative URIs or URLs MUST state what they
are relative to and any constraints on their values, if any.</p>
<p>The root path of a Registry service MAY be at the root of a host or have a
<code>PATH</code> portion in its URL (e.g. <code>http://example.com/myregistry</code>).</p>
<p>The &quot;scalar&quot; data types are: <code>boolean</code>, <code>decimal</code>, <code>integer</code>, <code>string</code>,
<code>timestamp</code>, <code>uinteger</code>, <code>uri</code>, <code>uriabsolute</code>, <code>urirelative</code>, <code>uritemplate</code>,
<code>url</code>, <code>urlabsolute</code>, <code>urlrelative</code>, <code>xid</code>.
Note that <code>any</code> is not a &quot;scalar&quot; type as its runtime value could be a complex
type such as <code>object</code>.</p>
<p>All attributes (specification-defined and extensions) MUST adhere to the
following rules:</p>
<ul>
<li>Their names MUST be between 1 and 63 characters in length.</li>
<li>Their names MUST only contain lowercase alphanumeric characters or an
underscore (<code>[a-z0-9_]</code>) and MUST NOT start with a digit (<code>[0-9]</code>).</li>
<li>For STRING attributes, an empty string is a valid value and MUST NOT be
treated the same as an attribute with no value (or absence of the attribute).</li>
<li>For scalar attributes, the string serialization of the attribute name and
its value MUST NOT exceed 4096 bytes. This is to ensure that it can appear
in an HTTP header without exceeding implementation limits (see
<a href="https://datatracker.ietf.org/doc/html/rfc6265#section-6.1">RFC6265/Limits</a>).
In cases where larger amounts of data are needed, it is RECOMMENDED that
an attribute (of type URL) be defined that references a separate
document. For example, <code>documentation</code> can be considered such an attribute
for <code>description</code>.</li>
<li>If an attribute's type is not fully defined (i.e. it is defined as an <code>any</code>
type) but a concrete type is needed to successfully process it, then the
server SHOULD default it to type <code>string</code>. For example, if an extension is
defined as a map whose values are of type <code>any</code>, but it appears in an HTTP
header with a value of <code>5</code> (and it is not clear if this would be an integer
or a string), if the server needs to convert this to a concrete data type,
then <code>string</code> is the default choice.</li>
<li>There might be cases when it is not possible to know whether a field name is
part of an object (in which case it is an &quot;attribute name&quot;), or is part of
a map (in which case it is a &quot;key name&quot;). This decision would impact
verification of the field since key names allow for a superset of the
characters allowed for attribute names. This will only happen when the
<code>any</code> type has been used higher-up in the model. As a result, any portion of
the entity that appears under the scope of an <code>any</code> typed attribute or
map-value is NOT REQUIRED to be validated except to ensure that the syntax
is valid per the rules of the serialization format used.</li>
<li>Attribute instances that have no value (and have no default value defined)
are semantically equivalent to having a value of <code>null</code> or not being present
at all, and for the sake of brevity, SHOULD NOT be serialized as part of its
owning entity in server responses. Likewise, specifying them with a value of
<code>null</code> in client requests SHOULD be reserved for cases where the client
needs to indicate a request to delete an attribute value (<code>null</code> in the
request) rather than to leave the attribute untouched (absent in the
request), such as when <code>PATCH</code> is used.</li>
</ul>
<p>Implementations of this specification MAY define additional (extension)
attributes. However, they MUST adhere to the following rules:</p>
<ul>
<li>All attributes MUST conform to the model definition of the Registry. This
means that they MUST satisfy at least one of the following:
<ul>
<li>Be explicitly defined (by name) as part of the model.</li>
<li>Be permitted due to the presence of the <code>*</code> (undefined) extension attribute
name at that level in the model.</li>
<li>Be permitted due to the presence of an <code>any</code> type for one of its parent
attribute definitions.</li>
</ul>
</li>
<li>They MUST NOT conflict with the name of an attribute defined by this
specification, including the <code>RESOURCE*</code> and <code>COLLECTION*</code> attributes that
are implicitly defined. Note that if a Resource type has the <code>hasdocument</code>
attribute set the <code>false</code> then this rule does not apply for the <code>RESOURCE*</code>
attributes as those attributes are not used for that Resource type.</li>
<li>It is RECOMMENDED that extension attributes on different entities do not
use the same name unless they have the exact same semantic meaning.</li>
<li>It is STRONGLY RECOMMENDED that they be named in such a way as to avoid
potential conflicts with future Registry level attributes. For
example, use of a model (or domain) specific prefix could be used to help
avoid possible future conflicts.</li>
</ul>
<h4 id="common-attributes"><a class="anchor" href="#common-attributes">☍</a> Common Attributes</h4>
<p>The following attributes are used by one or more entities defined by this
specification. They are defined here once rather than repeating them
throughout the specification.</p>
<p>For easy reference, the JSON serialization of these attributes adheres to this
form:</p>
<ul>
<li><code>&quot;SINGULARid&quot;: &quot;STRING&quot;</code></li>
<li><code>&quot;self&quot;: &quot;URL&quot;</code></li>
<li><code>&quot;shortself&quot;: &quot;URL&quot;</code></li>
<li><code>&quot;xid&quot;: &quot;XID&quot;</code></li>
<li><code>&quot;epoch&quot;: UINTEGER</code></li>
<li><code>&quot;name&quot;: &quot;STRING&quot;</code></li>
<li><code>&quot;description&quot;: &quot;STRING&quot;</code></li>
<li><code>&quot;documentation&quot;: &quot;URL&quot;</code></li>
<li><code>&quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }</code></li>
<li><code>&quot;createdat&quot;: &quot;TIMESTAMP&quot;</code></li>
<li><code>&quot;modifiedat&quot;: &quot;TIMESTAMP&quot;</code></li>
</ul>
<p>The definition of each attribute is defined below:</p>
<h5 id="singularid-id-attribute"><a class="anchor" href="#singularid-id-attribute">☍</a> <code>SINGULARid</code> (<code>id</code>) Attribute</h5>
<ul>
<li>
<p>Type: String</p>
</li>
<li>
<p>Description: An immutable unique identifier of the Registry, Group, Resource
or Version. The actual name of this attribute will vary based on the entity
it identifies. For example, a <code>schema</code> Resource would use an attribute name
of <code>schemaid</code>. This attribute MUST be named <code>registryid</code> for the Registry
itself, and MUST be named <code>versionid</code> for all Version entities.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be a non-empty string consisting of <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-2.3">RFC3986 <code>unreserved</code>
characters</a>
(ALPHA / DIGIT / <code>-</code> / <code>.</code> / <code>_</code> / <code>~</code>) and <code>@</code>, MUST start with
ALPHA, DIGIT or <code>_</code> and MUST be between 1 and 128 characters in length.</li>
<li>MUST be case-insensitive unique within the scope of the entity's parent.</li>
<li>This attribute MUST be treated as case-sensitive for look-up purposes.
This means that an HTTP request to an entity with the wrong case for its
<code>SINGULARid</code> MUST be treated as &quot;not found&quot;.</li>
<li>In cases where an entity's <code>SINGULARid</code> is specified outside of the
serialization of the entity (e.g. part of a request URL, or a map key), its
presence within the serialization of the entity is OPTIONAL. However, if
present, it MUST be the same as any other specification of the <code>SINGULARid</code>
outside of the entity, and it MUST be the same as the entity's existing
<code>SINGULARid</code> if one exists, otherwise an error
(<a href="#mismatched_id">mismatched_id</a>) MUST be generated.</li>
<li>MUST be immutable.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>a183e0a9-abf8-4763-99bc-e6b7fcc9544b</code></li>
<li><code>myEntity</code></li>
<li><code>myEntity.example.com</code></li>
</ul>
</li>
</ul>
<p>While <code>SINGULARid</code> can be something like a UUID, when possible, it is
RECOMMENDED that it be something human friendly as these values will often
appear in user-facing situations such as URLs or as command-line parameters.
And, in cases where <a href="#name-attribute"><code>name</code></a> is absent, it might be used as
the display name.</p>
<p>Note, since <code>SINGULARid</code> is immutable, in order to change its value, a new
entity would need to be created with the new <code>SINGULARid</code> that is a deep-copy
of the existing entity. Then the existing entity would be deleted.</p>
<h5 id="self-attribute"><a class="anchor" href="#self-attribute">☍</a> <code>self</code> Attribute</h5>
<ul>
<li>
<p>Type: URL</p>
</li>
<li>
<p>Description: A server-generated unique URL referencing the current entity.</p>
<ul>
<li>
<p>Each entity in the Registry MUST have a unique <code>self</code> URL value that
locates the entity in the Registry hierarchy and from where the entity can
be retrieved.</p>
</li>
<li>
<p>When specified as an absolute URL, it MUST be based on the URL of the
Registry root appended with the hierarchy path of the Registry
entities/collections leading to the entity.</p>
<p>In the case of pointing to an entity that has a <code>SINGULARid</code> attribute,
the URL MUST be a combination of the URL used to retrieve its parent
appended with its <code>SINGULARid</code> value.</p>
</li>
</ul>
</li>
<li>
<p>API View Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be a non-empty absolute URL based on the URL of the Registry.</li>
<li>When serializing Resources or Versions, if the <code>hasdocument</code> aspect is set
to <code>true</code>, then this URL MUST include the <code>$details</code> suffix to its
<code>SINGULARid</code> if it is serialized in the HTTP body response. If the aspect
is set to <code>false</code>, then this URL's <code>SINGULARid</code> MUST NOT include it.</li>
<li>MUST be a read-only attribute.</li>
</ul>
</li>
<li>
<p>Document View Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be a relative URL of the form <code>#JSON-POINTER</code> where the <code>JSON-POINTER</code>
locates this entity within the current document. See <a href="#doc-flag">Doc Flag</a>
for more information.</li>
<li>MUST NOT include <code>$details</code> suffix on its <code>SINGULARid</code>.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>https://example.com/registry/endpoints/ep1</code> (API View)</li>
<li><code>#/endpoints/ep1</code> (Document View)</li>
</ul>
</li>
</ul>
<h5 id="shortself-attribute"><a class="anchor" href="#shortself-attribute">☍</a> <code>shortself</code> Attribute</h5>
<ul>
<li>
<p>Type: URL</p>
</li>
<li>
<p>Description: A server generated unique absolute URL for an entity. This
attribute MUST be an alternative URL for the owning entity's <code>self</code>
attribute. The intention is that <code>shortself</code> SHOULD be shorter in length
than <code>self</code> such that it MAY be used when the length of the URL referencing
the owning entity is important. For example, in cases where the size of a
message needs to be as small as possible.</p>
<p>This specification makes no statement as to how this URL is constructed,
to which host/path it references, or whether a request to this URL
will directly perform the desired operation or whether it returns a
redirect to the full <code>self</code> URL requiring the client to resend the request.</p>
<p>If an entity is deleted and then a new entity is created that results in
the same <code>self</code> URL, this specification does not mandate that the same
<code>shorturl</code> be generated, but it MAY do so.</p>
<p>This attribute MUST only appear in the serialization if the <code>shortself</code>
capability is enabled. However, if this capability is enabled, then disabled,
and then re-enabled, the <code>shortself</code> values MUST retain their original
values. In this sense, implementations might create a <code>shortself</code> that is
known for the lifetime of the entity and the capability controls whether
the attribute is serialized or not.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED if the <code>shortself</code> capability is enabled.</li>
<li>MUST NOT appear in responses if the <code>shortself</code> capability is disabled.</li>
<li>MUST be unique across all entities in the Registry.</li>
<li>MUST be a non-empty absolute URL referencing the same entity as the <code>self</code>
URL, either directly or indirectly via an HTTP redirect.</li>
<li>MUST be a read-only attribute.</li>
<li>MUST be immutable for the lifetime of the entity.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>https://tinyurl.com/xreg123</code> redirects to
<code>https://example.com/endpoints/e1</code></li>
</ul>
</li>
</ul>
<h5 id="xid-attribute"><a class="anchor" href="#xid-attribute">☍</a> <code>xid</code> Attribute</h5>
<ul>
<li>
<p>Type: XID</p>
</li>
<li>
<p>Description: An immutable server generated unique identifier of the entity.
Unlike <code>SINGULARid</code>, which is unique within the scope of its parent, <code>xid</code>
MUST be unique across the entire Registry, and as such is defined to be a
relative URL from the root of the Registry. This value MUST be the same as
the PATH portion of its <code>self</code> URL, after the Registry's base URL, without
any <code>$</code> suffix (e.g. <code>$details</code>). Unlike some other relative URIs, <code>xid</code>
values MUST NOT be shortened based on the incoming request's URL. <code>xid</code>s
are always relative to the root path of the Registry.</p>
<p>This attribute is provided as a convenience for users who need a reference
to the entity without running the risk of incorrectly extracting it from
the <code>self</code> URL, which might be ambiguous at times. The <code>xid</code> value is also
meant to be used as a <code>xref</code> value (see <a href="#cross-referencing-resources">Cross Referencing
Resources</a>, or as the value for attributes of
type <code>xid</code> (see <a href="#model.target"><code>target</code> model attribute</a>).</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be a non-empty relative URL to the current entity.</li>
<li>MUST be of the form: <code>/[GROUPS/gID[/RESOURCES/rID[/meta | /versions/vID]]]</code>.</li>
<li>MUST start with the <code>/</code> character.</li>
<li>MUST be a read-only attribute.</li>
<li>MUST be immutable.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>/endpoints/ep1</code></li>
</ul>
</li>
</ul>
<h5 id="epoch-attribute"><a class="anchor" href="#epoch-attribute">☍</a> <code>epoch</code> Attribute</h5>
<ul>
<li>
<p>Type: Unsigned Integer</p>
</li>
<li>
<p>Description: A numeric value used to determine whether an entity has been
modified. Each time the associated entity is updated, this value MUST be
set to a new value that is greater than the current one. This attribute
MUST be updated for every update operation, even if no attributes were
explicitly updated, such as a <code>PATCH</code> with no attributes. This then acts
like a <code>touch</code> type of operation.</p>
<p>During a single write operation, whether this value is incremented for
each modified attribute of the entity, or updated just once for the entire
operation is an implementation choice.</p>
<p>During a create operation, if this attribute is present in the request, then
it MUST be silently ignored by the server.</p>
<p>During an update operation, if this attribute is present in the request, then
an error (<a href="#mismatched_epoch">mismatched_epoch</a>) MUST be generated if the
request includes a non-null value that differs from the existing value. A
value of <code>null</code> MUST be treated the same as a request with no <code>epoch</code>
attribute at all.</p>
<p>If an entity has a nested xRegistry collection, its <code>epoch</code> value MUST
be updated each time an entity in that collection is added or removed.
However, its <code>epoch</code> value MUST NOT be updated solely due to modifications of
an existing entity in the collection.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be an unsigned integer equal to or greater than zero.</li>
<li>MUST increase in value each time the entity is updated.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>0</code>, <code>1</code>, <code>2</code>, <code>3</code></li>
</ul>
</li>
</ul>
<h5 id="name-attribute"><a class="anchor" href="#name-attribute">☍</a> <code>name</code> Attribute</h5>
<ul>
<li>
<p>Type: String</p>
</li>
<li>
<p>Description: A human-readable name of the entity. This is often used
as the &quot;display name&quot; for an entity rather than the <code>SINGULARid</code> especially
when the <code>SINGULARid</code> might be something that isn't human friendly, like a
UUID. In cases where <code>name</code> is absent, the <code>SINGULARid</code> value SHOULD be
displayed in its place.</p>
<p>This specification places no uniqueness constraints on this attribute.
This means that two sibling entities MAY have the same value. Therefore,
this value MUST NOT be used for unique identification purposes, the
<code>SINGULARid</code> MUST be used instead.</p>
<p>Note that implementations MAY choose to enforce additional constraints on
this value. For example, they could mandate that <code>SINGULARid</code> and <code>name</code> be
the same value. Or, it could mandate that <code>name</code> be unique within the scope
of a parent entity. How any such requirement is shared with all parties is
out of scope of this specification.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>OPTIONAL.</li>
<li>If present, MUST be non-empty.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>My Cool Endpoint</code></li>
</ul>
</li>
</ul>
<h5 id="description-attribute"><a class="anchor" href="#description-attribute">☍</a> <code>description</code> Attribute</h5>
<ul>
<li>
<p>Type: String</p>
</li>
<li>
<p>Description: A human-readable summary of the purpose of the entity.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>OPTIONAL.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>A queue of the sensor generated messages</code></li>
</ul>
</li>
</ul>
<h5 id="documentation-attribute"><a class="anchor" href="#documentation-attribute">☍</a> <code>documentation</code> Attribute</h5>
<ul>
<li>
<p>Type: URL</p>
</li>
<li>
<p>Description: A URL to additional information about this entity.
This specification does not place any constraints on the data returned from
an HTTP <code>GET</code> to this URL.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>OPTIONAL.</li>
<li>If present, MUST be a non-empty URL.</li>
<li>MUST support an HTTP(s) <code>GET</code> to this URL.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>https://example.com/docs/myQueue</code></li>
</ul>
</li>
</ul>
<h5 id="labels-attribute"><a class="anchor" href="#labels-attribute">☍</a> <code>labels</code> Attribute</h5>
<ul>
<li>
<p>Type: Map of name/value string pairs</p>
</li>
<li>
<p>Description: A mechanism in which additional metadata about the entity can
be stored without changing the schema of the entity.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>OPTIONAL.</li>
<li>If present, MUST be a map of zero or more name/value string pairs. See
<a href="#attributes-and-extensions">Attributes and Extensions</a> for more
information.</li>
<li>Keys MUST be non-empty strings.</li>
<li>Values MAY be empty strings.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>&quot;labels&quot;: { &quot;owner&quot;: &quot;John&quot;, &quot;verified&quot;: &quot;&quot; }</code> when in the HTTP body</li>
<li><code>xRegistry-labels-owner: John</code> <br>
<code>xRegistry-labels-verified:</code>  when in HTTP headers</li>
</ul>
<p>Note: HTTP header values can be empty strings but some client-side tooling
might make it challenging to produce them. For example, <code>curl</code> requires
the header to be specified as <code>-HxRegistry-labels-verified;</code> - notice the
semicolon(<code>;</code>) is used instead of colon(<code>:</code>). So, this might be something
to consider when choosing to use labels that can be empty strings.</p>
</li>
</ul>
<h5 id="createdat-attribute"><a class="anchor" href="#createdat-attribute">☍</a> <code>createdat</code> Attribute</h5>
<ul>
<li>
<p>Type: Timestamp</p>
</li>
<li>
<p>Description: The date/time of when the entity was created.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be a <a href="https://tools.ietf.org/html/rfc3339">RFC3339</a> timestamp.</li>
<li>This specification places no restrictions on the value of this attribute,
nor on its value relative to its <code>modifiedat</code> value or the current
date/time. Implementations MAY choose to restrict its values if necessary.</li>
<li>If present in a write operation request, the value MUST override any
existing value, however a value of <code>null</code> MUST use the current date/time
as the new value.</li>
<li>When absent in a write operation request, any existing value MUST remain
unchanged, or if not already set, set to the current date/time</li>
<li>For Versions, if this attribute is updated such that the owning Version
becomes the &quot;newest&quot; Version and the Resource's <code>defaultversionsticky</code>
attribute is <code>false</code>, then this Version MUST become the &quot;default&quot; Version.</li>
<li>During the processing of a single request, all entities that have their
<code>createdat</code> or <code>modifiedat</code> attributes set to the current date/time due
to the processing rules above, MUST use the same value in all cases.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>2030-12-19T06:00:00Z</code></li>
</ul>
</li>
</ul>
<h5 id="modifiedat-attribute"><a class="anchor" href="#modifiedat-attribute">☍</a> <code>modifiedat</code> Attribute</h5>
<ul>
<li>
<p>Type: Timestamp</p>
</li>
<li>
<p>Description: The date/time of when the entity was last updated</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be a <a href="https://tools.ietf.org/html/rfc3339">RFC3339</a> timestamp
representing the time when the entity was last updated.</li>
<li>This specification places no restrictions on the value of this attribute,
nor on its value relative to its <code>createdat</code> value or the current
date/time.  Implementations MAY choose restrict its values if necessary.</li>
<li>Any update operation (even one that does not change any attribute, such as
a <code>PATCH</code> with no attributes provided), MUST update this attribute. This
then acts like a <code>touch</code> type of operation.</li>
<li>Upon creation of a new entity, this attribute MUST match the <code>createdat</code>
attribute's value.</li>
<li>Updates to an existing entity in an xRegistry collection MUST NOT cause an
update to its parent entity's <code>modifiedat</code> value. However, adding or
removing an entity from a nested xRegistry collection MUST update the
<code>modifiedat</code> value of the parent entity.</li>
<li>If present in a write operation request, the following applies:
<ul>
<li>If the request value is <code>null</code> or the same as the existing value, then
the current date/time MUST be used as its new value.</li>
<li>If the request value is different than the existing value, then the
request value MUST be used as its new value.</li>
</ul>
</li>
<li>When absent in a write operation request, it MUST be set to the current
date/time.</li>
<li>During the processing of a single request, all entities that have their
<code>createdat</code> or <code>modifiedat</code> attributes set to the current date/time due
to the processing rules above MUST use the same value in all cases.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>2030-12-19T06:00:00Z</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="registry-apis"><a class="anchor" href="#registry-apis">☍</a> Registry APIs</h3>
<p>This specification defines the following API patterns:</p>
<pre><code class="language-yaml">/                                               # Access the Registry
/capabilities                                   # Access available features
/model                                          # Access the model definitions
/export                                         # Retrieve Registry as a doc
/GROUPS                                         # Access a Group Type
/GROUPS/gID                                     # Access a Group
/GROUPS/gID/RESOURCES                           # Access a Resource Type
/GROUPS/gID/RESOURCES/rID                       # Default Version of a Resource
/GROUPS/gID/RESOURCES/rID/versions              # Versions of a Resource
/GROUPS/gID/RESOURCES/rID/versions/vID          # Access a Version of a Resource
</code></pre>
<p>While these APIs are shown to be at the root path of a host,
implementations MAY choose to prefix them as necessary. However, the same
prefix MUST be used consistently for all APIs in the same Registry instance.</p>
<p>Support for any particular API defined by this specification is OPTIONAL,
however, it is STRONGLY RECOMMENDED that server-side implementations support at
least the &quot;read&quot; (e.g. HTTP <code>GET</code>) operations. Implementations MAY choose to
incorporate authentication and/or authorization mechanisms for the APIs.</p>
<p>If an OPTIONAL HTTP path is not supported by an implementation, then any
use of that API MUST generate an error (<a href="#api_not_found">api_not_found</a>).</p>
<p>If an HTTP method is not supported for a supported HTTP path, then an error
(<a href="#method_not_allowed">method_not_allowed</a>) MUST be generated.</p>
<p>Implementations MAY support extension APIs, however, the following rules MUST
apply:</p>
<ul>
<li>New HTTP paths that extend non-root paths MUST NOT be defined.</li>
<li>New root HTTP paths MAY be defined as long as they do not use Registry level
HTTP paths or attribute names. This includes extension and GROUPS collection
attribute names.</li>
<li>Additional HTTP methods for specification-defined HTTP paths MUST NOT be
defined.</li>
</ul>
<p>For example, a new API with an HTTP path of <code>/my-api</code> is allowed, but APIs with
<code>/model/my-api</code> or <code>/name</code> HTTP paths are not.</p>
<p>This specification attempts to follow a standard REST/HTTP processing model.
The following key aspects are called out to help understand the overall
pattern of the APIs:</p>
<ul>
<li>A <code>PUT</code> or <code>POST</code> operation is a full replacement of the entities being
processed. Any missing attributes MUST be interpreted as a request for them
to be deleted. However, attributes that are managed by the server might have
specialized processing in those cases, in particular, mandatory attributes
as well as ones that have default values defined, MUST be reset to their
default values rather than deleted.</li>
<li>A <code>PATCH</code> operation MUST only modify the attributes explicitly mentioned
in the request. Any attribute with a value of <code>null</code> MUST be interpreted
as a request to delete the attribute, and as with <code>PUT</code>/<code>POST</code>, server
managed attributes might have specialized processing.</li>
<li><code>PUT</code> MUST NOT be targeted at xRegistry collections. A <code>POST</code> or <code>PATCH</code>
MUST be used instead to add entities to the collection, and a
<code>DELETE</code> MUST be used to delete unwanted entities.</li>
<li><code>POST</code> operations MUST only be targeted at xRegistry collections, not
individual entities - with the exception of a Resource entity. In that case
a <code>POST</code> to a Resource URL MUST be treated as an alias for a <code>POST</code> to the
Resource's <code>versions</code> collection.</li>
<li>Unknown query parameters SHOULD be silently ignored by servers. This
includes specification-defined but unsupported query parameters.</li>
</ul>
<p>In general, if a server is unable to retrieve all of the data intended to be
sent in a response, then an error
(<a href="#data_retrieval_error">data_retrieval_error</a>) MUST be generated and the
request rejected without any changes being made. However, it is permissible
for a server to attempt some creative processing. For example, if while
processing a <code>GET</code> the server can only retrieve half of the entities to be
returned at the current point in time, then it could return those with an
indication of there being more (via the <a href="../pagination/spec.md">pagination
specification</a>). Then during the next <code>GET</code> request it
could return the remainder of the data - or an error if it is still not
available. Note that if an entity is to be sent, then it MUST be serialized in
its entirety (all attributes, and requested child entities) or an error MUST
be generated.</p>
<p>There might be situations where someone will do a <code>GET</code> to retrieve data
from a Registry, and then do an update operation to a Registry with that data.
Depending on the use case, they might not want some of the retrieved data
to be applied during the update - for example, they might not want the
<code>epoch</code> validation checking to occur. Rather than forcing the user to edit
the data to remove the potentially problematic attributes, the following
query parameters MAY be included on write operations to control certain
aspects of the processing:</p>
<ul>
<li><code>?noepoch</code> - presence of this query parameter indicates that any <code>epoch</code>
attribute included in the request MUST be ignored.</li>
<li><code>?nodefaultversionid</code> - presence of this query parameter indicates that any
<code>defaultversionid</code> attribute included in the request MUST be ignored.</li>
<li><code>?nodefaultversionsticky</code> - presence of this query parameter indicates that
any <code>defaultversionsticky</code> attribute included in the request MUST be ignored.</li>
<li><code>?noreadonly</code> - presence of this query parameter indicates that any attempt
to update a read-only Resource MUST be silently ignored.</li>
</ul>
<p>Any JSON xRegistry metadata message that represents a single entity (i.e. not
a map) MAY include a top-level &quot;$schema&quot; attribute that points to a JSON Schema
document that describes the message contents. These notations can be used or
ignored by receivers of these messages. There is no requirement for
implementation of this specification to persist these values, to include them
in responses or to use this information.</p>
<h4 id="no-code-servers"><a class="anchor" href="#no-code-servers">☍</a> No-Code Servers</h4>
<p>One of the goals of xRegistry is to be as broadly supported as possible.
Requiring all xRegistry endpoints to support the full range of APIs defined
in this specification might not be feasible in all cases. In particular, there
might be cases where someone wishes to host a read-only xRegistry server to
only expose their documents (and metadata) and therefore the write operations
or advanced features (such as inlining or filtering) might not be needed.
In those cases, simple file serving HTTP servers, such as blob stores, ought
to be sufficient, and in those cases requiring support for query parameters
and other advanced features (that could require code) might not always be
possible.</p>
<p>To support these simple (no-code) scenarios, this specification is written
such that all of the APIs are OPTIONAL, and all of the query parameters on
the read operations are OPTIONAL (typically specified by saying that they
<code>SHOULD</code> be supported). However, it is STRONGLY RECOMMENDED that full API
servers support the query parameters when possible to enable a better user
experience, and increase interoperability.</p>
<p>Note that simple file servers SHOULD support exposing Resources where the HTTP
body response contains the Resource's associated &quot;document&quot; as well as the
case where the HTTP response body contains a JSON serialization of the
Resource via the <code>$details</code> suffix on the URL path. This can be achieved by
creating a secondary sibling file on disk with <code>$details</code> at the end of its
filename.</p>
<hr>
<p>The remainder of this specification mainly focuses on the successful interaction
patterns of the APIs. For example, most examples will show an HTTP &quot;200 OK&quot;
as the response. Each implementation MAY choose to return a more appropriate
response based on the specific situation. For example, in the case of an
authentication error the server could return <code>401 Unauthorized</code>.</p>
<p>The following sections define the APIs in more detail.</p>
<hr>
<h4 id="registry-collections"><a class="anchor" href="#registry-collections">☍</a> Registry Collections</h4>
<p>Registry collections (<code>GROUPS</code>, <code>RESOURCES</code> and <code>versions</code>) that are defined
by the <a href="#registry-model">Registry Model</a> MUST be serialized according to the
rules defined below.</p>
<p>The serialization of a collection is done as 3 attributes and they MUST adhere
to their respective forms as follows:</p>
<pre><code class="language-yaml">&quot;COLLECTIONSurl&quot;: &quot;URL&quot;,
&quot;COLLECTIONScount&quot;: UINTEGER,
&quot;COLLECTIONS&quot;: {
  # Map of entities in the collection, key is the &quot;SINGULARid&quot; of the entity
}
</code></pre>
<p>Where:</p>
<ul>
<li>The term <code>COLLECTIONS</code> MUST be the plural name of the collection
(e.g. <code>endpoints</code>, <code>versions</code>).</li>
<li>The <code>COLLECTIONSurl</code> attribute MUST be a URL that can be used to retrieve
the <code>COLLECTIONS</code> map via an HTTP(s) <code>GET</code> (including any necessary
<a href="#filter-flag">filtering</a>) and MUST be a read-only attribute that MUST
be silently ignored by a server during a write operation. An empty
collection MUST return an HTTP 200 with an empty map (<code>{}</code>). This attribute
MUST be an absolute URL except when <code>?doc</code> is enabled and the collection
is inlined, in which case it MUST be a relative URL.</li>
<li>The <code>COLLECTIONScount</code> attribute MUST contain the number of entities in the
<code>COLLECTIONS</code> map (after any necessary <a href="#filter-flag">filtering</a>) and MUST
be a read-only attribute that MUST be silently ignored by a server during
a write operation.</li>
<li>The <code>COLLECTIONS</code> attribute is a map and MUST contain the entities of the
collection (after any necessary <a href="#filter-flag">filtering</a>), and MUST use
the <code>SINGULARid</code> of each entity as its map key.</li>
<li>The key of each entity in the collection MUST be unique within the scope of
the collection.</li>
<li>The specifics of whether each attribute is REQUIRED or OPTIONAL will be
based on whether the document- or API-view is being used - see the next
section.</li>
</ul>
<p>When the <code>COLLECTIONS</code> attribute is expected to be present in the
serialization, but the number of entities in the collection is zero, it MUST
still be included as an empty map (e.g. <code>{}</code>).</p>
<p>The set of entities that are part of the <code>COLLECTIONS</code> attribute is a
point-in-time view of the Registry. There is no guarantee that a future <code>GET</code>
to the <code>COLLECTIONSurl</code> will return the exact same collection since the
contents of the Registry might have changed. This specification makes no
statement as to whether a subsequent <code>GET</code> that is missing previously returned
entities is an indication of those entities being deleted or not.</p>
<p>Since collections could be too large to retrieve in one request, when
retrieving a collection, the client MAY request a subset by using the
<a href="../pagination/spec.md">pagination specification</a>. Likewise, the server
MAY choose to return a subset of the collection using the same mechanism
defined in that specification even if the request didn't ask for pagination.
The pagination specification MUST only be used when the request is directed at
a collection, not at its owning entity (such as the root of the Registry,
or at an individual Group or Resource).</p>
<p>In the remainder of the specification, the presence of the <code>Link</code> HTTP header
indicates the use of the <a href="../pagination/spec.md">pagination specification</a>
MAY be used for that API.</p>
<p>The requirements on the presence of the 3 <code>COLLECTIONS</code> attributes varies
between document and API views, and is defined below:</p>
<h5 id="collections-in-document-view"><a class="anchor" href="#collections-in-document-view">☍</a> Collections in Document View</h5>
<p>In document view:</p>
<ul>
<li><code>COLLECTIONSurl</code> and <code>COLLECTIONScount</code> are OPTIONAL.</li>
<li><code>COLLECTIONS</code> is conditional in responses based on the values in the
<a href="#inline-flag">Inline Flag</a>. If a collection is part of the flag's value then
<code>COLLECTIONS</code> MUST be present in the response even if it is empty
(e.g. <code>{}</code>). If the collection is not part of the flag value then
<code>COLLECTIONS</code> MUST NOT be included in the response.</li>
</ul>
<h5 id="collections-in-api-view"><a class="anchor" href="#collections-in-api-view">☍</a> Collections in API View</h5>
<p>In API view:</p>
<ul>
<li><code>COLLECTIONSurl</code> is REQUIRED for responses even if there are no entities
in the collection.</li>
<li><code>COLLECTIONScount</code> is STRONGLY RECOMMENDED for responses even if
there are no entities in the collection. This requirement is not mandated
to allow for cases where calculating the exact count is too costly.</li>
<li><code>COLLECTIONSurl</code> and <code>COLLECTIONScount</code> are OPTIONAL for requests and MUST
be silently ignored by the server if present.</li>
<li><code>COLLECTIONS</code> is conditional in responses based on the values in the
<a href="#inline-flag">Inline Flag</a>. If a collection is part of the flag's value then
<code>COLLECTIONS</code> MUST be present in the response even if it is empty
(e.g. <code>{}</code>). If the collection is not part of the flag value then
<code>COLLECTIONS</code> MUST NOT be included in the response.</li>
<li><code>COLLECTIONS</code> is OPTIONAL for requests. See <a href="#updating-nested-registry-collections">Updating Nested Registry
Collections</a> for more details.</li>
</ul>
<h5 id="updating-nested-registry-collections"><a class="anchor" href="#updating-nested-registry-collections">☍</a> Updating Nested Registry Collections</h5>
<p>When updating an entity that can contain Registry collections, the request
MAY contain the 3 collection attributes. The <code>COLLECTIONSurl</code> and
<code>COLLECTIONScount</code> attributes MUST be silently ignored by the server.</p>
<p>If the <code>COLLECTIONS</code> attribute is present, the server MUST process each entity
in the collection map as a request to create or update that entity according to
the semantics of the HTTP method used. An entry in the map that isn't a valid
entity (e.g. is <code>null</code>) MUST generate an error (<a href="#bad_request">bad_request</a>).</p>
<p>For example:</p>
<pre><code class="language-yaml">PUT https://example.com/endpoints/ep1

{
  &quot;endpointid&quot;: &quot;ep1&quot;,
  &quot;name&quot;: &quot;A cool endpoint&quot;,

  &quot;messages&quot;: {
    &quot;mymsg1&quot;: { ... },
    &quot;mymsg2:&quot; { ... }
  }
}
</code></pre>
<p>will not only create/update an <code>endpoint</code> Group with an <code>endpointid</code> of <code>ep1</code>
but will also create/update its <code>message</code> Resources (<code>mymsg1</code> and <code>mymsg2</code>).</p>
<p>Any error while processing a nested collection entity MUST result in the entire
request being rejected.</p>
<p>An absent <code>COLLECTIONS</code> attribute MUST be interpreted as a request to not
modify the collection at all.</p>
<p>If a client wishes to replace an entire collection, rather than just add new
entities, the client MUST use one of the <code>DELETE</code> operations on the collection
first.</p>
<p>In cases where an update operation includes attributes meant to be applied
to the &quot;default&quot; Version of a Resource, and the incoming inlined <code>versions</code>
collections includes that &quot;default&quot; Version, the Resource's default Version
attributes MUST be silently ignored. This is to avoid any possible conflicting
data between the two sets of data for that Version. In other words, the
Version attributes in the incoming <code>versions</code> collection wins.</p>
<p>To better understand this scenario, consider the following HTTP request to
update a Message where the <code>defaultversionid</code> is <code>v1</code>:</p>
<pre><code class="language-yaml">PUT http://example.com/endpoints/ep1/messages/msg1

{
  &quot;messageid&quot;: &quot;msg1&quot;,
  &quot;versionid&quot;: &quot;v1&quot;,
  &quot;name&quot;: &quot;Blob Created&quot;

  &quot;versions&quot;: {
    &quot;v1&quot;: {
      &quot;messageid&quot;: &quot;msg1&quot;,
      &quot;versionid&quot;: &quot;v1&quot;,
      &quot;name&quot;: &quot;Blob Created Message Definition&quot;
    }
  }
}
</code></pre>
<p>If the <code>versions</code> collection were not present with the <code>v1</code> entity then the
top-level attributes would be used to update the default Version (<code>v1</code> in this
case). However, because it is present, the request to update <code>v1</code> becomes
ambiguous because it is not clear if the server is meant to use the top-level
attributes or if it is to use the attributes under the <code>v1</code> entity of the
<code>versions</code> collection. When both sets of attributes are the same, then it does
not matter. However, in these cases the <code>name</code> attributes have different
values. The paragraph above mandates that in these potentially ambiguous cases
the entity in the <code>versions</code> collection is to be used and the top-level
attributes are to be ignored - for the purposes of updating the &quot;default&quot;
Version's attributes. So, in this case the <code>name</code> of the default (<code>v1</code>)
Version will be <code>Blob Created Message Definition</code>.</p>
<hr>
<h4 id="entity-processing-rules"><a class="anchor" href="#entity-processing-rules">☍</a> Entity Processing Rules</h4>
<p>Rather than repeating the processing rules for each type of xRegistry
entity or Registry collection, the overall pattern is defined once in this
section and any entity-, or collection-specific rules will be detailed in the
appropriate section in the specification.</p>
<h5 id="creating-or-updating-entities"><a class="anchor" href="#creating-or-updating-entities">☍</a> Creating or Updating Entities</h5>
<p>This defines the general rules for how to update entities.</p>
<p>Creating or updating entities MAY be done using HTTP <code>PUT</code>, <code>PATCH</code> or <code>POST</code>
methods:</p>
<ul>
<li><code>PUT    PATH-TO-ENTITY[?OPTIONS]</code>           # Process a single entity</li>
<li><code>PATCH  PATH-TO-ENTITY[?OPTIONS]</code>           # Process a single entity</li>
<li><code>PATCH  PATH-TO-COLLECTION[?OPTIONS]</code>       # Process a set of entities</li>
<li><code>POST   PATH-TO-COLLECTION[?OPTIONS]</code>       # Process a set of entities</li>
</ul>
<p>Based on the entity being processed, the <code>OPTIONS</code> available will vary.</p>
<p>The <code>PUT</code> variant MUST adhere to the following:</p>
<ul>
<li>The URL MUST be of the form: <code>PATH-TO-ENTITY</code>.</li>
<li>The HTTP body MUST contain the full updated serialization of the entity to
be processed.</li>
<li>The entity processed MUST either be created (if it does not already
exist), or updated (if it does exist).</li>
<li>Any mutable attribute which is either missing or present with a value of
<code>null</code>, MUST be interpreted as a request to delete the attribute.</li>
<li>Excluding any Registry collection attributes, all mutable attributes
specified MUST be a full serialization of the attribute. Any missing
nested attribute MUST be interpreted as a request to delete the attribute.</li>
</ul>
<p>The <code>POST</code> variant MUST adhere to the following:</p>
<ul>
<li>The HTTP body MUST contain a JSON map where the key MUST be the
<code>SINGULARid</code> of each entity in the map. Note, that in the case of a map of
Versions, the <code>versionid</code> is used instead.</li>
<li>Each value in the map MUST be the full serialization of the entity to be
either added or updated. Note that <code>POST</code> does not support deleting
entities from a collection, so a separate delete operation might be needed
if there are entities that need to be removed.</li>
<li>The processing of each individual entity in the map MUST follow the same
rules as defined for <code>PUT</code> above.</li>
</ul>
<p>The <code>PATCH</code> variant when directed at a single entity, MUST adhere to the <code>PUT</code>
semantics defined above with the following exceptions:</p>
<ul>
<li>Any mutable attribute which is missing MUST be interpreted as a request to
leave it unchanged. However, modifying some other attribute (or some other
server semantics) MAY modify it. A value of <code>null</code> MUST be interpreted as
a request to delete the attribute.</li>
<li>When processing a Resource or Version, that has its <code>hasdocument</code> model
aspect set to <code>true</code>, the URL accessing the entity MUST include the
<code>$details</code> suffix, and MUST generate an error
(<a href="#details_required">details_required</a>) in the absence of the
<code>$details</code> suffix. This is because when it is absent, the processing of
the HTTP <code>xRegistry-</code> headers are already defined with &quot;patch&quot; semantics
so a normal <code>PUT</code> or <code>POST</code> can be used instead. Using <code>PATCH</code> in this
case would mean that the request is also trying to &quot;patch&quot; the Resource's
&quot;document&quot;, which this specification does not support at this time.</li>
<li><code>PATCH</code> MAY be used to create new entities, but as with any of the create
operations, any missing REQUIRED attributes MUST generate an error
(<a href="#required_attribute_missing">required_attribute_missing</a>).</li>
</ul>
<p>The <code>PATCH</code> variant when directed at an xRegistry collection, MUST adhere to
the following:</p>
<ul>
<li>The HTTP body MUST contain a JSON map where the key MUST be the
<code>SINGULARid</code> of each entity in the map. Note, that in the case of a map of
Versions, the <code>versionid</code> is used instead.</li>
<li>Each value in the map MUST contain just the attributes that are to be
updated for that entity. See <code>PATCH</code> semantics when directed as a single
entity above.</li>
<li>The processing of each individual entity in the map MUST follow the same
rules as defined for <code>PATCH</code> of a single entity above.</li>
</ul>
<p>The processing of each individual entity follows the same set of rules:</p>
<ul>
<li>If an entity with the specified <code>SINGULARid</code> already exists then it MUST be
interpreted as a request to update the existing entity. Otherwise, it MUST
be interpreted as a request to create a new entity with that value.</li>
<li>See the definition of each attribute for the rules governing how it is
processed.</li>
<li>All attributes present MUST be a full representation of its value. This means
any complex attributes (e.g. object, maps), MUST be fully replaced by the
incoming value.</li>
<li>A request to update, or delete, a read-only attribute MUST be silently
ignored. However, a request that includes a <code>SINGULARid</code> MUST be compared
with the entity's current value and if it differs then an error
(<a href="#mismatched_id">mismatched_id</a>) MUST be generated. This includes both
<code>RESOURCEid</code> and <code>versionid</code> in the case of Resources and Versions. This is
to prevent accidentally updating the wrong entity.</li>
<li>A request to update a mutable attribute with an invalid value MUST generate
an error (<a href="#invalid_data">invalid_data</a>) (this includes deleting a
mandatory mutable attribute).</li>
<li>Any Registry collection attributes MUST be processed per the rules specified
in the <a href="#updating-nested-registry-collections">Updating Nested Registry
Collections</a> section.</li>
<li>Any error during the processing of an entity, or its nested entities, MUST
result in the entire request being rejected and no updates performed.</li>
</ul>
<p>A successful response MUST return the same response as a <code>GET</code> to the entity
(or entities) processed, showing their current representation, with the
following exceptions:</p>
<ul>
<li>In the <code>POST</code> case, or a <code>PATCH</code> directed to an xRegistry collection, the
result MUST contain only the entities processed,
not the entire Registry collection, nor any entities deleted as a result
of processing the request.</li>
<li>In the <code>PUT</code> or <code>PATCH</code> cases that are directed to a single entity, for a
newly created entity, the HTTP status MUST be <code>201 Created</code>, and it MUST
include an HTTP <code>Location</code> header with a URL to the newly created entity.
Note that this URL MUST be the same as the <code>self</code> attribute of that entity.</li>
</ul>
<p>Otherwise an HTTP <code>200 OK</code> without an HTTP <code>Location</code> header MUST be returned.</p>
<p>Note that the response MUST be generated applying the semantics of any
query parameters specified on the request URL (e.g. <code>?inline</code>). If an error
occurs while generating the response (e.g. invalid <code>?filter</code>), then
an error MUST be generated and the entire operation MUST be undone.</p>
<h5 id="retrieving-a-registry-collection"><a class="anchor" href="#retrieving-a-registry-collection">☍</a> Retrieving a Registry Collection</h5>
<p>To retrieve a Registry collection, an HTTP <code>GET</code> MAY be used. The request
MUST be of the form:</p>
<pre><code class="language-yaml">GET PATH-TO-COLLECTION
</code></pre>
<p>A successful response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Link: &lt;URL&gt;;rel=next;count=UINTEGER ?

{
  &quot;KEY&quot;: {                                           # SINGULARid value
    &quot;SINGULARid&quot;: &quot;STRING&quot;,
    ... remaining entity attributes ...
  } *
}
</code></pre>
<h5 id="retrieving-an-entity-from-a-registry-collection"><a class="anchor" href="#retrieving-an-entity-from-a-registry-collection">☍</a> Retrieving an Entity from a Registry Collection</h5>
<p>To retrieve an entity, an HTTP <code>GET</code> MAY be used. The request MUST be of the
form:</p>
<pre><code class="language-yaml">GET PATH-TO-COLLECTION/ID-OF-ENTITY
</code></pre>
<p>A successful response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;SINGULARid&quot;: &quot;STRING&quot;,
  ... remaining entity attributes ...
}
</code></pre>
<h5 id="deleting-entities-in-a-registry-collection"><a class="anchor" href="#deleting-entities-in-a-registry-collection">☍</a> Deleting Entities in a Registry Collection</h5>
<p>There are two ways to delete entities from a Registry collection:</p>
<ol>
<li>to delete a single entity, an HTTP <code>DELETE</code> MAY be used. The request MUST
be of the form:</li>
</ol>
<pre><code class="language-yaml">DELETE PATH-TO-COLLECTION/ID-OF-ENTITY[?epoch=UINTEGER]
</code></pre>
<p>Where:</p>
<ul>
<li>The request body SHOULD be empty.</li>
<li>If the entity cannot be found, then an error (<a href="#not_found">not_found</a>) MUST
be generated.</li>
<li>In the case of deleting Resources, a <code>DELETE</code> directed to the <code>meta</code>
sub-object is not supported and MUST generate an error
(<a href="#method_not_allowed">method_not_allowed</a>).</li>
</ul>
<p>The following query parameter SHOULD be supported by servers:</p>
<ul>
<li><code>epoch</code><br>
The presence of this query parameter indicates that the server MUST check
to ensure that the <code>epoch</code> value matches the entity's current <code>epoch</code> value
and if it differs then an error (<a href="#mismatched_epoch">mismatched_epoch</a>) MUST
be generated.</li>
</ul>
<ol start="2">
<li>to delete multiple entities within a Registry collection, the request MUST
be in one of two forms:</li>
</ol>
<p>For non-Resource entities:</p>
<pre><code class="language-yaml">DELETE PATH-TO-COLLECTION

{
  &quot;KEY&quot;: {                                            # SINGULARid of entity
    &quot;epoch&quot;: UINTEGER ?
  } *
} ?
</code></pre>
<p>or</p>
<p>For Resource entities (see below for more details):</p>
<pre><code class="language-yaml">DELETE PATH-TO-COLLECTION

{
  &quot;KEY&quot;: {                                            # SINGULARid of entity
    &quot;meta&quot;: {
      &quot;epoch&quot;: UINTEGER ?
    } ?
  } *
} ?
</code></pre>
<p>Where:</p>
<ul>
<li>If the request body is empty (no map), then all entities in the collection
MUST be deleted.</li>
<li>If the request body is not empty, then it MUST be a map containing zero or
more entries where the key of each entry is each entity's unique
identifier - which is the <code>SINGULARid</code> of the entity.</li>
<li>When an <code>epoch</code> value is specified for an entity then the server MUST check
to ensure that the value matches the entity's current <code>epoch</code> value and if it
differs then an error (<a href="#mismatched_epoch">mismatched_epoch</a>) MUST be
generated.</li>
<li>When deleting Resources, since the <code>epoch</code> attribute is located under the
<code>meta</code> sub-object (and not as a top-level entity attribute), if included
in the <code>DELETE</code> request, it MUST appear under a <code>meta</code> sub-object. Any
additional <code>epoch</code> at the top-level MUST be silently ignored. Additionally,
<code>DELETE</code> request of Resources that only has <code>epoch</code> at a top-level attribute,
but not as a <code>meta</code> attribute, MUST generate an error
(<a href="#misplaced_epoch">misplaced_epoch</a>) as it is likely that the client is
using the Resource's default Version <code>epoch</code> value by mistake.  A top-level
<code>epoch</code> in the presence of a <code>meta</code> <code>epoch</code> MUST be ignored.</li>
<li>If the entity's unique identifier is present in the object, then it MUST
match its corresponding <code>KEY</code> value.</li>
<li>Any other entity attributes that are present in the request MUST be silently
ignored, even if their values are invalid.</li>
<li>If one of the referenced entities cannot be found, then the server MUST
silently ignore this condition and not treat it as an error.</li>
</ul>
<p>Whether the request is to delete a single entity or multiple, deleting an
entity MUST delete all children entities as well - meaning, any entities
within any nested Registry collections.</p>
<p>Any error MUST result in the entire request being rejected.</p>
<p>A successful response MUST return either:</p>
<pre><code class="language-yaml">HTTP/1.1 204 No Content
</code></pre>
<p>with an empty HTTP body, or:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
</code></pre>
<p>if, as an extension, the server chooses to return additional data in the
HTTP body.</p>
<hr>
<h3 id="registry-entity"><a class="anchor" href="#registry-entity">☍</a> Registry Entity</h3>
<p>The Registry entity represents the root of a Registry and is the main
entry-point for traversal and discovery.</p>
<p>The serialization of the Registry entity adheres to this form:</p>
<pre><code class="language-yaml">{
  &quot;specversion&quot;: &quot;STRING&quot;,
  &quot;registryid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,
  &quot;epoch&quot;: UINTEGER,
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,

  &quot;capabilities&quot;: { Registry capabilities }, ?   # Only if inlined
  &quot;model&quot;: { Registry model }, ?                 # Only if inlined

  # Repeat for each Group type
  &quot;GROUPSurl&quot;: &quot;URL&quot;,                            # e.g. &quot;endpointsurl&quot;
  &quot;GROUPScount&quot;: UINTEGER,                       # e.g. &quot;endpointscount&quot;
  &quot;GROUPS&quot;: { GROUPS collection } ?              # Only if inlined
}
</code></pre>
<p>The Registry entity includes the following
<a href="#common-attributes">common attributes</a>:</p>
<ul>
<li><a href="#singularid-id-attribute"><code>registryid</code></a> - REQUIRED in API and document
views. OPTIONAL in requests.</li>
<li><a href="#self-attribute"><code>self</code></a> - REQUIRED in API and document views. OPTIONAL
in requests.</li>
<li><a href="#shortself-attribute"><code>shortself</code></a> - OPTIONAL in API and document views,
based on the <code>shortself</code> capability. OPTIONAL in requests.</li>
<li><a href="#xid-attribute"><code>xid</code></a> - REQUIRED in API and document views. OPTIONAL in
requests.</li>
<li><a href="#epoch-attribute"><code>epoch</code></a> - REQUIRED in API and document view. OPTIONAL
in requests.</li>
<li><a href="#name-attribute"><code>name</code></a> - OPTIONAL.</li>
<li><a href="#description-attribute"><code>description</code></a> - OPTIONAL.</li>
<li><a href="#documentation-attribute"><code>documentation</code></a> - OPTIONAL.</li>
<li><a href="#labels-attribute"><code>labels</code></a> - OPTIONAL.</li>
<li><a href="#createdat-attribute"><code>createdat</code></a> - REQUIRED in API and document views.
OPTIONAL in requests.</li>
<li><a href="#modifiedat-attribute"><code>modifiedat</code></a> - REQUIRED in API and document views.
OPTIONAL in requests.</li>
</ul>
<p>and the following Registry level attributes:</p>
<h5 id="specversion-attribute"><a class="anchor" href="#specversion-attribute">☍</a> <code>specversion</code> Attribute</h5>
<ul>
<li>
<p>Type: String</p>
</li>
<li>
<p>Description: The version of this specification that the serialization
adheres to</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be a read-only attribute.</li>
<li>MUST be non-empty.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>1.0</code></li>
</ul>
</li>
</ul>
<h5 id="model-attribute"><a class="anchor" href="#model-attribute">☍</a> <code>model</code> Attribute</h5>
<ul>
<li>
<p>Type: Registry Model</p>
</li>
<li>
<p>Description: A description of the features, extension attributes, Groups and
Resources supported by this Registry. See <a href="#registry-model">Registry Model</a></p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>MUST NOT be included in API and document views unless requested.</li>
<li>MUST be included in API and document views if requested.</li>
</ul>
</li>
</ul>
<h5 id="groups-collections"><a class="anchor" href="#groups-collections">☍</a> <code>GROUPS</code> Collections</h5>
<ul>
<li>
<p>Type: Set of <a href="#registry-collections">Registry Collections</a></p>
</li>
<li>
<p>Description: A list of Registry collections that contain the set of Groups
supported by the Registry.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>It MUST include all nested Group Collection types in the
Registry, even if some of the collections are empty.</li>
</ul>
</li>
</ul>
<h4 id="retrieving-the-registry"><a class="anchor" href="#retrieving-the-registry">☍</a> Retrieving the Registry</h4>
<p>To retrieve the Registry, its metadata attributes, and Groups, an HTTP <code>GET</code>
MAY be used.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">GET /[?specversion=...]
</code></pre>
<p>The following query parameter SHOULD be supported by servers:</p>
<ul>
<li><code>specversion</code><br>
The presence of this OPTIONAL query parameter indicates that the response
MUST adhere to the xRegistry specification version specified
(case-insensitive). If the version is not supported, then an error
(<a href="#unsupported_specversion">unsupported_specversion</a>) MUST be generated.
Note that this query parameter MAY be included on any API request to the
server, not just the root of the Registry. When not specified, the default
value MUST be the newest version of this specification supported by the
server.</li>
</ul>
<p>A successful response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;specversion&quot;: &quot;STRING&quot;,
  &quot;registryid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,
  &quot;epoch&quot;: UINTEGER,
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,

  &quot;capabilities&quot;: { Registry capabilities }, ?   # Only if inlined
  &quot;model&quot;: { Registry model }, ?                 # Only if inlined

  # Repeat for each Group type
  &quot;GROUPSurl&quot;: &quot;URL&quot;,                 # e.g. &quot;endpointsurl&quot;
  &quot;GROUPScount&quot;: UINTEGER,            # e.g. &quot;endpointscount&quot;
  &quot;GROUPS&quot;: { GROUPS collection } ?   # Only if inlined
}
</code></pre>
<p><strong>Examples:</strong></p>
<p>Retrieve a Registry that has 2 types of Groups (<code>endpoints</code> and
<code>schemagroups</code>):</p>
<pre><code class="language-yaml">GET /
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;specversion&quot;: &quot;1.0-rc1&quot;,
  &quot;registryid&quot;: &quot;myRegistry&quot;,
  &quot;self&quot;: &quot;https://example.com/&quot;,
  &quot;xid&quot;: &quot;/&quot;,
  &quot;epoch&quot;: 1,
  &quot;createdat&quot;: &quot;2024-04-30T12:00:00Z&quot;,
  &quot;modifiedat&quot;: &quot;2024-04-30T12:00:01Z&quot;,

  &quot;endpointsurl&quot;: &quot;https://example.com/endpoints&quot;,
  &quot;endpointscount&quot;: 42,

  &quot;schemagroupsurl&quot;: &quot;https://example.com/schemagroups&quot;,
  &quot;schemagroupscount&quot;: 1
}
</code></pre>
<p>Another example where:</p>
<ul>
<li>The request asks for the model to be included in the response.</li>
<li>The request asks for the <code>schemagroups</code> Group to be inlined in the response.</li>
<li>The <code>endpoints</code> Group has one extension attribute defined.</li>
</ul>
<pre><code class="language-yaml">GET /?inline=schemagroups,model

HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;specversion&quot;: &quot;1.0-rc1&quot;,
  &quot;registryid&quot;: &quot;myRegistry&quot;,
  &quot;self&quot;: &quot;https://example.com/&quot;,
  &quot;xid&quot;: &quot;/&quot;,
  &quot;epoch&quot;: 1,
  &quot;createdat&quot;: &quot;2024-04-30T12:00:00Z&quot;,
  &quot;modifiedat&quot;: &quot;2024-04-30T12:00:01Z&quot;,

  &quot;model&quot;: {
    ... xRegistry spec-defined attributes excluded for brevity ...
    &quot;groups&quot;: {
      &quot;endpoints&quot;: {
        &quot;plural&quot;: &quot;endpoints&quot;,
        &quot;singular&quot;: &quot;endpoint&quot;,
        &quot;attributes&quot;: {
          ... xRegistry spec-defined attributes excluded for brevity ...
          &quot;shared&quot;: {
            &quot;name&quot;: &quot;shared&quot;,
            &quot;type&quot;: &quot;boolean&quot;
          }
        },

        &quot;resources&quot;: {
          &quot;messages&quot;: {
            &quot;plural&quot;: &quot;messages&quot;,
            &quot;singular&quot;: &quot;message&quot;,
            &quot;attributes&quot;: {
              ... xRegistry spec-defined attributes excluded for brevity ...
              &quot;*&quot;: {
                type: &quot;any&quot;
              }
            },
            &quot;maxversions&quot;: 1
          }
        }
      },
      &quot;schemagroups&quot;: {
        &quot;plural&quot;: &quot;schemagroups&quot;,
        &quot;singular&quot;: &quot;schemagroup&quot;,
        ... xRegistry spec-defined attributes excluded for brevity ...

        &quot;resources&quot;: {
          &quot;schemas&quot;: {
            &quot;plural&quot;: &quot;schemas&quot;,
            &quot;singular&quot;: &quot;schema&quot;,
            ... xRegistry spec-defined attributes excluded for brevity ...
            &quot;maxversions&quot;: 1
          }
        }
      }
    }
  },

  &quot;endpointsurl&quot;: &quot;https://example.com/endpoints&quot;,
  &quot;endpointscount&quot;: 42,

  &quot;schemagroupsurl&quot;: &quot;https://example.com/schemagroups&quot;,
  &quot;schemagroupscount&quot;: 1,
  &quot;schemagroups&quot;: {
    &quot;mySchemas&quot;: {
      &quot;schemaid&quot;: &quot;mySchemas&quot;,
      # Remainder of schemagroup is excluded for brevity
    }
  }
}
</code></pre>
<h4 id="updating-the-registry-entity"><a class="anchor" href="#updating-the-registry-entity">☍</a> Updating the Registry Entity</h4>
<p>To update the Registry entity, an HTTP <code>PUT</code> or <code>PATCH</code> MAY be used.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">PUT /
or
PATCH /
Content-Type: application/json; charset=utf-8
If-Match: &quot;UINTEGER|*&quot; ?

{
  &quot;registryid&quot;: &quot;STRING&quot;, ?
  &quot;epoch&quot;: UINTEGER, ?
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;, ?
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;, ?

  &quot;model&quot;: { Registry model }, ?

  # Repeat for each Group type
  &quot;GROUPS&quot;: { GROUPS collection } ?
}
</code></pre>
<p>Where:</p>
<ul>
<li>The HTTP body MUST contain the full JSON representation of the Registry
entity's mutable attributes.</li>
<li>The request MAY include the <code>'model</code> attribute if the Registry model
definitions are to be updated as part of the request. See <a href="#updating-the-registry-model">Updating the
Registry Model</a> for more information.
If present, the Registry's model MUST be updated prior to any entities being
updated. A value of <code>null</code> MUST generate an error
(<a href="#invalid_data">invalid_data</a>).</li>
</ul>
<p>A successful response MUST include the same content that an HTTP <code>GET</code>
on the Registry would return, and be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;specversion&quot;: &quot;STRING&quot;,
  &quot;registryid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,
  &quot;epoch&quot;: UINTEGER,
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,

  # Repeat for each Group type
  &quot;GROUPSurl&quot;: &quot;URL&quot;,
  &quot;GROUPScount&quot;: UINTEGER
}
</code></pre>
<p>Note that the response MUST NOT include the <code>model</code> attribute, nor any
inlined GROUPS collections.</p>
<p><strong>Examples:</strong></p>
<p>Updating a Registry's metadata</p>
<pre><code class="language-yaml">PUT /
Content-Type: application/json; charset=utf-8

{
  &quot;registryid&quot;: &quot;myRegistry&quot;,
  &quot;name&quot;: &quot;My Registry&quot;,
  &quot;description&quot;: &quot;An even cooler registry!&quot;
}
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;specversion&quot;: &quot;1.0-rc1&quot;,
  &quot;registryid&quot;: &quot;myRegistry&quot;,
  &quot;self&quot;: &quot;https://example.com/&quot;,
  &quot;xid&quot;: &quot;/&quot;,
  &quot;epoch&quot;: 2,
  &quot;name&quot;: &quot;My Registry&quot;,
  &quot;description&quot;: &quot;An even cooler registry!&quot;,
  &quot;createdat&quot;: &quot;2024-04-30T12:00:00Z&quot;,
  &quot;modifiedat&quot;: &quot;2024-04-30T12:00:01Z&quot;,

  &quot;endpointsurl&quot;: &quot;https://example.com/endpoints&quot;,
  &quot;endpointscount&quot;: 42,

  &quot;schemagroupsurl&quot;: &quot;https://example.com/schemagroups&quot;,
  &quot;schemagroupscount&quot;: 1
}
</code></pre>
<hr>
<h3 id="registry-capabilities"><a class="anchor" href="#registry-capabilities">☍</a> Registry Capabilities</h3>
<p>In order to programmatically discover which capabilities are supported by an
implementation, servers MUST support exposing this information via a
&quot;capabilities&quot; map that lists each supported feature along with any related
configuration detail that will help in successful usage of that feature.</p>
<p>The &quot;key&quot; of the capabilities-map is the &quot;name&quot; of each feature, and the
&quot;value&quot; is a feature specific set of configuration values. With the most basic
being a <code>BOOLEAN</code> value of <code>true</code> to indicate support for the feature.</p>
<p>The capabilities-map MAY be retrieved via two mechanisms:</p>
<ul>
<li>An HTTP <code>GET</code> request to the <code>/capabilities</code> API and MUST be supported
by all compliant implementations. However, as with all defined APIs,
security/access controls MAY be mandated.</li>
<li>The Registry <code>capabilities</code> attribute MAY be requested via the <code>?inline</code>
query parameter. Note that support for the <code>?inline</code> query parameter itself
is OPTIONAL. The <code>capabilities</code> attribute MUST only appear when explicitly
requested by the client via the <code>?inline</code> query parameter.</li>
</ul>
<p>Regardless of the retrieval mechanism, the format of the capabilities-map MUST
be of the form:</p>
<pre><code>{
  &quot;flags&quot;: [ &quot;STRING&quot; * ], ?
  &quot;mutable&quot;: [ &quot;STRING&quot; * ], ?
  &quot;pagination&quot;: BOOLEAN, ?
  &quot;schemas&quot;: [ &quot;STRING&quot; * ], ?
  &quot;shortself&quot;: BOOLEAN, ?
  &quot;specversions&quot;: [ &quot;STRING&quot; ], ?
  &quot;sticky&quot;: BOOLEAN, ?

  &quot;STRING&quot;: ... capability configuration ... *   // Extension capabilities
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>&quot;STRING&quot;</code> MUST be the name of the capability. This specification places
no restriction on the <code>&quot;STRING&quot;</code> value, other than it MUST be unique across
all capabilities and not be the empty string. It is RECOMMENDED that
extensions use some domain-specific name to avoid possible conflicts with
other extensions.</li>
</ul>
<p>All capability values, including extensions, MUST be defined as one of the
following:</p>
<ul>
<li>Numeric (one of: integer, unsigned integer, float)</li>
<li>Boolean</li>
<li>String</li>
<li>Array of one of the above</li>
</ul>
<p>Absence of a capability in the capability map is an indication of that feature
not being supported. All supported extensions MUST be included in the list.</p>
<p>Absence, presence, or configuration values of a feature in the map MAY vary
based on the authorization level of the client making the request.</p>
<p>The following defines the specification-defined capabilities:</p>
<h4 id="flags"><a class="anchor" href="#flags">☍</a> <code>flags</code></h4>
<ul>
<li>Name: <code>flags</code></li>
<li>Type: Array of strings</li>
<li>Description: The list of supported flags (query parameters). Absence in the
map indicates no support for that flag, and if included in a request
SHOULD be silently ignored by servers.</li>
<li>Defined values:
<code>collections</code>, <code>doc</code>, <code>epoch</code>, <code>filter</code>, <code>inline</code>, <code>nodefaultversionid</code>,
<code>nodefaultversionsticky</code>, <code>noepoch</code>, <code>noreadonly</code>, <code>offered</code>, <code>schema</code>,
<code>setdefaultversionid</code>, <code>specversion</code>.</li>
<li>When not specified, the default value MUST be an empty list and no query
parameters are supported.</li>
<li>Examples:
<ul>
<li><code>&quot;flags&quot;: [ &quot;filter&quot;, &quot;inline&quot; ]</code>    # Just these 2</li>
<li>`&quot;flags&quot;: [ &quot;*&quot; ]                    # All flags</li>
</ul>
</li>
</ul>
<h4 id="mutable"><a class="anchor" href="#mutable">☍</a> <code>mutable</code></h4>
<ul>
<li>Name <code>mutable</code></li>
<li>Type: Array of strings</li>
<li>Description: The list of items in the Registry that can be edited by the
client. <code>entities</code> refers to Groups, Resources, Versions and the Registry
itself. <code>model</code> refers to the ability to modify the Registry model.
<code>capabilities</code> refers to the ability to modify (and configure) the
server. Presence in this list does not guarantee that a client can edit
all items of that type. For example, some Resources might still be read-only
even if the client has the ability to edit Resources in general.</li>
<li>Supported values: <code>capabilities</code>, <code>entities</code>, <code>model</code>.</li>
<li>When not specified, the default value MUST be an empty list and the Registry
is read-only.</li>
</ul>
<h4 id="pagination"><a class="anchor" href="#pagination">☍</a> <code>pagination</code></h4>
<ul>
<li>Name: <code>pagination</code></li>
<li>Type: Boolean</li>
<li>Description: Indicates whether the server supports the use of the
<a href="../pagination/spec.md">pagination</a> specification (value of <code>true</code>).</li>
<li>When not specified, the default value MUST be <code>false</code>.</li>
</ul>
<h4 id="schemas"><a class="anchor" href="#schemas">☍</a> <code>schemas</code></h4>
<ul>
<li>Name: <code>schemas</code></li>
<li>Type: Array of Strings</li>
<li>Description: The list of schema formats supported by the server when
serializing the model. Each value MUST be a schema document format name
(e.g. <code>jsonSchema/2020-12</code>), and SHOULD be of the form <code>NAME[/VERSION]</code>.
All implementations of this specification MUST support
<code>xRegistry-json/1.0-rc1</code> (the JSON serialization as defined by this
specification).</li>
<li>The values MUST be case-insensitive.</li>
<li>A value of <code>xRegistry-json/1.0-rc1</code> MUST be included in the list.</li>
<li>When not specified, the default value MUST be <code>xRegistry-json/1.0-rc1</code>.</li>
</ul>
<h4 id="shortself"><a class="anchor" href="#shortself">☍</a> <code>shortself</code></h4>
<ul>
<li>Name: <code>shortself</code></li>
<li>Type: Boolean</li>
<li>Description: Indicates whether the <code>shortself</code> attribute MUST be included
in the server serialization of the entities within the Registry (value of
<code>true</code>).</li>
<li>When not specified, the default value MUST be <code>false</code>.</li>
</ul>
<h4 id="specversions"><a class="anchor" href="#specversions">☍</a> <code>specversions</code></h4>
<ul>
<li>Name: <code>specversions</code></li>
<li>Type: Array of strings</li>
<li>Description: List of xRegistry specification versions supported.</li>
<li>Supported values include: <code>1.0-rc1</code>.</li>
<li>A value of <code>1.0-rc1</code> MUST be included in the list.</li>
<li>When not specified, the default value MUST be <code>1.0-rc1</code>.</li>
</ul>
<h4 id="sticky"><a class="anchor" href="#sticky">☍</a> <code>sticky</code></h4>
<ul>
<li>Name: <code>sticky</code></li>
<li>Type: Boolean</li>
<li>Description: Indicates whether the server supports clients choosing which
Version of a Resource is to be the &quot;default&quot; Version. In other words, this
capability indicates whether a request to set a Resource's
<code>setdefaultversionsticky</code> attribute to <code>true</code> is allowed.</li>
<li>When not specified, the default value MUST be <code>true</code>.</li>
</ul>
<p>The list of values for the arrays MUST be case-insensitive and MAY include
extension values.</p>
<p>For clarity, servers MUST include all known capabilities in the serialization,
even if they are set to their default values or have empty lists.</p>
<h4 id="updating-the-capabilities-of-a-server"><a class="anchor" href="#updating-the-capabilities-of-a-server">☍</a> Updating the Capabilities of a Server</h4>
<p>If supported, updates to the server's capabilities MAY be done via an HTTP
<code>PUT</code>, or <code>PATCH</code>, to the <code>/capabilities</code> API, or by updating the <code>capabilities</code>
attribute on the root of the Registry. As with other APIs, a <code>PUT</code> MUST be
interpreted as a request to update the entire set of capabilities and any
missing capability MUST be interpreted as a request to reset it to its default
value. If a <code>PATCH</code> is used then each capability included MUST be fully
specified, and fully replaced by the incoming value. In other words, <code>PATCH</code>
is done at a capability level not any deeper within the JSON structure.</p>
<p>The request to the <code>/capabilities</code> API MUST be of the form:</p>
<pre><code class="language-yaml">PUT /capabilities
Content-Type: application/json; charset=utf-8

{ ... Capabilities map ...  }
</code></pre>
<p>or</p>
<pre><code class="language-yaml">PATCH /capabilities
Content-Type: application/json; charset=utf-8

{ ... Capabilities map ...  }
</code></pre>
<p>Where:</p>
<ul>
<li>The HTTP body MUST contain the full representation of all capabilities
in the case of <code>PUT</code>, and the full representation of just the modified
capabilities in the case of <code>PATCH</code>.</li>
<li>Any change to the configuration of the server that is not supported MUST
result in an error (<a href="#capability_error">capability_error</a>) and no changes
applied. Likewise, any unknown capability keys specified MUST generate an
error (<a href="#capability_error">capability_error</a>).</li>
</ul>
<p>A successful response MUST include a full representation of all of the
capabilities of the Registry and be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{ ... Capabilities map ... }
</code></pre>
<p>Updates via the <code>capabilities</code> attribute follows the same attribute
update semantics as the other Registry level attributes. Note that using
an HTTP <code>PATCH</code> to update the Registry's attributes MAY include the
<code>capabilities</code> attribute, however, it MUST be processed with the <code>PATCH</code>
semantics as well.</p>
<p>During the processing of a request to update the capabilities, the semantic
change MUST NOT take effect until after the processing of the current
request. Note that if the response includes the serialization of the
Registry's capabilities, then the changes MUST appear in that serialization.</p>
<p>For any capability that is an array of strings, a value of <code>&quot;*&quot;</code> MAY be used to
indicate that the server MUST replace <code>&quot;*&quot;</code> with the full set of items that
are available. An error (<a href="#capability_error">capability_error</a>) MUST be
generated if <code>&quot;*&quot;</code> appears with any other value in the list. <code>&quot;*&quot;</code> MUST NOT
appear in the serialization in any server's response.</p>
<p>Regardless of the mechanism used to update the capabilities, the Registry's
<code>epoch</code> value MUST be incremented.</p>
<p>In order for a client to discover the list of available values for each
capability, an HTTP <code>GET</code> MAY be sent to the <code>/capabilities</code> API with the
<code>?offered</code> query parameter and the response MUST adhere to the following
(which borrows many of the same structure from the <code>/model</code> API):</p>
<pre><code class="language-yaml">GET /capabilities?offered

{
  &quot;STRING&quot;: {
    &quot;type&quot;: &quot;TYPE&quot;,
    &quot;item&quot;: {
      &quot;type&quot;: &quot;TYPE&quot;
    }, ?
    &quot;enum&quot;: [ VALUE, * ], ?
    &quot;min&quot;: VALUE, ?
    &quot;max&quot;: VALUE, ?
    &quot;documentation&quot;: &quot;URL&quot; ?
  }, *
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>STRING</code> MUST be the capability name.</li>
<li><code>TYPE</code> MUST be one of <code>boolean</code>, <code>string</code>, <code>integer</code>, <code>decimal</code>, <code>uinteger</code>,
<code>array</code> as defined in <a href="#attributes-and-extensions">Attributes and
Extensions</a>.</li>
<li>When <code>&quot;type&quot;</code> is <code>array</code>, <code>&quot;item.type&quot;</code> MUST be one of <code>boolean</code>, <code>string</code>,
<code>integer</code>, <code>decimal</code>, <code>uinteger</code>, otherwise <code>&quot;item&quot;</code> MUST be absent.</li>
<li><code>&quot;enum&quot;</code>, when specified, contains a list of zero or more <code>VALUE</code>s whose
type MUST match either <code>&quot;type&quot;</code> or <code>&quot;item.type&quot;</code> if <code>&quot;item&quot;</code> is <code>&quot;array&quot;</code>.
This indicates the list of allowable values for this capability.</li>
<li><code>&quot;min&quot;</code> and <code>&quot;max&quot;</code>, when specified, MUST match the same type as either
<code>&quot;type&quot;</code> or <code>&quot;item.type&quot;</code> if <code>&quot;item&quot;</code> is <code>&quot;array&quot;</code>. These indicate the
minimum or maximum (inclusive) value range of this capability. When not
specified, there is no stated lower (or upper) limit.</li>
<li><code>&quot;documentation&quot;</code> provides a URL with additional information about the
capability.</li>
</ul>
<p>For example:</p>
<pre><code class="language-yaml">GET /capabilities?offered

{
  &quot;flags&quot;: {
    &quot;type&quot;: &quot;string&quot;,
    &quot;enum&quot;: [ &quot;collections&quot;, &quot;doc&quot;, &quot;epoch&quot;, &quot;filter&quot;, &quot;inline&quot;,
      &quot;nodefaultversionid&quot;, &quot;nodefaultversionsticky&quot;, &quot;noepoch&quot;, &quot;noreadonly&quot;,
      &quot;offered&quot;, &quot;schema&quot;, &quot;setdefaultversionid&quot;, &quot;specversion&quot; ]
  },
  &quot;pagination&quot;: {
    &quot;type&quot;: &quot;boolean&quot;,
    &quot;enum&quot;: [ false, true ]
  },
  &quot;schemas&quot;: {
    &quot;type&quot;: &quot;string&quot;,
    &quot;enum&quot;: [ &quot;xRegistry-json/1.0-rc1&quot; ]
  },
  &quot;shortself&quot;: {
    &quot;type&quot;: &quot;boolean&quot;,
    &quot;enum&quot;: [ false, true ]
  },
  &quot;specversions&quot;: {
    &quot;type&quot;: &quot;string&quot;,
    &quot;enum&quot;: [ &quot;xRegistry-json/1.0-rc1&quot; ]
  },
  &quot;sticky&quot;: {
    &quot;type&quot;: &quot;boolean&quot;,
    &quot;enum&quot;: [ true ]
  }
}
</code></pre>
<p>The enum of values allows for some special cases:</p>
<ul>
<li>String capabilities MAY include <code>*</code> as a wildcard character in a value
to indicate zero or more unspecified characters MAY appear at that location
in the value string.</li>
</ul>
<p>A request to update a capability with a value that is compliant with the
output of the <code>/capabilities?offered</code> MAY still generate an error
(<a href="#capability_error">capability_error</a>) if the server determines it cannot
support the request. For example, due to authorization concerns or the value,
while syntactically valid, isn't allowed in certain situations.</p>
<p>For clarity, even in cases where there is no variability allowed with certain
capabilities they SHOULD still be listed in both the <code>/capabilities</code> API
and the <code>/capabilities?offered</code> API to maximize discoverability. For example,
if <code>pagination</code> is not supported, then a server SHOULD still include:</p>
<pre><code class="language-yaml">  &quot;pagination&quot;: false
</code></pre>
<p>in the <code>/capabilities</code> output, and</p>
<pre><code class="language-yaml">  &quot;pagination&quot;: {
    &quot;type&quot;: &quot;boolean&quot;,
    &quot;enum&quot;: [ false ]
  }
</code></pre>
<p>in the <code>/capabilities?offered</code> output (assuming both APIs are supported).</p>
<h3 id="registry-model"><a class="anchor" href="#registry-model">☍</a> Registry Model</h3>
<p>The Registry model defines the Groups, Resources, extension attributes and
changes to specification-defined attributes. This information is
intended to be used by tooling that does not have knowledge of the structure of
the Registry in advance and therefore will need to dynamically discover it.</p>
<p>To enable support for a wide range of use cases, but to also ensure
interoperability across implementations, the following rules have been defined
with respect to how models are defined or updated:</p>
<ul>
<li>Changes to specification-defined attributes MAY be included in the model but
MUST NOT change them such that they become incompatible with the
specification. For example, changes to further constrain the allowable values
of an attribute is typically allowed, but changing its <code>type</code> from <code>string</code>
to <code>int</code> is not.</li>
<li>Specification-defined attributes that are <code>required</code> MUST NOT have this
aspect changed to <code>false</code>.</li>
<li>Specification-defined attributes that are <code>readonly</code> MUST NOT have this
aspect changed to <code>false</code>.</li>
</ul>
<p>Any specification attributes not included in a request to define, or update,
a model MUST be included in the resulting model. In other words, the
Registry's model consists of the specification-defined attributes overlaid
with the attributes that are explicitly-defined as part of a model
create/update request.</p>
<p>Note: there is no mechanism defined to delete specification-defined attributes
from the model.</p>
<p>Registries MAY support extension attributes to the model language (meaning,
new attributes within the model definitions themselves), but only if
the server supports them. Servers MUST generate an error
(<a href="#model_error">model_error</a>) if a model definition includes unknown model
language attributes.</p>
<p>Once a Registry has been created, changes to the model MAY be supported by
server implementations. This specification makes no statement as to what types
of changes are allowed beyond the following requirements:</p>
<ul>
<li>Any model changes MUST result in a specification compliant model definition.</li>
<li>Servers MUST ensure that the representation of all entities within the
Registry MUST adhere to the current model prior to completing any request.</li>
</ul>
<p>Any request to update the model that does not adhere to those requirements
MUST generate an error (<a href="#model_compliance_error">model_compliance_error</a>).</p>
<p>How the server guarantees that all entities in the Registry are compliant with
the model is an implementation detail. For example, while it is
NOT RECOMMENDED, it is valid for an implementation to modify (or even delete)
existing entities to ensure model compliance. Instead, it is RECOMMENDED that
the model update requests generate an error
(<a href="#model_compliance_error">model_compliance_error</a>) if existing entities are
not compliant.</p>
<p>Additionally, is it STRONGLY RECOMMENDED that model updates be limited to
backwards compatible changes.</p>
<p>Implementations MAY choose to limit the types of changes made to the model,
or not support model updates at all.</p>
<p>The xRegistry schema for an empty Registry can be found <a href="./model.json">here</a>,
while a schema for a sample xRegistry (with Groups and Resources) can be
found <a href="./sample-model.json">here</a>.</p>
<p>The Registry model can be retrieved two ways:</p>
<ol>
<li>as a stand-alone entity via an HTTP <code>GET</code> to the <code>/model</code> API. This is
useful when management of the Registry's model is needed independent of the
entities within the Registry.  See <a href="#retrieving-the-registry-model">Retrieving the Registry
Model</a> for more information.</li>
<li>as part of the Registry contents by requesting the <code>model</code> attribute be
inlined. This is useful when it is desirable to view the entire Registry as
a single document - such as an &quot;export&quot; type of scenario. See the
<a href="#retrieving-the-registry">Retrieving the Registry</a> section for more
information on this option.</li>
</ol>
<p>Regardless of how the model is retrieved, the overall format is as follows:</p>
<pre><code class="language-yaml">{
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;attributes&quot;: {                      # Registry level extensions
    &quot;STRING&quot;: {                        # Attribute name
      &quot;name&quot;: &quot;STRING&quot;,                # Same as attribute's key
      &quot;type&quot;: &quot;TYPE&quot;,                  # boolean, string, array, object, ...
      &quot;target&quot;: &quot;STRING&quot;, ?            # If &quot;type&quot; is &quot;xid&quot;
      &quot;namecharset&quot;: &quot;STRING&quot;, ?       # If &quot;type&quot; is &quot;object&quot;
      &quot;description&quot;: &quot;STRING&quot;,
      &quot;enum&quot;: [ VALUE * ], ?           # Array of values of type &quot;TYPE&quot;
      &quot;strict&quot;: BOOLEAN, ?             # Just &quot;enum&quot; values or not. Default=true
      &quot;readonly&quot;: BOOLEAN, ?           # From client's POV. Default=false
      &quot;immutable&quot;: BOOLEAN, ?          # Once set, can't change. Default=false
      &quot;required&quot;: BOOLEAN, ?           # Default=false
      &quot;default&quot;: VALUE, ?              # Scalar attribute's default value

      &quot;attributes&quot;: { ... }, ?         # If &quot;type&quot; above is object
      &quot;item&quot;: {                        # If &quot;type&quot; above is map,array
        &quot;type&quot;: &quot;TYPE&quot;, ?              # map value type, or array type
        &quot;namecharset&quot;: &quot;STRING&quot;, ?     # If this item &quot;type&quot; is object
        &quot;attributes&quot;: { ... }, ?       # If this item &quot;type&quot; is object
        &quot;item&quot;: { ... } ?              # If this item &quot;type&quot; is map,array
      } ?

      &quot;ifvalues&quot;: {                    # If &quot;type&quot; is scalar
        &quot;VALUE&quot;: {
          &quot;siblingattributes&quot;: { ... } # Siblings to this &quot;attribute&quot;
        } *
      } ?
    } *
  },

  &quot;groups&quot;: {
    &quot;STRING&quot;: {                        # Key=plural name, e.g. &quot;endpoints&quot;
      &quot;plural&quot;: &quot;STRING&quot;,              # e.g. &quot;endpoints&quot;
      &quot;singular&quot;: &quot;STRING&quot;,            # e.g. &quot;endpoint&quot;
      &quot;description&quot;: &quot;STRING&quot;, ?
      &quot;modelversion&quot;: &quot;STRING&quot;, ?      # Version of the group model
      &quot;compatiblewith&quot;: &quot;URI&quot;, ?       # Statement of compatibility with model spec
      &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
      &quot;attributes&quot;: { ... }, ?         # See &quot;attributes&quot; above

      &quot;resources&quot;: {
        &quot;STRING&quot;: {                    # Key=plural name, e.g. &quot;messages&quot;
          &quot;plural&quot;: &quot;STRING&quot;,          # e.g. &quot;messages&quot;
          &quot;singular&quot;: &quot;STRING&quot;,        # e.g. &quot;message&quot;
          &quot;description&quot;: &quot;STRING&quot;, ?
          &quot;maxversions&quot;: UINTEGER, ?   # Num Vers(&gt;=0). Default=0, 0=unlimited
          &quot;setversionid&quot;: BOOLEAN, ?   # vid settable? Default=true
          &quot;setdefaultversionsticky&quot;: BOOLEAN, ? # sticky settable? Default=true
          &quot;hasdocument&quot;: BOOLEAN, ?     # Has separate document. Default=true
          &quot;singleversionroot&quot;: BOOLEAN, ? # enforce single root. Default=false
          &quot;typemap&quot;: MAP, ?             # contenttype mappings
          &quot;modelversion&quot;: &quot;STRING&quot;, ?   # Version of the resource model
          &quot;compatiblewith&quot;: &quot;URI&quot;`, ?   # Statement of compatibility with model spec
          &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
          &quot;attributes&quot;: { ... }, ?      # Version attributes/extensions
          &quot;metaattributes&quot;: { ... } ?   # Resource attributes/extensions
        } *
      } ?
    } *
  } ?
}
</code></pre>
<p>The following describes the attributes of Registry model:</p>
<ul>
<li>
<p><code>modelversion</code> <span id="model.modelversion"></span></p>
<ul>
<li>Type: String.</li>
<li>OPTIONAL.</li>
<li>The version of the local model of a group or resource.</li>
<li>It is common to use a combination of major and minor version numbers.</li>
<li>Example: <code>1.2</code></li>
</ul>
</li>
<li>
<p><code>compatiblewith</code> <span id="model.compatiblewith"></span></p>
<ul>
<li>Type: URI.</li>
<li>OPTIONAL.</li>
<li>References / represents an xRegistry model definition that
the current model is compatible with. This is meant to express
interoperability between models in different xRegistries via using a
shared compatible model.</li>
<li>Does not imply runtime validation of the claim.</li>
<li>Example: <code>https://raw.githubusercontent.com/xregistry/spec/refs/heads/main/schema/model.json</code></li>
</ul>
</li>
<li>
<p><code>labels</code> <span id="model.labels"></span></p>
<ul>
<li>Type: Map of string-string.</li>
<li>OPTIONAL.</li>
<li>A set of name/value pairs that allows for additional metadata about the
Registry to be stored without changing the schema of the model.</li>
<li>If present, MUST be a map of zero or more name/value string pairs.
See <a href="#attributes-and-extensions">Attributes and Extensions</a> for more
information.</li>
<li>Keys MUST be non-empty strings.</li>
<li>Values MAY be empty strings.</li>
<li>Model authors MAY define additional labels.</li>
</ul>
</li>
<li>
<p><code>attributes</code> <span id="model.attributes"></span></p>
<ul>
<li>Type: Map where each attribute's name MUST match the key of the map.</li>
<li>OPTIONAL.</li>
<li>The set of attributes defined at the indicated level of the Registry. This
includes extensions and specification-defined/modified attributes.</li>
<li>REQUIRED at specification-defined locations, otherwise OPTIONAL for
extensions Objects.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;</code></p>
<ul>
<li>Type: String.</li>
<li>REQUIRED.</li>
<li>The name of the attribute being defined. See <code>attributes.&quot;STRING&quot;.name</code>
for more information.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.name</code></p>
<ul>
<li>
<p>Type: String.</p>
</li>
<li>
<p>REQUIRED.</p>
</li>
<li>
<p>The name of the attribute. MUST be the same as the key used in the owning
<code>attributes</code> attribute. A value of <code>*</code> indicates support for undefined
extension names. Absence of a <code>*</code> attribute indicates lack of support for
undefined extensions and an error (<a href="#unknown_attribute">unknown_attribute</a>)
MUST be generated if one is present in a request.</p>
<p>Often <code>*</code> is used with a <code>type</code> of <code>any</code> to allow for any undefined
extension name of any supported data type. By default, the model
does not support undefined extensions. Note that undefined extensions, if
supported, MUST adhere to the same rules as
<a href="#attributes-and-extensions">defined extensions</a>.</p>
<p>An attribute of <code>*</code> MUST NOT use the <code>ifvalues</code> feature, but a non-<code>*</code>
attribute MAY define an <code>ifvalues</code> attribute named <code>*</code> as long as there
isn't already one defined for this level in the entity</p>
<p>An extension attribute MUST NOT use a name that conflicts with any
specification-defined attribute, sub-object attribute or collection
related attribute names defined at the same level in the hierarchy. For
Resource/Version attributes, this applies for both levels - e.g. a Version
level extension MUST NOT use a name that conflicts with its Resource level
attribute names.</p>
</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.type</code></p>
<ul>
<li>Type: TYPE.</li>
<li>REQUIRED.</li>
<li>The &quot;TYPE&quot; of the attribute being defined. MUST be one of the data types
(in lower case) defined in <a href="#attributes-and-extensions">Attributes and
Extensions</a>.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.target</code> <span id="model.target"></span></p>
<ul>
<li>Type: STRING.</li>
<li>OPTIONAL.</li>
<li>The type of entity that this attribute points to when <code>type</code> is set to
<code>url-reference</code>, <code>uri-reference</code> or <code>xid</code>. <code>target</code> MUST NOT be used
for any other type of attribute. The value of this model attribute MUST be
a &quot;xid template&quot; of one of the following forms:
<ul>
<li><code>/GROUPS</code> - a plural Group type name. An entity attribute of this
type/target MUST reference an instance of this Group type.</li>
<li><code>/GROUPS/RESOURCES</code> - a plural Resource type name. An entity attribute
of this type/target MUST reference an instance of this Resource type,
not a specific Version of the Resource.</li>
<li><code>/GROUPS/RESOURCES[/versions]</code> - a Version or Resource type name. An
entity attribute of this type/target MUST reference either an instance
of this Resource type or an instance of a Version of this Resource type.</li>
<li><code>/GROUPS/RESOURCES/versions</code> - a Version of a Resource type. An entity
attribute of this type/target MUST reference an instance of a Version
of this Resource type, not the Resource itself.</li>
</ul>
</li>
<li>An <code>xid</code> entity attribute that includes a <code>target</code> value as part of
its model definition MUST match the <code>target</code> entity type specified. An
<code>xid</code> attribute that does not include <code>target</code> definition has no
such restriction and MAY be any valid <code>xid</code> value.</li>
<li>A URI/URL-reference entity attribute MAY include <code>target</code> as part of its
definition. If so, then any runtime value that is a relative URI/URL
(begins with <code>/</code>) MUST be an <code>xid</code> and MUST adhere to the <code>target</code> entity
type specified. Absolute URIs/URLs are not constrained by the presence of
a <code>target</code> value.</li>
<li>To keep the model, and processing simple, the value MUST NOT reference a
type that uses <code>ximport</code> to reference another model entity definition. In
other words, <code>target</code> is not transitive.</li>
<li>Example: <code>/endpoints/messages</code></li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.namecharset</code> <span id="model.namecharset"></span></p>
<ul>
<li>
<p>Type: String.</p>
</li>
<li>
<p>OPTIONAL, and MUST only be used when <code>type</code> is <code>object</code>.</p>
</li>
<li>
<p>Specifies the name of the character set that defines the allowable
characters that can be used for the object's top-level attribute names.
Any attempt to define a top-level attribute for this object that does
not adhere to the characters defined by the character set name MUST
generate an error (<a href="#invalid_character">invalid_character</a>).</p>
</li>
<li>
<p>Per the <a href="#attributes-and-extensions">Attributes and Extensions</a> section,
attribute names are normally limited to just the set of characters that
ensure they can reliably be used in cases such as code variable names
without the need for some escaping mechanism. However, there are
situations where object-typed attribute names need to support additional
characters, such as a dash (<code>-</code>), and it is known that they will never be
used in those restricted character set situations. By setting the
<code>namecharset</code> aspect to <code>extended</code> the server MUST allow for an extended
set of valid characters in attribute names for this object.</p>
<p>The allowed character set for attribute names within an <code>object</code> MUST also
apply to the top-level <code>siblingattributes</code> of any <code>ifvalues</code> defined
for those attributes.</p>
</li>
<li>
<p>This specification defines two character sets:</p>
<ul>
<li><code>strict</code> - this character set is the same as the set of characters
defined for all attribute names - see <a href="#attributes-and-extensions">Attributes and
Extensions</a>.</li>
<li><code>extended</code> - this character set is the same as the set of characters
defined for all map key names - see <a href="#attributes-and-extensions">Attributes and
Extensions</a>.</li>
</ul>
</li>
<li>
<p>When not specified, the default value is <code>strict</code>.</p>
</li>
<li>
<p>Implementations MAY define additional character sets, however, an attempt
to define a model that uses an unknown character set name MUST generate an
error (<a href="#model_error">model_error</a>).</p>
</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.description</code></p>
<ul>
<li>Type: String.</li>
<li>OPTIONAL.</li>
<li>A human-readable description of the attribute.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.enum</code></p>
<ul>
<li>
<p>Type: Array of values of type <code>attributes.&quot;STRING&quot;.type</code>..</p>
</li>
<li>
<p>OPTIONAL.</p>
</li>
<li>
<p>A list of possible values for this attribute. Each item in the array MUST
be of type defined by <code>type</code>. When not specified, or an empty array, there
are no restrictions on the value set of this attribute. This MUST only be
used when the <code>type</code> is a scalar. See the <code>strict</code> attribute below.</p>
<p>When specified without <code>strict</code> being <code>true</code>, this list is just a
suggested set of values and the attribute is NOT REQUIRED to use one of
them.</p>
</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.strict</code></p>
<ul>
<li>Type: Boolean.</li>
<li>OPTIONAL.</li>
<li>Indicates whether the attribute restricts its values to just the array of
values specified in <code>enum</code> or not. A value of <code>true</code> means that any
values used that is not part of the <code>enum</code> set MUST generate an error
(<a href="#invalid_data">invalid_data</a>).
This attribute has no impact when <code>enum</code> is absent or an empty array.</li>
<li>When not specified, the default value MUST be <code>true</code>.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.readonly</code></p>
<ul>
<li>
<p>Type: Boolean.</p>
</li>
<li>
<p>OPTIONAL.</p>
</li>
<li>
<p>Indicates whether this attribute is modifiable by a client. During
creation, or update, of an entity if this attribute is specified, then
its value MUST be silently ignored by the server even if the value is
invalid.</p>
<p>Typically, attributes that are completely under the server's control
will be <code>readonly</code> - e.g. <code>self</code>.</p>
</li>
<li>
<p>When not specified, the default value MUST be <code>false</code>.</p>
</li>
<li>
<p>When the attribute name is <code>*</code> then <code>readonly</code> MUST NOT be set to <code>true</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.immutable</code></p>
<ul>
<li>
<p>Type: Boolean.</p>
</li>
<li>
<p>OPTIONAL.</p>
</li>
<li>
<p>Indicates whether this attribute's value can be changed once it is set.
This MUST ONLY be used for server controlled specification-defined
attributes, such as <code>specversion</code> and <code>SINGULARid</code>, and MUST NOT be used for
extension attributes. As such, it is only for informational purposes for
clients.</p>
<p>Once set, any attempt to update the value MUST be silently ignored by
the server.</p>
</li>
<li>
<p>When not specified, the default value MUST be <code>false</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.required</code></p>
<ul>
<li>Type: Boolean</li>
<li>OPTIONAL.</li>
<li>Indicates whether this attribute is REQUIRED to have a non-null value.</li>
<li>When set to <code>true</code>, this specification does not mandate how this
attribute's value is populated (i.e. by a client, the server or via a
default value), just that by the end of processing any request it MUST
have a non-null value, and generate an error
(<a href="#invalid_data">invalid_data</a>) if not.</li>
<li>A <code>true</code> value also implies that this attribute MUST be serialized in any
response from the server - with the exception of the optimizations
specified for document view.</li>
<li>When not specified the default value MUST be <code>false</code>.</li>
<li>When the attribute name is <code>*</code> then <code>required</code> MUST NOT be set to <code>true</code>.</li>
<li>MUST NOT be <code>false</code> if a default value (<code>default</code>) is defined.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.default</code></p>
<ul>
<li>Type: MUST be a non-<code>null</code> value of the type specified by the
<code>attributes.&quot;STRING&quot;.type</code> model attribute and MUST only be used for
scalar types.</li>
<li>OPTIONAL.</li>
<li>This value MUST be used to populate this attribute's value if one was
not provided by a client. An attribute with a default value does not mean
that its owning Object is mandated to be present, rather the attribute
would only appear when the owning Object is present. By default,
attributes have no default values.</li>
<li>When not specified, this attribute has no default value and has the same
semantic meaning a being absent or set to <code>null</code>.</li>
<li>When a default value is specified, this attribute MUST be serialized in
responses from servers as part of its owning entity, even if it is set to
its default value. This means that any attribute that has a default value
defined MUST also have its <code>required</code> aspect set to <code>true</code>.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.attributes</code></p>
<ul>
<li>Type: Object, see <code>attributes</code> above.</li>
<li>OPTIONAL.</li>
<li>This contains the list of attributes defined as part of a nested resource.</li>
<li>MAY be present when the owning attribute's <code>type</code> is <code>object</code>, otherwise it
MUST NOT be present. It MAY be absent or an empty list if there are no
defined attributes for the nested <code>object</code>.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.item</code> <span id="model.attributes.item"></span></p>
<ul>
<li>Type: Object.</li>
<li>REQUIRED when owning attribute's <code>type</code> is <code>map</code> or <code>array</code>.</li>
<li>Defines the nested resource that this attribute references. This
attribute MUST only be used when the owning attribute's <code>type</code> value is
<code>map</code> or <code>array</code>.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.item.type</code></p>
<ul>
<li>Type: TYPE.</li>
<li>REQUIRED.</li>
<li>The &quot;TYPE&quot; of this nested resource.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.item.namecharset</code></p>
<ul>
<li>See <a href="#model.namecharset"><code>namecharset</code></a> above.</li>
<li>OPTIONAL, and MUST only be used when <code>item.type</code> is <code>object</code>.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.item.attributes</code></p>
<ul>
<li>See <a href="#model.attributes"><code>attributes</code></a> above.</li>
<li>OPTIONAL, and MUST ONLY be used when <code>item.type</code> is <code>object</code>.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.item.item</code></p>
<ul>
<li>See <a href="#model.attributes.item"><code>attributes.&quot;STRING&quot;.item</code></a> above.</li>
<li>REQUIRED when <code>item.type</code> is <code>map</code> or <code>array</code>.</li>
</ul>
</li>
<li>
<p><code>attributes.&quot;STRING&quot;.ifvalues</code></p>
<ul>
<li>
<p>Type: Map where each value of the attribute is the key of the map.</p>
</li>
<li>
<p>OPTIONAL.</p>
</li>
<li>
<p>This map can be used to conditionally include additional
attribute definitions based on the runtime value of the current attribute.
If the string serialization of the runtime value of this attribute matches
the <code>ifvalues</code> <code>&quot;VALUE&quot;</code> (case-sensitive) then the <code>siblingattributes</code> MUST
be included in the model as siblings to this attribute.</p>
<p>If <code>enum</code> is not empty and <code>strict</code> is <code>true</code> then this map MUST NOT
contain any value that is not specified in the <code>enum</code> array.</p>
<p>This aspect MUST only be used for scalar attributes.</p>
<p>All attributes defined for this <code>ifvalues</code> MUST be unique within the scope
of this <code>ifvalues</code> and MUST NOT match a named attribute defined at this
level of the entity. If multiple <code>ifvalues</code> sections, at the same entity
level, are active at the same time then there MUST NOT be duplicate
<code>ifvalues</code> attributes names between those <code>ifvalues</code> sections.</p>
</li>
<li>
<p><code>ifvalues</code> <code>&quot;VALUE&quot;</code> MUST NOT be an empty string.</p>
</li>
<li>
<p><code>ifvalues</code> <code>&quot;VALUE&quot;</code> MUST NOT start with the <code>^</code> (caret) character as its
presence at the beginning of <code>&quot;VALUE&quot;</code> is reserved for future use.</p>
</li>
<li>
<p><code>ifvalues</code> <code>siblingattributes</code> MAY include additional <code>ifvalues</code>
definitions.</p>
</li>
</ul>
</li>
<li>
<p><code>groups</code></p>
<ul>
<li>Type: Map where the key MUST be the plural name (<code>groups.plural</code>) of the
Group type (<code>GROUPS</code>).</li>
<li>REQUIRED if there are any Group types defined for the Registry.</li>
<li>The set of Group types supported by the Registry.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;</code></p>
<ul>
<li>Type: String.</li>
<li>REQUIRED.</li>
<li>The name of the Group being defined. See <code>groups.&quot;STRING&quot;.plural</code>
for more information.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.plural</code></p>
<ul>
<li>Type: String.</li>
<li>REQUIRED.</li>
<li>The plural name of the Group type e.g. <code>endpoints</code> (<code>GROUPS</code>).</li>
<li>MUST be unique across all Group types (plural and singular names) in the
Registry.</li>
<li>MUST be non-empty and MUST be a valid attribute name with the exception
that it MUST NOT exceed 58 characters (not 63).</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.singular</code></p>
<ul>
<li>Type: String.</li>
<li>REQUIRED.</li>
<li>The singular name of a Group type e.g. <code>endpoint</code> (<code>GROUP</code>).</li>
<li>MUST be unique across all Group types (plural and singular names) in the
Registry.</li>
<li>MUST be non-empty and MUST be a valid attribute name with the exception
that it MUST NOT exceed 58 characters (not 63).</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.labels</code></p>
<ul>
<li>See [<code>labels</code>]((#model.labels) above.</li>
<li>OPTIONAL.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.attributes</code></p>
<ul>
<li>See <a href="#model.attributes"><code>attributes</code></a> above.</li>
<li>OPTIONAL.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources</code></p>
<ul>
<li>Type: Map where the key MUST be the plural name (<code>groups.resources.plural</code>)
of the Resource type (<code>RESOURCES</code>).</li>
<li>REQUIRED if there are any Resource types defined for the Group type.</li>
<li>The set of Resource types defined for the Group type.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;</code>.resources.&quot;STRING&quot;`</p>
<ul>
<li>Type: String.</li>
<li>REQUIRED.</li>
<li>The name of the Resource being defined. See
<code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.plural</code> for more information.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.plural</code></p>
<ul>
<li>Type: String.</li>
<li>REQUIRED.</li>
<li>The plural name of the Resource type e.g. <code>messages</code> (<code>RESOURCES</code>).</li>
<li>MUST be non-empty and MUST be a valid attribute name with the exception
that it MUST NOT exceed 58 characters (not 63).</li>
<li>MUST be unique across all Resources (plural and singular names) within the
scope of its owning Group type.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.singular</code></p>
<ul>
<li>Type: String.</li>
<li>REQUIRED.</li>
<li>The singular name of the Resource type e.g. <code>message</code> (<code>RESOURCE</code>).</li>
<li>MUST be non-empty and MUST be a valid attribute name with the exception
that it MUST NOT exceed 58 characters (not 63).</li>
<li>MUST be unique across all Resources (plural and singular names) within the
scope of its owning Group type.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.maxversions</code></p>
<ul>
<li>Type: Unsigned Integer.</li>
<li>OPTIONAL.</li>
<li>Number of Versions that will be stored in the Registry for this Resource
type.</li>
<li>When not specified, the default value MUST be zero (<code>0</code>).</li>
<li>A value of zero (<code>0</code>) indicates there is no stated limit, and
implementations MAY prune non-default Versions at any time. This means
it is valid for an implementation to only support one (<code>1</code>) Version when
<code>maxversions</code> is set to <code>0</code>.</li>
<li>When the limit is exceeded, implementations MUST prune Versions by
deleting the oldest Version first, skipping the
Version marked as &quot;default&quot;. The strategy for finding the oldest Version
to delete is as follows:
<ol>
<li>Find all Versions that are roots (i.e. <code>ancestor</code> is the same as its
<code>versionid</code>).</li>
<li>If many exist, find the Version with the oldest <code>createdat</code> date.</li>
<li>If many exist, select the first Version sorting all Versions in
ascending case-insensitive alphabetical order based on the <code>versionid</code>
attribute.
Once the single oldest Version is determined, delete it.
A special case for the pruning rules is that if <code>maxversions</code> is set to
one (1), then the &quot;default&quot; Version is not skipped, which means it will be
deleted and the new Version will become &quot;default&quot;.</li>
</ol>
</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.setversionid</code></p>
<ul>
<li>Type: Boolean (<code>true</code> or <code>false</code>, case-sensitive).</li>
<li>OPTIONAL.</li>
<li>Indicates whether support for client-side setting of a Version's
<code>versionid</code> is supported.</li>
<li>When not specified, the default value MUST be <code>true</code>.</li>
<li>A value of <code>true</code> indicates the client MAY specify the <code>versionid</code> of a
Version during its creation process.</li>
<li>A value of <code>false</code> indicates that the server MUST choose an appropriate
<code>versionid</code> value during creation of the Version.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.setdefaultversionsticky</code></p>
<ul>
<li>Type: Boolean (<code>true</code> or <code>false</code>, case-sensitive).</li>
<li>OPTIONAL.</li>
<li>Indicates whether support for client-side selection of the &quot;default&quot;
Version is supported for Resources of this type. Once set, the default
Version MUST NOT change unless there is some explicit action by a client
to change it - hence the term &quot;sticky&quot;.</li>
<li>When not specified, the default value MUST be <code>true</code>.</li>
<li>A value of <code>true</code> indicates a client MAY select the default Version of
a Resource via one of the methods described in this specification rather
than the server always choosing the default Version.</li>
<li>A value of <code>false</code> indicates the server MUST choose which Version is the
default Version.</li>
<li>This attribute MUST NOT be <code>true</code> if <code>maxversions</code> is one (<code>1</code>).</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.hasdocument</code></p>
<ul>
<li>
<p>Type: Boolean (<code>true</code> or <code>false</code>, case-sensitive).</p>
</li>
<li>
<p>OPTIONAL.</p>
</li>
<li>
<p>Indicates whether or not Resources of this type can have a document
associated with it. If <code>false</code> then the xRegistry metadata becomes &quot;the
document&quot;. Meaning, an HTTP <code>GET</code> to the Resource's URL will return the
xRegistry metadata in the HTTP body. The <code>xRegistry-</code> HTTP headers MUST
NOT be used for requests or response messages for these Resources.
Use of <code>$details</code> on the request URLs MAY be used to provide consistency
with the cases where this attribute is set to <code>true</code> - but the output
remains the same.</p>
<p>A value of <code>true</code> does not mean that these Resources are guaranteed to
have a non-empty document, and an HTTP <code>GET</code> to the Resource MAY return an
empty HTTP body.</p>
</li>
<li>
<p>When not specified, the default value MUST be <code>true</code>.</p>
</li>
<li>
<p>A value of <code>true</code> indicates that Resource of this type supports a separate
document to be associated with it.</p>
</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.singleversionroot</code></p>
<ul>
<li>Type: Boolean (<code>true</code> or <code>false</code>, case-sensitive).</li>
<li>OPTIONAL.</li>
<li>Indicates whether Resources of this type can have multiple Versions
that represent roots of an ancestor tree, as indicated by the
Version's <code>ancestor</code> attribute value being the same as its <code>versionid</code>
attribute.</li>
<li>When not specified, the default value MUST be <code>false</code>.</li>
<li>A value of <code>true</code> indicates that only one Version of the Resource can
be a root. This is useful to avoid creating multiple roots. When this
attribute is set to <code>true</code>, the server MUST generate an error
(<a href="#multiple_roots">multiple_roots</a>) if any
request results in a state where more than one Version of a Resource
is a root of an ancestor tree.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.typemap</code></p>
<ul>
<li>
<p>Type: Map where the keys and values MUST be non-empty strings. The key
MAY include at most one <code>*</code> to act as a wildcard to mean zero or more
instance of any character at that position in the string - similar to a
<code>.*</code> in a regular expression. The key MUST be a case-insensitive string.</p>
</li>
<li>
<p>OPTIONAL.</p>
</li>
<li>
<p>When a Resource's metadata is serialized in a response and the
<code>?inline=RESOURCE</code> feature is enabled, the server will attempt to
serialize the Resource's &quot;document&quot; under the <code>RESOURCE</code> attribute.
However, this can only happen under two situations:<br>
1 - The Resource document's bytes are already in the same format as
the xRegistry metadata - in other words JSON, or<br>
2 - The Resource's document can be considered a &quot;string&quot; and therefore
can be serialized as a &quot;string&quot;, possibly with some escaping.<br></p>
<p>For some well-known <code>contenttype</code> values (e.g. <code>application/json</code>) the
first case can be easily determined by the server. However, for custom
<code>contenttype</code> values the server will need to be explicitly told how to
interpret its value (e.g. to know if it is a string or JSON).
The <code>typemap</code> attribute allows for this by defining a mapping of
<code>contenttype</code> values to well-known xRegistry format types.</p>
<p>Since the <code>contenttype</code> value is a &quot;media-type&quot; per
<a href="https://datatracker.ietf.org/doc/html/rfc9110#media.type">RFC9110</a>,
for purposes of looking it up in the <code>typemap</code>, just the <code>type/subtype</code>
portion of the value (case-insensitively) MUST be used. Meaning, any
<code>parameters</code> MUST be excluded.</p>
<p>If more than one entry in the <code>typemap</code> matches the <code>contenttype</code>, but
they all have the same value, then that value MUST be used. If they are
not all the same, then <code>binary</code> MUST be used.</p>
</li>
<li>
<p>This specification defines the following values (case-insensitive):</p>
<ul>
<li><code>binary</code></li>
<li><code>json</code></li>
<li><code>string</code></li>
</ul>
<p>Implementations MAY define additional values.</p>
<p>A value of <code>binary</code> indicates that the Resource's document is to be treated
as an array of bytes and serialized under the <code>RESOURCEbase64</code> attribute,
even if the <code>contenttype</code> is of the same type of the xRegistry metadata
(e.g. <code>application/json</code>). This is useful when it is desireable to not
have the server potentially modify the document (e.g. &quot;pretty-print&quot; it).</p>
<p>A value of <code>json</code> indicates that the Resource's document is JSON and MUST
be serialized under the <code>RESOURCE</code> attribute if it is valid JSON. Note that
if there is a syntax error in the JSON then the server MUST treat the
document as <code>binary</code> to avoid sending invalid JSON to the client. The
server MAY choose to modify the formating of the document (e.g. to
&quot;pretty-print&quot; it).</p>
<p>A value of <code>string</code> indicates that the Resource's document is to be treated
as a string and serialized using the default string serialization rules
for the format being used to serialize the Resource's metadata. For example,
when using JSON, this means escaping all non-printable characters.</p>
<p>Specifying an unknown (or unsupported) value MUST generate an error
(<a href="#model_error">model_error</a>) during the update of the xRegistry model.</p>
<p>By default, the following
<a href="https://datatracker.ietf.org/doc/html/rfc9110#media.type">RFC9110</a>
<code>typemap</code> keys MUST be implicitly defined as follows, unless overridden
by an explicit <code>typemap</code> entry:</p>
<ul>
<li><code>application/json</code>: mapped to <code>json</code></li>
<li><code>*+json</code>: mapped to <code>json</code></li>
<li><code>text/plain</code>: mapped to <code>string</code></li>
</ul>
</li>
<li>
<p>Example:<br></p>
<pre><code class="language-yaml">&quot;typemap&quot;: {
  &quot;text/*&quot;: &quot;string&quot;,
  &quot;text/mine&quot;: &quot;json&quot;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.labels</code></p>
<ul>
<li>See <a href="#model.attributes"><code>attributes</code></a> above.</li>
<li>OPTIONAL.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.attributes</code></p>
<ul>
<li>See <a href="#model.attributes"><code>attributes</code></a> above and
<a href="#model.metaattributes"><code>metaattributes</code></a> below.</li>
<li>OPTIONAL.</li>
<li>The list of attributes associated with each Version of the Resource.</li>
<li>The list of <code>groups.resources.attributes</code> names MUST NOT overlap with the
list of <code>groups.resource.metaattributes</code> names.</li>
</ul>
</li>
<li>
<p><code>groups.&quot;STRING&quot;.resources.&quot;STRING&quot;.metaattributes</code>
<span id="model.metaattributes"></span></p>
<ul>
<li>See <a href="#model.attributes"><code>attributes</code></a> above.</li>
<li>OPTIONAL.</li>
<li>The list of attributes associated with the Resource, not its Versions,
and will appear in the <code>meta</code> sub-object of the Resource.</li>
<li>The list of <code>groups.resources.attributes</code> names MUST NOT overlap with the
list of <code>groups.resource.metaattributes</code> names.</li>
</ul>
</li>
</ul>
<h4 id="retrieving-the-registry-model"><a class="anchor" href="#retrieving-the-registry-model">☍</a> Retrieving the Registry Model</h4>
<p>To retrieve the Registry Model as a stand-alone entity, an HTTP <code>GET</code> MAY be
used.</p>
<p>Registries MAY support exposing the model in a variety of well-defined schema
formats. The <code>schemas</code> capabilities attribute MUST expose the set of schema
formats available.</p>
<p>The resulting schema document MUST include the full Registry model - meaning
all specification-defined attributes, extension attributes, Group types, and
Resource types.</p>
<p>For the sake of brevity, this specification doesn't include the full definition
of the specification-defined attributes as part of the snippets of output.
However, the full model definition of the Registry level attributes can be
found in <a href="model.json">model.json</a>, and the Group and Resource level attributes
can be found in this sample <a href="sample-model.json">sample-model.json</a>.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">GET /model[?schema=NAME[/VERSION]]
</code></pre>
<p>Where:</p>
<ul>
<li>When specified, the <code>?schema</code> query parameter MUST be one of the valid
<code>schema</code> capabilities values (case-insensitive).</li>
<li>When not specified, the default value MUST be <code>xRegistry-json/1.0-rc1</code>.</li>
</ul>
<p>Implementations of this specification MUST support <code>xRegistry-json/1.0-rc1</code>.</p>
<p>A successful response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: ...

... xRegistry model in a schema specific format ...
</code></pre>
<p>Where:</p>
<ul>
<li>The HTTP body MUST be a schema representation of the Registry model
in the format requested by the <code>?schema</code> query parameter.</li>
<li>When a <code>VERSION</code> is not specified as part of the <code>?schema</code> query parameter
then the server MAY choose any schema version of the specified schema format.
However, it is RECOMMENDED that the newest supported version be used.</li>
</ul>
<p>If the specified schema format is not supported then an error
(<a href="#invalid_data">invalid_data</a>) MUST be generated.</p>
<p>When the <code>schema</code> is <code>xRegistry-json/1.0-rc1</code> then the response MUST be of the
form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;attributes&quot;: {
    &quot;STRING&quot;: {
      &quot;name&quot;: &quot;STRING&quot;,
      &quot;type&quot;: &quot;TYPE&quot;,
      &quot;target&quot;: &quot;STRING&quot;, ?
      &quot;namecharset&quot;: &quot;STRING&quot;, ?
      &quot;description&quot;: &quot;STRING&quot;, ?
      &quot;enum&quot;: [ VALUE * ], ?
      &quot;strict&quot;: BOOLEAN, ?
      &quot;readonly&quot;: BOOLEAN, ?
      &quot;immutable&quot;: BOOLEAN, ?
      &quot;required&quot;: BOOLEAN, ?
      &quot;default&quot;: VALUE, ?

      &quot;attributes&quot;: { ... }, ?
      &quot;item&quot;: { ... }, ?

      &quot;ifvalues&quot;: {
        &quot;VALUE&quot;: {
          &quot;siblingattributes&quot;: { ... }
        } *
      } ?
    } *
  },

  &quot;groups&quot;: {
    &quot;STRING&quot;: {
      &quot;plural&quot;: &quot;STRING&quot;,
      &quot;singular&quot;: &quot;STRING&quot;,
      &quot;description&quot;: &quot;STRING&quot;, ?
      &quot;modelversion&quot;: &quot;STRING&quot;, ?
      &quot;compatiblewith&quot;: &quot;URI&quot;, ?
      &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
      &quot;attributes&quot;: { ... }, ?

      &quot;resources&quot;: {
        &quot;STRING&quot;: {
          &quot;plural&quot;: &quot;STRING&quot;,
          &quot;singular&quot;: &quot;STRING&quot;,
          &quot;description&quot;: &quot;STRING&quot;, ?
          &quot;maxversions&quot;: UINTEGER, ?
          &quot;setversionid&quot;: BOOLEAN, ?
          &quot;setdefaultversionsticky&quot;: BOOLEAN, ?
          &quot;hasdocument&quot;: BOOLEAN, ?
          &quot;singleversionroot&quot;: BOOLEAN, ?
          &quot;typemap&quot;: MAP, ?
          &quot;modelversion&quot;: &quot;STRING&quot;, ?
          &quot;compatiblewith&quot;: &quot;URI&quot;, ?
          &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
          &quot;attributes&quot;: { ... }, ?
          &quot;metaattributes&quot;: { ... } ?
        } *
      } ?
    } *
  } ?
}
</code></pre>
<p><strong>Examples:</strong></p>
<p>Retrieve a Registry model that has one extension attribute on the
<code>endpoints</code> Group, and supports returning the schema of the Registry
as JSON Schema:</p>
<pre><code class="language-yaml">GET /model
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;attributes&quot;: {
    ... xRegistry spec-defined attributes excluded for brevity ...
  },
  &quot;groups&quot;: {
    &quot;endpoints&quot;: {
      &quot;plural&quot;: &quot;endpoints&quot;,
      &quot;singular&quot;: &quot;endpoint&quot;,
      &quot;attributes&quot;: {
        ... xRegistry spec-defined attributes excluded for brevity ...
        &quot;shared&quot;: {
          &quot;name&quot;: &quot;shared&quot;,
          &quot;type&quot;: &quot;boolean&quot;
        }
      },

      &quot;resources&quot;: {
        &quot;messages&quot;: {
          &quot;plural&quot;: &quot;messages&quot;,
          &quot;singular&quot;: &quot;message&quot;,
            ... xRegistry spec-defined attributes excluded for brevity ...
            &quot;*&quot;: {
              type: &quot;any&quot;
            }
          },
          &quot;metaattributes&quot;: {
            ... xRegistry spec-defined attributes excluded for brevity ...
            &quot;*&quot;: {
              type: &quot;any&quot;
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h4 id="updating-the-registry-model"><a class="anchor" href="#updating-the-registry-model">☍</a> Updating the Registry Model</h4>
<p>To update the Registry model, the new full representation of the model
MAY be included on an HTTP <code>PUT</code> to the Registry Entity in the <code>model</code>
attribute, or a <code>PUT</code> MAY be done to the <code>/model</code> API. Note that <code>PATCH</code>
is not supported via the <code>/model</code> API.</p>
<p>While the remainder of this section is presented within the scope of the
<code>/model</code> API, the processing rules of the model definition MUST also apply
when it is updated via the <code>model</code> attribute on the Registry entity.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">PUT /model
Content-Type: application/json; charset=utf-8

{
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;attributes&quot;: {
    &quot;STRING&quot;: {
      &quot;name&quot;: &quot;STRING&quot;,
      &quot;type&quot;: &quot;TYPE&quot;,
      &quot;target&quot;: &quot;STRING&quot;, ?
      &quot;namecharset&quot;: &quot;STRING&quot;, ?
      &quot;description&quot;: &quot;STRING&quot;, ?
      &quot;enum&quot;: [ VALUE * ], ?
      &quot;strict&quot;: BOOLEAN, ?
      &quot;readonly&quot;: BOOLEAN, ?
      &quot;immutable&quot;: BOOLEAN, ?
      &quot;required&quot;: BOOLEAN, ?
      &quot;default&quot;: VALUE, ?

      &quot;attributes&quot;: { ... }, ?               # For nested object
      &quot;item&quot;: { ... }, ?                     # For nested map, array

      &quot;ifvalues&quot;: {
        &quot;VALUE&quot;: {
          &quot;siblingattributes&quot;: { ... }
        } *
      } ?
    } *
  },

  &quot;groups&quot;: {
    &quot;STRING&quot;: {
      &quot;plural&quot;: &quot;STRING&quot;,
      &quot;singular&quot;: &quot;STRING&quot;,
      &quot;description&quot;: &quot;STRING&quot;, ?
      &quot;modelversion&quot;: &quot;STRING&quot;, ?
      &quot;compatiblewith&quot;: &quot;URI&quot;, ?
      &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
      &quot;attributes&quot;: { ... }, ?               # See &quot;attributes&quot; above

      &quot;resources&quot;: {
        &quot;STRING&quot;: {
          &quot;plural&quot;: &quot;STRING&quot;,
          &quot;singular&quot;: &quot;STRING&quot;,
          &quot;description&quot;: &quot;STRING&quot;, ?
          &quot;maxversions&quot;: UINTEGER, ?
          &quot;setversionid&quot;: BOOLEAN, ?
          &quot;setdefaultversionsticky&quot;: BOOLEAN, ?
          &quot;hasdocument&quot;: BOOLEAN, ?
          &quot;singleversionroot&quot;: BOOLEAN, ?
          &quot;typemap&quot;: MAP, ?
          &quot;modelversion&quot;: &quot;STRING&quot;, ?
          &quot;compatiblewith&quot;: &quot;URI&quot;, ?
          &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
          &quot;attributes&quot;: { ... }, ?           # Version attributes/extensions
          &quot;metaattributes&quot;: { ... } ?        # Resource attributes/extensions
        } *
      } ?
    } *
  } ?
}
</code></pre>
<p>Where:</p>
<ul>
<li>The HTTP body MUST contain all of the attributes, Groups and Resources that
the client wishes to define.</li>
<li>Specification-defined attributes not included in the request MUST be added
by the server with their default definitions.</li>
</ul>
<p>See <a href="#registry-model">Registry Model</a> for more details about the list of
allowable changes to a model.</p>
<p>A successful response MUST include a full representation of the Registry model
and be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;attributes&quot;: {
    &quot;STRING&quot;: {
      &quot;name&quot;: &quot;STRING&quot;,
      &quot;type&quot;: &quot;TYPE&quot;,
      &quot;target&quot;: &quot;STRING&quot;, ?
      &quot;namecharset&quot;: &quot;STRING&quot;, ?
      &quot;description&quot;: &quot;STRING&quot;, ?
      &quot;enum&quot;: [ VALUE * ], ?
      &quot;strict&quot;: BOOLEAN, ?
      &quot;readonly&quot;: BOOLEAN, ?
      &quot;immutable&quot;: BOOLEAN, ?
      &quot;required&quot;: BOOLEAN, ?
      &quot;default&quot;: VALUE, ?

      &quot;attributes&quot;: { ... }, ?
      &quot;item&quot;: { ... }, ?

      &quot;ifvalues&quot;: {
        &quot;VALUE&quot;: {
          &quot;siblingattributes&quot;: { ... }
        } *
      } ?
    } *
  },

  &quot;groups&quot;: {
    &quot;STRING&quot;: {
      &quot;plural&quot;: &quot;STRING&quot;,
      &quot;singular&quot;: &quot;STRING&quot;,
      &quot;description&quot;: &quot;STRING&quot;, ?
      &quot;modelversion&quot;: &quot;STRING&quot;, ?
      &quot;compatiblewith&quot;: &quot;URI&quot;, ?
      &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
      &quot;attributes&quot;: { ... }, ?

      &quot;resources&quot;: {
        &quot;STRING&quot;: {
          &quot;plural&quot;: &quot;STRING&quot;,
          &quot;singular&quot;: &quot;STRING&quot;,
          &quot;description&quot;: &quot;STRING&quot;, ?
          &quot;maxversions&quot;: UINTEGER, ?
          &quot;setversionid&quot;: BOOLEAN, ?
          &quot;setdefaultversionsticky&quot;: BOOLEAN, ?
          &quot;hasdocument&quot;: BOOLEAN, ?
          &quot;singleversionroot&quot;: BOOLEAN, ?
          &quot;typemap&quot;: MAP, ?
          &quot;modelversion&quot;: &quot;STRING&quot;, ?
          &quot;compatiblewith&quot;: &quot;URI&quot;, ?
          &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
          &quot;attributes&quot;: { ... }, ?
          &quot;metaattributes&quot;: { ... } ?
        } *
      } ?
    } *
  } ?
}
</code></pre>
<p><strong>Examples:</strong></p>
<p>Update a Registry's model to add a new Group type:</p>
<pre><code class="language-yaml">PUT /model
Content-Type: application/json; charset=utf-8

{
  &quot;groups&quot;: {
    &quot;endpoints&quot;: {
      &quot;plural&quot;: &quot;endpoints&quot;,
      &quot;singular&quot;: &quot;endpoint&quot;,
      &quot;attributes&quot;: {
        &quot;shared&quot;: {
          &quot;name&quot;: &quot;shared&quot;,
          &quot;type&quot;: &quot;boolean&quot;
        }
      },

      &quot;resources&quot;: {
        &quot;messages&quot;: {
          &quot;plural&quot;: &quot;messages&quot;,
          &quot;singular&quot;: &quot;message&quot;,
          &quot;attributes&quot;: {
            &quot;*&quot;: {
              type: &quot;any&quot;
            }
          }
        }
      }
    },
    &quot;schemagroups&quot;: {
      &quot;plural&quot;: &quot;schemagroups&quot;,
      &quot;singular&quot;: &quot;schemagroup&quot;,

      &quot;resources&quot;: {
        &quot;schemas&quot;: {
          &quot;plural&quot;: &quot;schemas&quot;,
          &quot;singular&quot;: &quot;schema&quot;
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;attributes&quot;: {
    ... xRegistry spec-defined attributes excluded for brevity ...
  },
  &quot;groups&quot;: {
    &quot;endpoints&quot; {
      &quot;plural&quot;: &quot;endpoints&quot;,
      &quot;singular&quot;: &quot;endpoint&quot;,
      &quot;attributes&quot;: {
        ... xRegistry spec-defined attributes excluded for brevity ...
        &quot;shared&quot;: {
          &quot;name&quot;: &quot;shared&quot;,
          &quot;type&quot;: &quot;boolean&quot;
        }
      },

      &quot;resources&quot;: {
        &quot;messages&quot;: {
          &quot;plural&quot;: &quot;messages&quot;,
          &quot;singular&quot;: &quot;message&quot;,
          ... xRegistry spec-defined attributes excluded for brevity ...
          &quot;attributes&quot;: {
            &quot;*&quot;: {
              type: &quot;any&quot;
            }
          }
          &quot;maxversions&quot;: 1
        }
      }
    },
    &quot;schemagroups&quot;: {
      &quot;plural&quot;: &quot;schemagroups&quot;,
      &quot;singular&quot;: &quot;schemagroup&quot;,

      &quot;resources&quot;: {
        &quot;schemas&quot;: {
          &quot;plural&quot;: &quot;schemas&quot;,
          &quot;singular&quot;: &quot;schema&quot;
          ... xRegistry spec-defined attributes excluded for brevity ...
        }
      }
    }
  }
}
</code></pre>
<h5 id="reuse-of-resource-definitions"><a class="anchor" href="#reuse-of-resource-definitions">☍</a> Reuse of Resource Definitions</h5>
<p>When a Resource type definition is to be shared between Groups, rather than
creating a duplicate Resource definition, the <code>ximport</code> mechanism MAY be used
instead. When defining the Resources of a Group, a special Resource &quot;plural&quot;
name MAY be used to reference other Resource definitions from within the same
Registry. For example, the following abbreviated model definition defines
one Resource type (<code>messages</code>) under the <code>messagegroups</code> Group, that is
also used by the <code>endpoints</code> Group.</p>
<pre><code class="language-yaml">&quot;model&quot;: {
  &quot;groups&quot;: {
    &quot;messagegroups&quot;: {
      &quot;plural&quot;: &quot;messagegroups&quot;,
      &quot;singular&quot;: &quot;messagegroup&quot;,
      &quot;resources&quot;: {
        &quot;messages&quot;: {
          &quot;plural&quot;: &quot;messages&quot;,
          &quot;singular&quot;: &quot;message&quot;
        }
      }
    },
    &quot;endpoints&quot;: {
      &quot;plural&quot;: &quot;endpoints&quot;,
      &quot;singular&quot;: &quot;endpoint&quot;,
      &quot;resources&quot;: {
        &quot;ximport&quot;: [ &quot;messagegroups/messages&quot; ]
      }
    }
  }
}
</code></pre>
<p>The format of the <code>ximport</code> specification is:</p>
<pre><code class="language-yaml">&quot;ximport&quot;: [ &quot;GROUPS/RESOURCES&quot;, * ]
</code></pre>
<p>where:</p>
<ul>
<li>Each array value MUST be a reference to another GROUPS/RESOURCES plural
combination defined within the same Registry. It MUST NOT reference the
same Group under which the <code>ximport</code> resides.</li>
<li>An empty array MAY be specified, implying no Resources are imported.</li>
</ul>
<p>Since the <code>resources</code> attribute is a map, use of the <code>ximport</code> feature MUST
only be used once per Group definition.</p>
<p>Additional locally defined Resources MAY be defined within a Group that uses
the <code>ximport</code> feature, however, Resource <code>plural</code> and <code>singular</code> values
MUST be unique across all imported and locally defined Resources. Locally
defined Resources MUST NOT use <code>ximport</code> as a <code>plural</code> or <code>singular</code> name.</p>
<p>See <a href="#cross-referencing-resources">Cross Referencing Resources</a> for more
additional information.</p>
<h5 id="includes-in-the-xregistry-model-data"><a class="anchor" href="#includes-in-the-xregistry-model-data">☍</a> Includes in the xRegistry Model Data</h5>
<p>There might be times when it is necessary for an xRegistry model to reuse
portions of another xRegistry model defined elsewhere. Rather than forcing
the duplication of the model definitions, an &quot;include&quot; type of JSON directive
MAY be used.</p>
<p>The general formats of the include are:</p>
<pre><code class="language-yaml">&quot;$include&quot;: &quot;PATH-TO-DOCUMENT#JSON-POINTER-IN-DOC&quot;
</code></pre>
<p>or</p>
<pre><code class="language-yaml">&quot;$includes&quot;: [ &quot;PATH-TO-DOCUMENT#JSON-POINTER-IN-DOC&quot; * ]
</code></pre>
<p>where the first form specifies a single reference to be included, and the
second form specifies multiple. The fragment (<code>#...</code>) portion is OPTIONAL.</p>
<p>For example:</p>
<pre><code class="language-yaml">&quot;$include&quot;: &quot;http://example.com/xreg-model.json#/groups/mygroup/attributes&quot;
</code></pre>
<p>is asking for the attributes of a GROUP called <code>mygroup</code> to be included at
this location of the current model definition.</p>
<p>These directives MAY be used in any JSON Object or Map entity in an
xRegistry model definition. The following rules apply for how to process the
include directive:</p>
<ul>
<li>The include path reference value MUST be compatible with the environment in
which the include is being evaluated. For example, in an xRegistry server it
would most likely always be a URL. However, in an external tool the reference
might be to a local file on disk or a URL.</li>
<li>The include MUST reference a JSON Object or Map that is consistent with
the model definition of where the include appears, and the target attributes,
or keys, are processed in place of the <code>$include</code> attribute.</li>
<li>Any attributes already present (as siblings to the include) MUST take
precedence over an included attribute - matching is done via comparing
the <code>name</code> of the attributes.</li>
<li>When <code>$includes</code> is used, the references MUST be processed in order and
earlier attributes included take precedence over subsequently included
attributes.</li>
<li>Both <code>$include</code> and <code>$includes</code> MUST NOT be present at the same time at the
same level in the model.</li>
<li>Included model definitions MAY use <code>include</code> directives, but MUST NOT be
recursive.</li>
<li>Resolution of the include path MUST follow standard path resolution.
Meaning, relative paths are relative to the document with the include
directive.</li>
<li>If present, the fragment (<code>#...</code>) part of the reference MUST adhere to the
<a href="https://datatracker.ietf.org/doc/html/rfc6901">JSON Pointer</a> specification.</li>
</ul>
<p>When the directives are used in a request to update the model, the server MUST
resolve all includes prior to processing the request and MUST return the
expanded model in response to the request for the model. The includes MUST NOT
be processed again at a later time. A request to re-evaluate the includes can
be done via a subsequent model update operation. Note, this means that when
the model is subsequently retrieved (e.g. via an HTTP <code>GET</code>) the include
directives MUST NOT be in the response.</p>
<p><strong>Examples:</strong></p>
<p>A model definition that includes xRegistry attributes from a file on a remote
server, and adds the definition of one attribute to a GROUP named <code>mygroups</code>
from an external Group named <code>group1</code> in another xRegistry.</p>
<pre><code class="language-yaml">{
  &quot;attributes&quot;: {
    &quot;$include&quot;: &quot;http://example.com/someattributes&quot;,
    &quot;myattribute&quot;: {
      &quot;name&quot;: &quot;myattribute&quot;,
      &quot;type&quot;: &quot;string&quot;
    }
  }
  &quot;groups&quot;: {
    &quot;mygroups&quot;: {
      &quot;plural&quot;: &quot;mygroups&quot;,
      &quot;singular&quot;: &quot;mygroup&quot;,
      &quot;attributes&quot;: {
        &quot;attr1&quot;: {
          &quot;$include&quot;: &quot;http://example.com/model#/groups/group1/attributes/attr1&quot;
        }
        ... remainder of model excluded for brevity ...
      }
    }
  }
}
</code></pre>
<p>where <code>http://example.com/someattributes</code> might look like:</p>
<pre><code class="language-yaml">{
  &quot;myattr&quot;: {
    &quot;name&quot;: &quot;myattr&quot;,
    &quot;type&quot;: &quot;string&quot;
  }
}
</code></pre>
<p>and the second include target might look like:</p>
<pre><code class="language-yaml">{
  &quot;name&quot;: &quot;attr1&quot;,
  &quot;type&quot;: &quot;string&quot;
}
</code></pre>
<hr>
<h3 id="exporting"><a class="anchor" href="#exporting">☍</a> Exporting</h3>
<p>The <code>/export</code> API MUST be an alias for
<code>GET /?doc&amp;inline=*,model,capabilities&quot;. If supported, it MUST only support the </code>GET` HTTP method. This API was created:</p>
<ul>
<li>As a shorthand convenience syntax for clients that need to download the
entire Registry as a single document. For example, to then be used in an
&quot;import&quot; type of operation for another Registry, or for tooling that
does not need the duplication of information that <code>?doc</code> removes.</li>
<li>To allow for servers that do not support query parameters (such as
<a href="#no-code-servers">No-Code Servers</a>) to expose the entire Registry with a
single API call.</li>
</ul>
<p>Query parameters MAY be included on the request and any <code>?inline</code> flag
specified MUST override the default value defined above.</p>
<hr>
<h3 id="groups"><a class="anchor" href="#groups">☍</a> Groups</h3>
<p>Groups represent entities that typically act as a collection mechanism for
related Resources. However, it is worth noting that Groups do not have to have
Resources associated with them. It is possible to have Groups be the main (or
only) entity of a Registry. Each Group type MAY have any number of Resource
types within it. This specification does not define how the Resources within a
Group type are related to each other.</p>
<p>The serialization of a Group entity adheres to this form:</p>
<pre><code class="language-yaml">{
  &quot;GROUPid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,
  &quot;epoch&quot;: UINTEGER,
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,

  # Repeat for each Resource type in the Group
  &quot;RESOURCESurl&quot;: &quot;URL&quot;,                    # e.g. &quot;messagesurl&quot;
  &quot;RESOURCEScount&quot;: UINTEGER,               # e.g. &quot;messagescount&quot;
  &quot;RESOURCES&quot;: { RESOURCES collection } ?   # If inlined
}
</code></pre>
<p>Groups include the following
<a href="#common-attributes">common attributes</a>:</p>
<ul>
<li><a href="#singularid-id-attribute"><code>GROUPid</code></a> - REQUIRED in API and document views.
OPTIONAL in requests.</li>
<li><a href="#self-attribute"><code>self</code></a> - REQUIRED in API and document views. OPTIONAL in
requests.</li>
<li><a href="#shortself-attribute"><code>shortself</code></a> - OPTIONAL in API and document views,
based on the <code>shortself</code> capability. OPTIONAL in requests.</li>
<li><a href="#xid-attribute"><code>xid</code></a> - REQUIRED in API and document views. OPTIONAL in
requests.</li>
<li><a href="#epoch-attribute"><code>epoch</code></a> - REQUIRED in API and document views. OPTIONAL in
requests.</li>
<li><a href="#name-attribute"><code>name</code></a> - OPTIONAL.</li>
<li><a href="#description-attribute"><code>description</code></a> - OPTIONAL.</li>
<li><a href="#documentation-attribute"><code>documentation</code></a> - OPTIONAL.</li>
<li><a href="#labels-attribute"><code>labels</code></a> - OPTIONAL.</li>
<li><a href="#createdat-attribute"><code>createdat</code></a> - REQUIRED in API and document views.
OPTIONAL in requests.</li>
<li><a href="#modifiedat-attribute"><code>modifiedat</code></a> - REQUIRED in API and document views.
OPTIONAL in requests.</li>
</ul>
<p>and the following Group level attributes:</p>
<h5 id="resources-collections"><a class="anchor" href="#resources-collections">☍</a> <code>RESOURCES</code> Collections</h5>
<ul>
<li>
<p>Type: Set of <a href="#registry-collections">Registry Collections</a>.</p>
</li>
<li>
<p>Description: A list of Registry collections that contain the set of
Resources supported by the Group.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>It MUST include all nested Resource Collection types of the owning Group,
even if some of the collections are empty.</li>
</ul>
</li>
</ul>
<h4 id="retrieving-a-group-collection"><a class="anchor" href="#retrieving-a-group-collection">☍</a> Retrieving a Group Collection</h4>
<p>To retrieve a Group collection, an HTTP <code>GET</code> MAY be used.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">GET /GROUPS
</code></pre>
<p>A successful response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Link: &lt;URL&gt;;rel=next;count=UINTEGER ?

{
  &quot;KEY&quot;: {                                     # GROUPid
    &quot;GROUPid&quot;: &quot;STRING&quot;,
    &quot;self&quot;: &quot;URL&quot;,
    &quot;shortself&quot;: &quot;URL&quot;, ?
    &quot;xid&quot;: &quot;XID&quot;,
    &quot;epoch&quot;: UINTEGER,
    &quot;name&quot;: &quot;STRING&quot;, ?
    &quot;description&quot;: &quot;STRING&quot;, ?
    &quot;documentation&quot;: &quot;URL&quot;, ?
    &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
    &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
    &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,

    # Repeat for each Resource type in the Group
    &quot;RESOURCESurl&quot;: &quot;URL&quot;,                    # e.g. &quot;messagesurl&quot;
    &quot;RESOURCEScount&quot;: UINTEGER,               # e.g. &quot;messagescount&quot;
    &quot;RESOURCES&quot;: { RESOURCES collection } ?   # If inlined
  } *
}
</code></pre>
<p><strong>Examples:</strong></p>
<p>Retrieve all entities in the <code>endpoints</code> Group:</p>
<pre><code class="language-yaml">GET /endpoints
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Link: &lt;https://example.com/endpoints&amp;page=2&gt;;rel=next;count=100

{
  &quot;ep1&quot;: {
    &quot;endpointid&quot;: &quot;ep1&quot;,
    &quot;self&quot;: &quot;https://example.com/endpoints/ep1&quot;,
    &quot;xid&quot;: &quot;/endpoints/ep1&quot;,
    &quot;epoch&quot;: 1,
    &quot;name&quot;: &quot;A cool endpoint&quot;,
    &quot;createdat&quot;: &quot;2024-04-30T12:00:00Z&quot;,
    &quot;modifiedat&quot;: &quot;2024-04-30T12:00:01Z&quot;,

    &quot;messagesurl&quot;: &quot;https://example.com/endpoints/ep1/messages&quot;,
    &quot;messagescount&quot;: 5
  },
  &quot;ep2&quot;: {
    &quot;endpointid&quot;: &quot;ep2&quot;,
    &quot;self&quot;: &quot;https://example.com/endpoints/ep2&quot;,
    &quot;xid&quot;: &quot;/endpoints/ep2&quot;,
    &quot;epoch&quot;: 3,
    &quot;name&quot;: &quot;Redis Queue&quot;,
    &quot;createdat&quot;: &quot;2024-04-30T12:00:00Z&quot;,
    &quot;modifiedat&quot;: &quot;2024-04-30T12:00:01Z&quot;,

    &quot;messagesurl&quot;: &quot;https://example.com/endpoints/ep2/messages&quot;,
    &quot;messagescount&quot;: 1
  }
}
</code></pre>
<p>Notice that the <code>Link</code> HTTP header is present, indicating that there
is a second page of results that can be retrieved via the specified URL,
and that there are total of 100 items in this collection.</p>
<h4 id="creating-or-updating-groups"><a class="anchor" href="#creating-or-updating-groups">☍</a> Creating or Updating Groups</h4>
<p>Creating or updating Groups via HTTP MAY be done by using the HTTP <code>PUT</code>,
<code>PATCH</code> or <code>POST</code> methods:</p>
<ul>
<li><code>PUT   /GROUPS/gID</code>       # Create/update a single Group</li>
<li><code>PATCH /GROUPS/gID</code>       # Create/update a single Group</li>
<li><code>PATCH /GROUPS</code>           # Create/update multiple Groups of type GROUPS</li>
<li><code>POST  /GROUPS</code>           # Create/update multiple Groups of type GROUPS</li>
</ul>
<p>The processing of the above APIs is defined in the <a href="#creating-or-updating-entities">Creating or Updating
Entities</a> section.</p>
<ul>
<li><code>POST  /</code>                 # Create/update multiple Groups of varying types</li>
</ul>
<p>This API is very similar to the <code>POST /GROUPS</code> above except that the HTTP
body MUST be a map of Group types as shown below:</p>
<pre><code class="language-yaml">{
  &quot;endpoints&quot;: {
    &quot;endpoint1&quot;: { ... Group endpoint1's xRegistry metadata ... },
    &quot;endpoint2&quot;: { ... Group endpoint2's xRegistry metadata ... }
  },
  &quot;schemagroups&quot;: {
    &quot;schemagroup1&quot;: { ... Group schemagroup1's xRegistry metadata ... },
    &quot;schemagroup2&quot;: { ... Group schemagroup2's xRegistry metadata ... }
  }
}
</code></pre>
<p>Notice the format is almost the same as what a <code>PUT /</code> would look like if the
request wanted to update the Registry's attributes and define a set of Groups,
but without the Registry's attributes. This allows for an update of the
specified Groups without modifying the Registry's attributes.</p>
<p>The response in this case MUST be a map of the Group types with just the
Groups that were processed as part of the request.</p>
<p>Each individual Group definition MUST adhere to the following:</p>
<pre><code class="language-yaml">{
  &quot;GROUPid&quot;: &quot;STRING&quot;, ?
  &quot;self&quot;: &quot;URL&quot;, ?
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;, ?
  &quot;epoch&quot;: UINTEGER, ?
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;, ?
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;, ?

  # Repeat for each Resource type in the Group
  &quot;RESOURCESurl&quot;: &quot;URL&quot;,                     # e.g. &quot;messagesurl&quot;
  &quot;RESOURCEScount&quot;: UINTEGER,                # e.g. &quot;messagescount&quot;
  &quot;RESOURCES&quot;: { RESOURCES collection } ?
}
</code></pre>
<p>Each individual Group in a successful response MUST adhere to the following:</p>
<pre><code class="language-yaml">{
  &quot;GROUPid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,
  &quot;epoch&quot;: UINTEGER,
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,

  # Repeat for each Resource type in the Group
  &quot;RESOURCESurl&quot;: &quot;URL&quot;,                    # e.g. &quot;messagesurl&quot;
  &quot;RESOURCEScount&quot;: UINTEGER                # e.g. &quot;messagescount&quot;
}
</code></pre>
<p><strong>Examples:</strong></p>
<p>Targeted request to create a specific Group by <code>GROUPid</code>:</p>
<pre><code class="language-yaml">PUT /endpoints/ep1
Content-Type: application/json; charset=utf-8

{
  &quot;endpointid&quot;: &quot;ep1&quot;,
  ... remainder of Endpoint 'ep1' definition ...
}
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 201 Created
Content-Type: application/json; charset=utf-8
Location: https://example.com/endpoints/ep1

{
  &quot;endpointid&quot;: &quot;ep1&quot;,
  ... remainder of Endpoint 'ep1' definition ...
}
</code></pre>
<p>Multiple Groups specified in the HTTP body:</p>
<pre><code class="language-yaml">POST /endpoints
Content-Type: application/json; charset=utf-8

{
  &quot;ep1&quot;: {
    &quot;endpointid&quot;: &quot;ep1&quot;,
    ... remainder of ep1 definition ...
  },
  &quot;ep2&quot;: {
    &quot;endpointid&quot;: &quot;ep2&quot;,
    ... remainder of ep2 definition ...
  }
}
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;ep1&quot;: {
    &quot;endpointid&quot;: &quot;ep1&quot;,
    ... remainder of ep1 definition ...
  },
  &quot;ep2&quot;: {
    &quot;endpointid&quot;: &quot;ep2&quot;,
    ... remainder of ep2 definition ...
  }
}
</code></pre>
<h4 id="retrieving-a-group"><a class="anchor" href="#retrieving-a-group">☍</a> Retrieving a Group</h4>
<p>To retrieve a Group, an HTTP <code>GET</code> MAY be used.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">GET /GROUPS/gID
</code></pre>
<p>A successful response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;GROUPid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,
  &quot;epoch&quot;: UINTEGER,
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,

  # Repeat for each Resource type in the Group
  &quot;RESOURCESurl&quot;: &quot;URL&quot;,                     # e.g. &quot;messagesurl&quot;
  &quot;RESOURCEScount&quot;: UINTEGER,                # e.g. &quot;messagescount&quot;
  &quot;RESOURCES&quot;: { RESOURCES collection } ?    # If inlined
}
</code></pre>
<p><strong>Examples:</strong></p>
<p>Retrieve a single <code>endpoints</code> Group:</p>
<pre><code class="language-yaml">GET /endpoints/ep1
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;GROUPid&quot;: &quot;ep1&quot;,
  &quot;self&quot;: &quot;https://example.com/endpoints/ep1&quot;,
  &quot;xid&quot;: &quot;/endpoints/ep1&quot;,
  &quot;epoch&quot;: 1,
  &quot;name&quot;: &quot;myEndpoint&quot;,
  &quot;createdat&quot;: &quot;2024-04-30T12:00:00Z&quot;,
  &quot;modifiedat&quot;: &quot;2024-04-30T12:00:01Z&quot;,

  &quot;messagesurl&quot;: &quot;https://example.com/endpoints/ep1/messages&quot;,
  &quot;messagescount&quot;: 5
}
</code></pre>
<h4 id="deleting-groups"><a class="anchor" href="#deleting-groups">☍</a> Deleting Groups</h4>
<p>To delete one or more Groups, an HTTP <code>DELETE</code> MAY be used:</p>
<ul>
<li><code>DELETE /GROUPS/gID[?epoch=UINTEGER]</code></li>
<li><code>DELETE /GROUPS</code></li>
</ul>
<p>The processing of these two APIs is defined in the <a href="#deleting-entities-in-a-registry-collection">Deleting Entities in a
Registry Collection</a>
section.</p>
<hr>
<h3 id="resources"><a class="anchor" href="#resources">☍</a> Resources</h3>
<p>Resources typically represent the main entity that the Registry is managing.
Each Resource is associated with a Group to aid in their discovery and to show
a relationship with Resources in that same Group. Resources appear within the
Group's <code>RESOURCES</code> collection.</p>
<p>Resources, like all entities in the Registry, can be modified but Resources
can also have a version history associated with them, allowing for users to
retrieve previous Versions of the Resource. In this respect, Resources have
a 2-layered definition. The first layer is the Resource entity itself,
and the second layer is its <code>versions</code> collection - the version history of
the Resource.</p>
<p>The Resource entity serves three purposes:
1 - It represents the collection for the historical Versions of the data being
managed. This is true even if the Resource type is defined to not use
versioning, meaning the number of Versions allowed is just one. The
Versions will appear as a nested entity under the <code>versions</code> attribute.<br>
2 - It is an alias for the &quot;default&quot; Version of the Resource. And most
operations directed at the URL of the Resource will act upon that Version,
not the Resource itself. See
<a href="#default-version-of-a-resource">Default Version of a Resource</a> and
<a href="#versions">Versions</a> for more details.<br>
3 - It has a set of attributes for Resource level metadata - data that is not
specific to one Version of the Resource but instead applies to the
Resource in general. These attributes appear under a <code>meta</code>
attribute/sub-object so as to keep them separate from any Version level
attributes. Note that these attributes do not appear on the Versions.</p>
<p>The URL of a Resource can be thought of as an alias for the &quot;default&quot;
Version of the Resource, and as such, most of the attributes shown when
processing the Resource will be mapped from the &quot;default&quot; Version.</p>
<p>However, there a few exceptions:</p>
<ul>
<li><code>self</code> MUST be a URL to the Resource, and not to the &quot;default&quot;
Version in the <code>versions</code> collection. The Resource's <code>defaultversionurl</code>
attribute (in the <code>meta</code> sub-object) can be used to locate the &quot;default&quot;
Version.</li>
<li><code>shortself</code>, if present, MUST be an alternative URL for <code>self</code>.</li>
<li><code>xid</code> MUST be a relative URI to the Resource, and not to the &quot;default&quot;
Version in the <code>versions</code> collection.</li>
<li>A few extra attributes will appear to help with the navigation of the
Resource. For example, a URL to the <code>meta</code> sub-object and the <code>versions</code>
Collection attributes.</li>
</ul>
<p>The remainder of this section discusses the processing rules for Resources
and Versions. While it mainly uses the term &quot;Resource&quot; for ease of reading, in
most cases it can be assumed that the same applies for &quot;Versions&quot;. When this
is not the case, it will be explicitly called out.</p>
<h4 id="resource-metadata-vs-resource-document"><a class="anchor" href="#resource-metadata-vs-resource-document">☍</a> Resource Metadata vs Resource Document</h4>
<p>Unlike Groups, which consist entirely of xRegistry managed metadata, Resources
typically have their own domain-specific data and document format that needs
to be kept distinct from the xRegistry Resource metadata. As discussed
previously, the model definition for Resource has a <code>hasdocument</code> attribute
indicating whether a Resource type defines its own separate document or not.</p>
<p>This specification does not define any requirements for the contents of this
separate document, and it doesn't even need to be stored within the Registry.
The Resource MAY choose to simply store a URL reference to the externally
managed document instead. When the document is stored within the Registry, it
can be managed as an opaque array of bytes.</p>
<p>When a Resource does have a separate document, HTTP interactions to the URL
for the Resource MUST include this document in the HTTP body as it is typically
the data of interest for end users. As a convenance, the simple (mainly
scalar) xRegistry metadata of the Resource will appear as HTTP headers.</p>
<p>To change this view such that the xRegistry metadata becomes the data of
interest, the request URLs MUST have <code>$details</code> appended to them. In these
cases, the HTTP body of the requests and responses MUST have a JSON
serialization of the entity's xRegistry metadata, and the separate document
MAY appear as an attribute within that metadata based on the specific
operation being done.</p>
<p>For example:</p>
<pre><code class="language-yaml">GET https://example.com/schemagroups/mygroup/schemas/myschema
</code></pre>
<p>will retrieve the schema document associated with the <code>myschema</code> Resource,
while:</p>
<pre><code class="language-yaml">GET https://example.com/schemagroups/mygroup/schemas/myschema$details
</code></pre>
<p>will retrieve the xRegistry metadata information for the <code>myschema</code> Resource.</p>
<p>When the Resource's path is appended with <code>$details</code>, the Resource's document
becomes available via a set of <code>RESOURCE*</code> attributes within that metadata:</p>
<ul>
<li>
<p><code>RESOURCE</code>: this attribute MUST be used when the contents of the Resource's
document are stored within the Registry and its &quot;array of bytes&quot; can be
used directly in the serialization of the Resource metadata &quot;as is&quot;. Meaning,
in the JSON case, those bytes can be parsed as a JSON value without any
additional processing (such as escaping) being done. This is a convenience
(optimization) attribute to make it easier to view the document when it
happens to be in the same format as the xRegistry itself.</p>
<p>The model Resource attribute <code>typemap</code> MAY be used to help the server
determine which <code>contenttype</code> values are of the same format - see
<a href="#registry-model">Registry Model</a> for more information. If a Resource has
a matching <code>contenttype</code> but the contents of the Resource's document do not
successfully parse (e.g. it's <code>application/json</code> but the JSON is invalid),
then <code>RESOURCE</code> MUST NOT be used and <code>RESOURCEbase64</code> MUST be used instead.</p>
</li>
<li>
<p><code>RESOURCEbase64</code>: this attribute MUST be used when the contents of the
Resource's are stored within the Registry but <code>RESOURCE</code> can not be used.
The Resource's document is base64 encoded and serialized as a string.</p>
</li>
<li>
<p><code>RESOURCEurl</code>: this attribute MUST be used when the Resource is stored
external to the Registry and its value MUST be a URL that can be used to
retrieve its contents via an HTTP(s) <code>GET</code>.</p>
</li>
</ul>
<p>When accessing a Resource's metadata with <code>$details</code>, often it is to
view or update the xRegistry metadata and not the document, as such, including
the potentially large amount of data from the Resource's document in request
and response messages could be cumbersome. To address this, the <code>RESOURCE</code> and
<code>RESOURCEbase64</code> attributes do not appear by default as part of the
serialization of the Resource. Rather, they MUST only appear in responses when
the <a href="#inline-flag"><code>?inline=RESOURCE</code></a> query parameter is used. Likewise, in
requests, these attributes are OPTIONAL and would only need to be used when a
change to the document's content is needed at the same time as updates to the
Resource's metadata. However, the <code>RESOURCEurl</code> attribute MUST always appear
if it has a value.</p>
<p>Note that the serialization of a Resource MUST only use at most one of these 3
attributes at a time.</p>
<h4 id="resource-attributes"><a class="anchor" href="#resource-attributes">☍</a> Resource Attributes</h4>
<p>Resource attributes are non-versioned attributes associated with a Resource.
In a sense they can be considered to be global to the Resource and its
Versions, but they are not part of, or serialized in, any Version. Instead,
they are serialized in two different ways:</p>
<p>1 - some will appear within a <code>meta</code> attribute/sub-object to the Resource.
This keeps them separate from the default Version attributes that might
appear. However, the <code>meta</code> attribute itself will appear as a sibling to
the default Version attributes. Note that <code>meta</code> will only be
serialized when requested by the client.</p>
<p>2 - some will appear as siblings to the default Version attributes within the
Resource serialization. These appear here, rather than under <code>meta</code>,
because they are specifically designed to help with the traversal of the
Resource's hierarchy and putting them &quot;one level down&quot; would reduce their
usefulness.</p>
<p>When the Resource is serialized as a JSON object, the serialization of the
Resource attribute MUST adhere to the following:</p>
<pre><code class="language-yaml">{
  &quot;RESOURCEid&quot;: &quot;STRING&quot;,
  &quot;versionid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,                           # URL to Resource, not Version
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,                            # Relative URI to Resource
  # Default Version attributes appear here

  &quot;metaurl&quot;: &quot;URL&quot;,
  &quot;meta&quot;: {                                # Only if inlined
    &quot;RESOURCEid&quot;: &quot;STRING&quot;,
    &quot;self&quot;: &quot;URL&quot;,                         # Absolute Meta URL, not Version
    &quot;shortself&quot;: &quot;URL&quot;, ?
    &quot;xid&quot;: &quot;XID&quot;,                          # Relative Meta URI, not Version
    &quot;xref&quot;: &quot;URL&quot;, ?                       # Ptr to linked Resource
    &quot;epoch&quot;: UINTEGER,                     # Resource's epoch
    &quot;createdat&quot;: &quot;TIMESTAMP&quot;,              # Resource's
    &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,             # Resource's
    &quot;readonly&quot;: BOOLEAN,                   # Default=false
    &quot;compatibility&quot;: &quot;STRING&quot;,             # Default=none
    &quot;compatibilityauthority&quot;: &quot;STRING&quot;, ?  # Default=external
    &quot;deprecated&quot;: { ... }, ?

    &quot;defaultversionid&quot;: &quot;STRING&quot;,
    &quot;defaultversionurl&quot;: &quot;URL&quot;,
    &quot;defaultversionsticky&quot;: BOOLEAN        # Default=false
  }, ?
  &quot;versionsurl&quot;: &quot;URL&quot;,
  &quot;versionscount&quot;: UINTEGER,
  &quot;versions&quot;: { map of Versions }          # Only if inlined
}
</code></pre>
<p>Note that the <code>meta</code> and <code>versions</code> attributes MUST only appear when
requested by the client - for example, via the <code>?inline</code> flag.</p>
<p>When the Resource is serialized with its domain-specific document in the
HTTP body, then Resource level attributes SHOULD appear as HTTP headers and
adhere to the following:</p>
<pre><code class="language-yaml">xRegistry-RESOURCEid: STRING
xRegistry-versionid: STRING
xRegistry-self: URL
xRegistry-xid: URI
# Default Version attributes, and other HTTP headers, appear here
xRegistry-metaurl: URL
xRegistry-versionsurl: URL
xRegistry-versionscount: UINTEGER
</code></pre>
<p>Notice the <code>meta</code> and <code>versions</code> attributes are not included since they are
not complex data types.</p>
<p>The Resource level attributes include the following
<a href="#common-attributes">common attributes</a>:</p>
<ul>
<li><a href="#singularid-id-attribute"><code>RESOURCEid</code></a> - REQUIRED in API and document
views. OPTIONAL in requests.</li>
<li><a href="#self-attribute"><code>self</code></a> - REQUIRED in API and document view. OPTIONAL in
requests.</li>
<li><a href="#shortself-attribute"><code>shortself</code></a> - OPTIONAL in API and document views,
based on the <code>shortself</code> capability. OPTIONAL in requests.</li>
<li><a href="#xid-attribute"><code>xid</code></a> - REQUIRED in API and document views. OPTIONAL in
requests.</li>
</ul>
<p>and the following Resource level attributes:</p>
<h5 id="xref-attribute"><a class="anchor" href="#xref-attribute">☍</a> <code>xref</code> Attribute</h5>
<ul>
<li>
<p>Type: Relative URI (xid).</p>
</li>
<li>
<p>Description: indicates that this Resource is a reference to another Resource
within the same Registry. See <a href="#cross-referencing-resources">Cross Referencing
Resources</a> for more information.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>OPTIONAL.</li>
<li>If present, it MUST be the <code>xid</code> of a same-typed Resource in the Registry.</li>
</ul>
</li>
</ul>
<h5 id="readonly-attribute"><a class="anchor" href="#readonly-attribute">☍</a> <code>readonly</code> Attribute</h5>
<ul>
<li>
<p>Type: Boolean</p>
</li>
<li>
<p>Description: indicates whether this Resource is updateable by clients. This
attribute is a server controlled attribute and therefore cannot be modified
by clients. This specification makes no statement as to when Resources are to
be read-only.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be a read-only attribute.</li>
<li>When not specified, the default value MUST be <code>false</code>.</li>
<li>It MUST be a case-sensitive <code>true</code> or <code>false</code>.</li>
<li>A request to update a read-only Resource MUST generate an error
(<a href="#readonly">readonly</a>) unless the <code>?noreadonly</code> query parameter was used,
in which case the error MUST be silently ignored. See
<a href="#registry-apis">Registry APIs</a> for more information.</li>
</ul>
</li>
</ul>
<h5 id="compatibility-attribute"><a class="anchor" href="#compatibility-attribute">☍</a> <code>compatibility</code> Attribute</h5>
<ul>
<li>
<p>Type: String (with resource-specified enumeration of possible values)</p>
</li>
<li>
<p>Description: States that Versions of this Resource adhere to a certain
compatibility rule. For example, a &quot;backward&quot; compatibility value would
indicate that all Versions of a Resource are backwards compatible with the
next oldest Version, as determined by their <code>ancestor</code> attributes.</p>
<p>This specification makes no statement as to which parts of the data are
examined for compatibility (e.g. xRegistry metadata, domain-specific
document, etc.). This SHOULD be defined by the <code>compatibility</code> values.
The exact meaning of what each <code>compatibility</code> value means might vary based
on the data model of the Resource, therefore this specification only defines
a very high-level abstract meaning for each to ensure some degree of
consistency. However, domain-specific specifications are expected to
modify the <code>compatibility</code> enum values defined in the Resource's model to
limit the list of available values and to define the exact meaning of each.
Implementations MUST include <code>none</code> as one of the possible values and when
set to <code>none</code> then compatibility checking MUST NOT be performed.</p>
<p>If the <code>compatibilityauthority</code> attribute is set to <code>server</code> then
implementations of this specification are REQUIRED to perform the proper
compatibility checks to ensure that all Versions of a Resource adhere to the
rules defined by the current value of this attribute.
For <code>compatibility</code> strategies that require understanding the sequence in
which Versions need to be compatible, the server MUST use the
<a href="#ancestor-attribute"><code>ancestor</code></a> to determine the sequence of Versions.</p>
<p>Note that, like all attributes, if a default value is defined as part of the
model, then this attribute MUST be populated with that value if no value
is provided.</p>
<p>This specification defines the following enumeration values. Implementations
MAY choose to extend this list, or use a subset of it.</p>
<ul>
<li><code>backward</code> - A Version is compatible with the next oldest Version.</li>
<li><code>backward_transitive</code> - A Version is compatible with all older Versions.</li>
<li><code>forward</code> - A Version is compatible with the next newest Version.</li>
<li><code>forward_transitive</code> - A Version is compatible with all newer Versions.</li>
<li><code>full</code> - A Version is compatible with the next oldest and next newest
Versions.</li>
<li><code>full_transitive</code> - A Version is compatible with all older and all newer
Versions.</li>
<li><code>none</code> - No compatibility checking is performed.</li>
</ul>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>It MUST be a case-sensitive value from the model-defined enumeration range.</li>
<li>When not specified, the default value MUST be <code>none</code>.</li>
<li>The enumeration range MUST include <code>none</code> as a valid value.</li>
<li>If the <code>compatibilityauthority</code> attribute is set to <code>server</code>, when
changing the <code>compatibility</code> attribute, the server MUST validate whether
the new <code>compatibility</code> value can be enforced across all existing
Versions. If that's not the case, the server MUST generate an error
(<a href="#compatibility_violation">compatibility_violation</a>).</li>
</ul>
</li>
</ul>
<h4 id="compatibilityauthority-attribute"><a class="anchor" href="#compatibilityauthority-attribute">☍</a> <code>compatibilityauthority</code> Attribute</h4>
<ul>
<li>
<p>Name: <code>compatibilityauthority</code></p>
</li>
<li>
<p>Type: String</p>
</li>
<li>
<p>Description: Indicates the authority that enforces the <code>compatibility</code>
value defined by the owning Resource.</p>
<p>This specification defines the following enumeration values. Implementations
MAY choose to extend this list.</p>
<ul>
<li><code>external</code> - The compatibility is enforced by an external authority.</li>
<li><code>server</code> - The compatibility is enforced by the server.</li>
</ul>
<p>The server MUST generate an error
(<a href="#compatibility_violation">compatibility_violation</a>) following any
attempt to set the <code>compatibilityauthority</code> attribute to <code>server</code> if the
server cannot enforce the compatibility for the Resource's Versions.</p>
<p>When set to <code>server</code>, the server MUST generate an error
(<a href="#compatibility_violation">compatibility_violation</a>) following any
attempt to create/update a Resource (or its Versions) that would result in
those entities violating the stated compatibility statement.</p>
<p>A value of <code>external</code> indicates that the server MUST NOT perform any
compatibility checking and that the compatibility checking is performed by
an external authority.</p>
<p>Attempts to change this value to <code>server</code> MUST result in the validation of
existing Versions.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>MUST be present when <code>compatibility</code> is not <code>none</code>.</li>
<li>MUST NOT be present when <code>compatibility</code> is <code>none</code>.</li>
<li>When not specified, and <code>compatibility</code> is not <code>none</code>, the default value
MUST be <code>external</code>.</li>
<li>If present, MUST be non-empty.</li>
</ul>
</li>
</ul>
<h4 id="deprecated"><a class="anchor" href="#deprecated">☍</a> <code>deprecated</code></h4>
<ul>
<li>
<p>Type: Object containing the following properties:</p>
<ul>
<li>
<p><code>effective</code><br>
An OPTIONAL property indicating the time when the Resource entered, or will
enter, a deprecated state. The date MAY be in the past or future. If this
property is not present the Resource is already in a deprecated state.
If present, this MUST be an <a href="https://tools.ietf.org/html/rfc3339">RFC3339</a> timestamp.</p>
</li>
<li>
<p><code>removal</code><br>
An OPTIONAL property indicating the time when the Resource MAY be removed.
The Resource MUST NOT be removed before this time. If this property is not
present then client can not make any assumption as to when the Resource
might be removed. Note: as with most properties, this property is mutable.
If present, this MUST be an <a href="https://tools.ietf.org/html/rfc3339">RFC3339</a> timestamp and MUST NOT be
sooner than the <code>effective</code> time if present.</p>
</li>
<li>
<p><code>alternative</code><br>
An OPTIONAL property specifying the URL to an alternative Resource the
client can consider as a replacement for this Resource. There is no
guarantee that the referenced Resource is an exact replacement, rather the
client is expected to investigate the Resource to determine if it is
appropriate.</p>
</li>
<li>
<p><code>docs</code><br>
An OPTIONAL property specifying the URL to additional information about
the deprecation of the Resource. This specification does not mandate any
particular format or information, however some possibilities include:
reasons for the deprecation or additional information about likely
alternative Resources. The URL MUST support an HTTP GET request.</p>
</li>
</ul>
<p>Note that an implementation is not mandated to use this attribute in
advance of removing a Resource, but is it RECOMMENDED that they do so.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>OPTIONAL</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>&quot;deprecated&quot;: {}</code></li>
<li>
<pre><code>&quot;deprecated&quot;: {
  &quot;removal&quot;: &quot;2030-12-19T00:00:00&quot;,
  &quot;alternative&quot;: &quot;https://example.com/entities-v2/myentity&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="defaultversionid-attribute"><a class="anchor" href="#defaultversionid-attribute">☍</a> <code>defaultversionid</code> Attribute</h5>
<ul>
<li>
<p>Type: String</p>
</li>
<li>
<p>Description: the <code>versionid</code> of the default Version of the Resource.
This specification makes no statement as to the format of this string or
versioning scheme used by implementations of this specification. However, it
is assumed that newer Versions of a Resource will have a &quot;higher&quot;
value than older Versions.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be the <code>versionid</code> of the default Version of the Resource.</li>
<li>See the <a href="#defaultversionsticky-attribute"><code>defaultversionsticky</code> Attribute</a>
below for how to process these two attributes.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>1</code>, <code>2.0</code>, <code>v3-rc1</code> (v3's release candidate 1)</li>
</ul>
</li>
</ul>
<h5 id="defaultversionurl-attribute"><a class="anchor" href="#defaultversionurl-attribute">☍</a> <code>defaultversionurl</code> Attribute</h5>
<ul>
<li>
<p>Type: URL</p>
</li>
<li>
<p>Description: a URL to the default Version of the Resource.</p>
<p>This URL MUST NOT include the <code>$detail</code> suffix even if the Resource's
<code>hasdocument</code> aspect is set to <code>true</code>.</p>
</li>
<li>
<p>API View Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be an absolute URL to the default Version of the Resource, and MUST
be the same as the Version's <code>self</code> attribute.</li>
<li>MUST be a read-only attribute.</li>
</ul>
</li>
<li>
<p>Document View Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>If the default Version is inlined in the document then this attribute
MUST be a relative URL of the form <code>#JSON-POINTER</code> where the <code>JSON-POINTER</code>
locates the default Version within the current document. See
<a href="#doc-flag">Doc Flag</a> for more information.</li>
<li>If the default Version is not inlined in the document, then this attribute
MUST be an absolute URL per the API view constraints listed above.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>https://example.com/endpoints/ep1/messages/msg1/versions/1.0</code></li>
</ul>
</li>
</ul>
<h5 id="defaultversionsticky-attribute"><a class="anchor" href="#defaultversionsticky-attribute">☍</a> <code>defaultversionsticky</code> Attribute</h5>
<ul>
<li>
<p>Type: Boolean</p>
</li>
<li>
<p>Description: indicates whether or not the &quot;default&quot; Version has been
explicitly set or whether the &quot;default&quot; Version is always the newest one
based on the <code>createdat</code> timestamp. A value of <code>true</code> means that it has been
explicitly set and the value of <code>defaultversionid</code> MUST NOT automatically
change if Versions are added or removed. A value of <code>false</code> means the default
Version MUST be the newest Version based on <code>createdat</code> timestamps.</p>
<p>When set to <code>true</code>, if the default Version is deleted, then without any
indication of which Version is to become the new default Version, the
sticky aspect MUST be disabled and the default Version MUST be the newest
Version. See <a href="#default-version-of-a-resource">Default Version of a Resource</a>
for more information.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>When not specified, the default value MUST be <code>false</code>.</li>
<li>When specified, it MUST be a case-sensitive <code>true</code> or <code>false</code>.</li>
<li>When specified in a request, a value of <code>null</code> MUST be interpreted as a
request to delete the attribute, implicitly setting it to <code>false</code>.</li>
<li>The processing of the <code>defaultversionsticky</code> and <code>defaultversionid</code>
attributes are related, and is described as follows:
<ul>
<li>When <code>PATCH</code> is used but only one of the two attributes is specified
in the request, then:
<ul>
<li>A non-<code>null</code> <code>defaultversionid</code> MUST result in processing as if
<code>defaultversionsticky</code> has a value of <code>true</code>.</li>
<li>A <code>null</code> <code>defaultversionid</code> MUST result in processing as if
<code>defaultversionsticky</code> has a value of <code>false</code>.</li>
<li>A <code>null</code> or <code>false</code> <code>defaultversionsticky</code> MUST result in processing
as if <code>defaultversionid</code> has a value of <code>null</code>.</li>
<li>The processing then continues on the patched <code>meta</code> sub-object as if
<code>PUT</code> or <code>POST</code> was used.</li>
</ul>
</li>
<li>When <code>PUT</code> or <code>POST</code> is used:
<ul>
<li>A <code>null</code> or absent <code>defaultversionid</code> in the request MUST result in the
same semantics as it referencing &quot;the newest Version&quot;.</li>
<li>A <code>null</code> or absent <code>defaultversionsticky</code> in the request MUST result in
the same semantics as it being set to <code>false</code>.</li>
<li>A <code>defaultversionid</code> referencing a non-existing Version MUST generate
an error (<a href="#unknown_id">unknown_id</a>).</li>
<li>If <code>defaultversionsticky</code> is <code>false</code> and <code>defaultversionid</code> does not
reference the newest Version then an error
(<a href="#invalid_data">invalid_data</a>) MUST be generated, as this
would result in an inconsistent state.</li>
<li>For clarity, if the net result of the processing is that the sticky
feature is turned off, then the <code>defaultversionid</code> MUST reference the
newest Version.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>true</code>, <code>false</code></li>
</ul>
</li>
</ul>
<h5 id="meta-attributesub-object"><a class="anchor" href="#meta-attributesub-object">☍</a> <code>meta</code> Attribute/Sub-Object</h5>
<ul>
<li>
<p>Type: Object</p>
</li>
<li>
<p>Description: an object that contains most of the Resource level attributes.</p>
<p>The <code>meta</code> sub-object is an entity in its own right, meaning it supports the
<code>GET</code>, <code>PUT</code> and <code>PATCH</code> APIs as described for all entities within the
xRegistry. It also has its own <code>epoch</code> value which adheres to the normal
<code>epoch</code> processing rules already described, and its value is only updated
when the <code>meta</code> attributes are updated.</p>
<p>When specified, it MUST appear as an attribute of the Resource as a sibling
to the Resource's default Version attributes.</p>
</li>
<li>
<p>API View Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST NOT appear unless requested by the client.</li>
</ul>
</li>
<li>
<p>Document View Constraints:</p>
<ul>
<li>REQUIRED.</li>
</ul>
</li>
</ul>
<p>Note: doing a <code>PUT</code> to a Resource, or a <code>POST</code> to an xRegistry Collection, as
a mechanism to update the <code>meta</code> sub-object MUST include the Resource
default Version attributes in the request. When not specified, the server will
interpret it as a request to delete the default Version attributes. If
possible, an update request to the <code>metaurl</code> directly would be a better
choice, or use <code>PATCH</code> instead and only include the <code>meta</code> sub-object.</p>
<p>During a write operation, the absence of the <code>meta</code> attribute indicates that
no changes are to be made to the <code>meta</code> sub-object.</p>
<h5 id="metaurl-attribute"><a class="anchor" href="#metaurl-attribute">☍</a> <code>metaurl</code> Attribute</h5>
<ul>
<li>
<p>Type: URL</p>
</li>
<li>
<p>Description: a server generated URL to the Resource's <code>meta</code> sub-object.</p>
<p>When specified, it MUST appear as an attribute of the Resource as a sibling
to the Resource's default Version attributes.</p>
</li>
<li>
<p>API View Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be an absolute URL to the Resource's <code>meta</code> sub-object.</li>
<li>MUST be a read-only attribute.</li>
</ul>
</li>
<li>
<p>Document View Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>If the <code>meta</code> sub-object is inlined in the document then this attribute
MUST be a relative URL of the form <code>#JSON-POINTER</code> where the <code>JSON-POINTER</code>
locates the <code>meta</code> sub-object within the current document. See
<a href="#doc-flag">Doc Flag</a> for more information.</li>
<li>If the <code>meta</code> sub-object is not inlined in the document then this attribute
MUST be an absolute URL per the API view constraints listed above.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>https://example.com/endpoints/ep1/messages/msg1/meta</code></li>
</ul>
</li>
</ul>
<h5 id="versions-collection"><a class="anchor" href="#versions-collection">☍</a> <code>versions</code> Collection</h5>
<ul>
<li>
<p>Type: <a href="#registry-collections">Registry Collection</a></p>
</li>
<li>
<p>Description: A map of Versions of the Resource.</p>
<p>Note that Resources MUST have at least one Version.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
</ul>
</li>
</ul>
<h4 id="serializing-resources"><a class="anchor" href="#serializing-resources">☍</a> Serializing Resources</h4>
<p>Serializing Resources requires some special processing due to Resources not
representing just a single set of data. In particular, the following
aspects need to be taken into account:</p>
<ul>
<li>Operations directed to the URL of a Resource are actually acting upon the
&quot;default&quot; Version of that Resource.</li>
<li>Management of the Resource's xRegistry metadata needs to be separate from the
management of any particular Version of the Resource, as well as any
potential domain-specific document associated with the Resource/Version.</li>
<li>The actions, and learning, necessary for end-users to access the most likely
&quot;data of interest&quot; needs to be minimal.</li>
</ul>
<p>To address these aspects, the serialization of a Resource will vary based
on whether it is defined to have a domain-specific document and whether the
client wishes to focus on managing its xRegistry metadata or that secondary
document.</p>
<p>As discussed above, there are two ways to serialize a Resource in an HTTP
message's body:</p>
<ul>
<li>As its underlying domain-specific document.</li>
<li>As its xRegistry metadata.</li>
</ul>
<p>Which variant is used is controlled by the use of <code>$details</code> on the URL path.
The following sections go into more details about these two serialization
options.</p>
<h5 id="serializing-resource-documents"><a class="anchor" href="#serializing-resource-documents">☍</a> Serializing Resource Documents</h5>
<p>When a Resource is serialized as its underlying domain-specific document,
in other words <code>$details</code> is not appended to its URL path, the HTTP body of
requests and responses MUST be the exact bytes of the document. If the
document is empty, or there is no document, then the HTTP body MUST be empty
(zero length).</p>
<p>In this serialization mode, it might be useful for clients to have access to
Resource's xRegistry metadata. To support this, some of the Resource's
xRegistry metadata will appear as HTTP headers in response messages.</p>
<p>On responses, unless otherwise stated, all top-level scalar attributes of the
Resource SHOULD appear as HTTP headers where the header name is the name of the
attribute prefixed with <code>xRegistry-</code>. Note, the optionality of this requirement
is not to allow for servers to decide whether or not to do so, rather it is to
allow for <a href="#no-code-servers">No-Code Servers</a> servers than might not be able
to control the HTTP response headers.</p>
<p>Certain attributes do not follow this rule if a standard HTTP header name is
to be used instead (e.g. <code>contenttype</code> MUST use <code>Content-Type</code>, not
<code>xRegistry-contenttype</code>). Each attribute that falls into this category will
be identified as part of its definition.</p>
<p>Top-level map attributes whose values are of scalar types MUST also appear as
HTTP headers (each key having its own HTTP header) and in those cases the
HTTP header names will be of the form: <code>xRegistry-ATTRIBUTENAME-KEYNAME</code>. Note
that map keys MAY contain the <code>-</code> character, so any <code>-</code> after the 2nd <code>-</code> is
part of the key name. See
<a href="#http-header-values">HTTP Header Values</a> for additional information and
<a href="#labels-attribute"><code>labels</code></a> for an example of one such attribute.</p>
<p>Complex top-level attributes (e.g. arrays, objects, non-scalar maps) MUST NOT
appear as HTTP headers.</p>
<p>On update requests, similar serialization rules apply. However, rather than
these headers being REQUIRED, the client would only need to include those
top-level attributes that they would like to change. But, including unchanged
attributes MAY be done. Any attributes not included in request messages
MUST be interpreted as a request to leave their values unchanged. Using a
value of <code>null</code> (case-sensitive) indicates a request to delete that attribute.</p>
<p>Any top-level map attributes that appear as HTTP headers MUST be included
in their entirety and any missing keys MUST be interpreted as a request to
delete those keys from the map.</p>
<p>Since only some types of attributes can appear as HTTP headers, <code>$details</code>
MUST be used to manage the others. See the next section for more details.</p>
<p>When a Resource (not a Version) is serialized with the Resource document
in the HTTP body, it MUST adhere to this form:</p>
<pre><code class="language-yaml">Content-Type: STRING ?
xRegistry-RESOURCEid: STRING               # ID of Resource, not default Version
xRegistry-versionid: STRING                # ID of the default Version
xRegistry-self: URL                        # Resource URL, not default Version
xRegistry-xid: URI                         # Relative Resource URI
xRegistry-epoch: UINT                      # Start default Version's attributes
xRegistry-name: STRING ?
xRegistry-isdefault: true
xRegistry-description: STRING ?
xRegistry-documentation: URL ?
xRegistry-labels-KEY: STRING *
xRegistry-createdat: TIME
xRegistry-modifiedat: TIME
xRegistry-ancestor: STRING
xRegistry-RESOURCEurl: URL ?               # End of default Version attributes
xRegistry-metaurl: URL                     # Resource level attributes
xRegistry-versionsurl: URL
xRegistry-versionscount: UINTEGER
Location: URL
Content-Location: URL ?
Content-Disposition: STRING ?

... Resource document ... ?
</code></pre>
<p>Where:</p>
<ul>
<li>The <code>RESOURCEid</code> is the <code>SINGULARid</code> of the Resource, not the default
Version.</li>
<li>The <code>versionid</code> attribute MUST be the ID of the Resource's default Version.</li>
<li>The <code>xid</code> URI references the Resource, not the default Version.</li>
<li>The <code>versionsurl</code> and <code>versionscount</code> Collection attributes are included,
but not the <code>versions</code> collection itself.</li>
<li>The <code>Location</code> header only appears in response to a create operation and
MUST be the same as the <code>self</code> URL.</li>
<li>The <code>Content-Location</code> header MAY appear, and if present, MUST reference
the &quot;default&quot; Version.</li>
<li><code>Content-Disposition</code> SHOULD be present and if so, MUST be the <code>RESOURCEid</code>
value. This allows for HTTP tooling that is not aware of xRegistry to know
the desired filename to use if the HTTP body were to be written to a file.</li>
</ul>
<p>Version serialization will look similar, but the set of xRegistry HTTP headers
will be slightly different (to exclude Resource level attributes). See the
next sections for more information.</p>
<p>Scalar default Version extension attributes MUST also appear as
<code>xRegistry-</code> HTTP headers.</p>
<h5 id="serializing-resource-metadata"><a class="anchor" href="#serializing-resource-metadata">☍</a> Serializing Resource Metadata</h5>
<p>Appending <code>$details</code> to a Resource or Version's URL path modifies the
serialization of the entity such that rather than the HTTP body containing
the entity's domain-specific &quot;document&quot; and the xRegistry metadata being
in HTTP headers, all of them are instead within the HTTP body as one JSON
object. If the entity's &quot;document&quot; is included within the object then it'll
appear under a <code>RESOURCE*</code> attribute (as discussed above).</p>
<p>The advantage of this format is that the HTTP body will contain all of the
xRegistry metadata and not just the scalar values - as is the case when they
appear as HTTP headers. This allows for management of all metadata as well
as any possible domain-specific document at one time.</p>
<p>Note that in the case of a reference to a Resource (not a Version), the
metadata will be from the default Version, plus the extra <code>meta</code> and <code>versions</code>
related attributes.</p>
<p>When serialized as a JSON object, a Resource (not a Version) MUST adhere to
this form:</p>
<pre><code class="language-yaml">{
  &quot;RESOURCEid&quot;: &quot;STRING&quot;,                  # ID of Resource, not default Version
  &quot;versionid&quot;: &quot;STRING&quot;,                   # ID of default Version
  &quot;self&quot;: &quot;URL&quot;,                           # URL of Resource,not default Version
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,                            # Relative URI of Resource
  # These are inherited from the default Version
  &quot;epoch&quot;: UINTEGER,
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;isdefault&quot;: true,
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,
  &quot;ancestor&quot;: &quot;STRING&quot;,
  &quot;contenttype&quot;: &quot;STRING&quot;, ?

  &quot;RESOURCEurl&quot;: &quot;URL&quot;, ?                  # If not local
  &quot;RESOURCE&quot;: ... Resource document ..., ? # If inlined &amp; JSON
  &quot;RESOURCEbase64&quot;: &quot;STRING&quot;, ?            # If inlined &amp; ~JSON

  # Resource level helper attributes
  &quot;metaurl&quot;: &quot;URL&quot;,
  &quot;meta&quot;: {                                # If inlined
    &quot;RESOURCEid&quot;: &quot;STRING&quot;,
    &quot;self&quot;: &quot;URL&quot;,                         # URL to &quot;meta&quot;
    &quot;shortself&quot;: &quot;URL&quot;, ?
    &quot;xid&quot;: &quot;XID&quot;,                          # Relative URI to &quot;meta&quot;
    &quot;xref&quot;: &quot;URL&quot;, ?                       # Ptr to linked Resource
    &quot;epoch&quot;: UINTEGER,                     # Resource's epoch
    &quot;createdat&quot;: &quot;TIMESTAMP&quot;,              # Resource's
    &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,             # Resource's
    &quot;readonly&quot;: BOOLEAN,                   # Default=false
    &quot;compatibility&quot;: &quot;STRING&quot;,             # Default=none
    &quot;compatibilityauthority&quot;: &quot;STRING&quot;, ?  # Default=external
    &quot;deprecated&quot;: { ... },

    &quot;defaultversionid&quot;: &quot;STRING&quot;,
    &quot;defaultversionurl&quot;: &quot;URL&quot;,
    &quot;defaultversionsticky&quot;: BOOLEAN        # Default=false
  }, ?
  &quot;versionsurl&quot;: &quot;URL&quot;,
  &quot;versionscount&quot;: UINTEGER,
  &quot;versions&quot;: { Versions collection } ?    # If inlined
}
</code></pre>
<p>The serialization of a Version will look similar except the <code>meta</code> and
<code>versions</code> related Resource level attributes MUST NOT be present. More on this
in the next sections.</p>
<h4 id="cross-referencing-resources"><a class="anchor" href="#cross-referencing-resources">☍</a> Cross Referencing Resources</h4>
<p>Typically, Resources exist within the scope of a single Group, however there
might be situations where a Resource needs to be related to multiple Groups.
In these cases, there are two options. First, a copy of the Resource could be
made into the second Group. The obvious downside to this is that there's no
relationship between the two Resources and any changes to one would need to
be done in the other - running the risk of them getting out of sync.</p>
<p>The second, and better, option is to create a cross-reference from one
(the &quot;source&quot; Resource) to the other (&quot;target&quot; Resource). This is done
by setting the <code>xref</code> attribute on the source Resource to be the <code>xid</code>
of the target Resource.</p>
<p>The <code>xref</code> attribute is defined in the model as:</p>
<pre><code class="language-yaml">&quot;xref&quot;: {
  &quot;name&quot;: &quot;xref&quot;,
  &quot;type&quot;: &quot;xid&quot;,
  &quot;target&quot;: &quot;/GROUPS/RESOURCES&quot;
}
</code></pre>
<p>where <code>/GROUPS/RESOURCES</code> will be the actual Group and Resource plural names
of this Resource.</p>
<p>Looking at a specific example, a Group/Resource model definition of:</p>
<pre><code class="language-yaml">{
  &quot;groups&quot; : {
    &quot;schemagroups&quot;: {
      &quot;plural&quot;: &quot;schemagroups&quot;,
      &quot;singular&quot;: &quot;schemagroup&quot;,

      &quot;resources&quot;: {
        &quot;plural&quot;: &quot;schemas&quot;,
        &quot;singular&quot;: &quot;schema&quot;,
        &quot;attributes&quot;: {
          &quot;xref&quot;: {
            &quot;name&quot;: &quot;xref&quot;,
            &quot;type&quot;: &quot;xid&quot;,
            &quot;target&quot;: &quot;/schemagroups/schemas&quot;
          }
        }
      }
    }
  }
}
</code></pre>
<p>Means that <code>schemas</code> can be cross-referenced to other <code>/schemagroups/schema</code>
Resource. Notice that <code>target</code> is a <code>xid</code> template to itself.</p>
<p>For example: a <code>schema</code> Resource instance defined as (HTTP body of
<code>PUT /schemagroups/group1/schemas/mySchema$details</code>):</p>
<pre><code class="language-yaml">{
  &quot;schemaid&quot;: &quot;mySchema&quot;,
  &quot;meta&quot;: {
    &quot;xref&quot;: &quot;/schemagroups/group2/schemas/sharedSchema&quot;
  }
}
</code></pre>
<p>means that <code>mySchema</code> references <code>sharedSchema</code>, which exists in <code>group2</code>.
When this source Resource (<code>mySchema</code>) is retrieved, all of the target
Resource's attributes (except its <code>RESOURCEid</code>) will appear as if they were
locally defined.</p>
<p>So, if the target Resource (<code>sharedSchema</code>) is defined as:</p>
<pre><code class="language-yaml">{
  &quot;resourceid&quot;: &quot;sharedSchema&quot;,
  &quot;versionid&quot;: &quot;v1&quot;,
  &quot;self&quot;: &quot;http://example.com/schemagroups/group2/schemas/sharedSchema&quot;,
  &quot;xid&quot;: &quot;/schemagroups/group2/schemas/sharedSchema&quot;,
  &quot;epoch&quot;: 2,
  &quot;isdefault&quot;: true,
  &quot;createdat&quot;: &quot;2024-01-01-T12:00:00&quot;,
  &quot;modifiedat&quot;: &quot;2024-01-01-T12:01:00&quot;,
  &quot;ancestor&quot;: &quot;v1&quot;,

  &quot;metaurl&quot;: &quot;http://example.com/schemagroups/group2/schemas/sharedSchema/meta&quot;,
  &quot;versionscount&quot;: 1,
  &quot;versionsurl&quot;: &quot;http://example.com/schemagroups/group2/schemas/sharedSchema/versions&quot;
}
</code></pre>
<p>then the resulting serialization of the source Resource would be:</p>
<pre><code class="language-yaml">{
  &quot;resourceid&quot;: &quot;mySchema&quot;,
  &quot;versionid&quot;: &quot;v1&quot;,
  &quot;self&quot;: &quot;http://example.com/schemagroups/group1/schemas/mySchema&quot;,
  &quot;xid&quot;: &quot;/schemagroups/group1/schemas/mySchema&quot;,
  &quot;epoch&quot;: 2,
  &quot;isdefault&quot;: true,
  &quot;createdat&quot;: &quot;2024-01-01-T12:00:00&quot;,
  &quot;modifiedat&quot;: &quot;2024-01-01-T12:01:00&quot;,
  &quot;ancestor&quot;: &quot;v1&quot;,

  &quot;metaurl&quot;: &quot;http://example.com/schemagroups/group1/schemas/mySchema/meta&quot;,
  &quot;meta&quot;: {
    &quot;resourceid&quot;: &quot;mySchema&quot;,
    &quot;self&quot;: &quot;http://example.com/schemagroups/group1/schemas/mySchema/meta&quot;,
    &quot;xid&quot;: &quot;/schemagroups/group1/schemas/mySchema/meta&quot;,
    &quot;xref&quot;: &quot;/schemagroups/group2/schemas/sharedSchema&quot;,
    &quot;createdat&quot;: &quot;2024-01-01-T12:00:00&quot;,
    &quot;modifiedat&quot;: &quot;2024-01-01-T12:01:00&quot;,
    &quot;readonly&quot;: false,
    &quot;compatibility&quot;: &quot;none&quot;
  },
  &quot;versionscount&quot;: 1,
  &quot;versionsurl&quot;: &quot;http://example.com/schemagroups/group1/schemas/mySchema/versions&quot;
}
</code></pre>
<p>Note:</p>
<ul>
<li>Any attributes referencing the source MUST use the source's metadata. In
this respect, users of this serialization would never know that this is a
cross-referenced Resource except for the presence of the <code>xref</code> attribute.
For example, its <code>RESOURCEid</code> MUST be the source's <code>id</code> and not the target's.</li>
<li>The <code>xref</code> attribute MUST appear within the <code>meta</code> sub-object so a client
can easily determine that this Resource is a cross-referenced Resource, and
it provides a reference to the targeted Resource.</li>
<li>The <code>xref</code> URL MUST be the <code>xid</code> of the target Resource.</li>
</ul>
<p>From a consumption (read) perspective, aside from the presence of the <code>xref</code>
attribute, the Resource appears to be a normal Resource that exists within
<code>group1</code>. All of the specification-defined features (e.g. <code>?inline</code>,
<code>?filter</code>) MAY be used when retrieving the Resource.</p>
<p>However, from a write perspective it is quite different. In order to update
the target Resource's attributes (or nested entities), a write operation MUST
be done on the appropriate target Resource entity directly. Write
operations on the source MAY be done, however, the changes are limited to
converting it from a &quot;cross-reference&quot; Resource back into a &quot;normal&quot;
Resource.  See the following for more information:</p>
<p>When converting a &quot;normal&quot; Resource into a cross-reference Resource (adding
an <code>xref</code> value), or creating a new Resource that will be a cross-reference
Resource, the following MUST be adhered to:</p>
<ul>
<li>The request MUST include an <code>xref</code> attribute with a value that is
the <code>xid</code> of the target Resource.</li>
<li>The request MAY include the <code>RESOURCEid</code> attribute (of the source
Resource) on the Resource or <code>meta</code> sub-object.</li>
<li>The request MAY include <code>epoch</code> within <code>meta</code> (to do an <code>epoch</code> validation
check) only if the Resource already exists.</li>
<li>The request MUST NOT include any other attributes or nested collections.
This includes default Version attributes within the Resource serialization.</li>
<li>If the Resource already exists, then any Versions associated with the Resource
MUST be deleted.</li>
</ul>
<p>When converting a cross-reference Resource back into a &quot;normal&quot; Resource, the
following MUST be adhered to:</p>
<ul>
<li>The request MUST delete the <code>xref</code> attribute or set it to <code>null</code>.</li>
<li>A default Version of the Resource MUST be created.</li>
<li>Any attributes specified at the Resource level MUST be interpreted as a
request to set the default Version attributes. Absence of any attributes
MUST result in a default Version being created with all attributes set
to their default values. Note that normal Resource update semantics apply.</li>
<li>When not specified in the request, the Resource's <code>createdat</code> value MUST be
reset to the timestamp of when this source Resource was originally created.</li>
<li>When not specified in the request, the Resource's <code>modifiedat</code> value MUST be
set to &quot;now&quot;.</li>
<li>The Resource's <code>epoch</code> value (in <code>meta</code>) MUST be greater than the original
Resource's previously known value (if any) and greater than the target
Resource's <code>epoch</code> value. In pseudocode this is:
<code>epoch = max(original_Epoch, target_Resource_Epoch) + 1</code>.
This will ensure that the Resource's <code>epoch</code> value will never decrease as a
result of this operation. Note that going from a &quot;normal&quot; Resource to a
cross-reference Resource does not have this guarantee. If the target Resource
no longer exists then <code>target_Resource_Epoch</code> MUST be treated as zero.</li>
<li>Aside from the processing rules specified above, the Resource's attributes
that might have existed prior to the Resource being converted from a
&quot;normal&quot; Resource into a cross-reference Resource MUST NOT be resurrected
with their old values.</li>
<li>Any relationship with the target Resource MUST be deleted.</li>
</ul>
<p>If the target Resource itself is a cross-reference Resource, then including
the target Resource's attributes MUST NOT be done when serializing the
source Resource. Recursive, or transitively, following of <code>xref</code> URLs is not
done.</p>
<p>Both the source and target Resources MUST be of the same Resource model type,
simply having similar Resource type definitions is not sufficient. This
implies that use of the <code>ximport</code> feature in the model to reference a
Resource type from another Group type definition MUST be used if the same
Resource type is to exist in different Group types. See
<a href="#reuse-of-resource-definitions"><code>ximport</code></a> for more information.</p>
<p>An <code>xref</code> value that points to a non-existing Resource, either because
it was deleted or never existed, is not an error and is not a condition
that a server is REQUIRED to detect. In these &quot;dangling xref&quot; situations, the
serialization of the source Resource will not include any target Resource
attributes or nested collections. Rather, it will only show the <code>RESOURCEid</code>
and <code>xref</code> attributes.</p>
<hr>
<h4 id="resource-and-version-apis"><a class="anchor" href="#resource-and-version-apis">☍</a> Resource and Version APIs</h4>
<p>For convenience, the Resource and Version create, update and delete APIs can be
summarized as:</p>
<p><em><strong><code>POST /GROUPS/gID</code></strong></em></p>
<ul>
<li>Creates or updates one or more collection of Resource types.</li>
</ul>
<p><strong><code>POST /GROUPS/gID/RESOURCES</code></strong><br>
<strong><code>PATCH /GROUPS/gID/RESOURCES</code></strong></p>
<ul>
<li>Creates or updates one or more Resources.</li>
</ul>
<p><strong><code>PUT   /GROUPS/gID/RESOURCES/rID[$details]</code></strong><br>
<strong><code>PATCH /GROUPS/gID/RESOURCES/rID[$details]</code></strong></p>
<ul>
<li>Creates a new Resource, or update the default Version of a Resource.</li>
</ul>
<p><strong><code>POST /GROUPS/gID/RESOURCES/rID[$details]</code></strong><br>
<strong><code>PATCH /GROUPS/gID/RESOURCES/rID[$details]</code></strong></p>
<ul>
<li>Creates or updates a single Version of a Resource.</li>
</ul>
<p><strong><code>PUT   /GROUPS/gID/RESOURCES/rID/meta</code></strong><br>
<strong><code>PATCH /GROUPS/gID/RESOURCES/rID/meta</code></strong></p>
<ul>
<li>Updates the <code>meta</code> sub-object of a Resource.</li>
</ul>
<p><strong><code>POST /GROUPS/gID/RESOURCES/rID/versions</code></strong><br>
<strong><code>PATCH /GROUPS/gID/RESOURCES/rID/versions</code></strong></p>
<ul>
<li>Creates or updates one or more Versions of a Resource.</li>
</ul>
<p><strong><code>PUT   /GROUPS/gID/RESOURCES/rID/versions/vID[$details]</code></strong><br>
<strong><code>PATCH /GROUPS/gID/RESOURCES/rID/versions/vID[$details]</code></strong></p>
<ul>
<li>Creates or updates a single Version of a Resource.</li>
</ul>
<p>And the delete APIs are summarized as:</p>
<p><strong><code>DELETE /GROUPS/gID/RESOURCES</code></strong></p>
<ul>
<li>Delete a list of Resources, or all if the list is absent.</li>
</ul>
<p><strong><code>DELETE /GROUPS/gID/RESOURCES/rID</code></strong></p>
<ul>
<li>Delete a single Resource.</li>
</ul>
<p><strong><code>DELETE /GROUPS/gID/RESOURCES/rID/versions</code></strong></p>
<ul>
<li>Delete a list of Versions, or all (and the Resource) if the list is absent.</li>
</ul>
<p><strong><code>DELETE /GROUPS/gID/RESOURCES/rID/versions/vID</code></strong></p>
<ul>
<li>Delete a single Version of a Resource, and the Resource if last Version.</li>
</ul>
<p>The following sections go into more detail about each API.</p>
<hr>
<h4 id="retrieving-a-resource-collection"><a class="anchor" href="#retrieving-a-resource-collection">☍</a> Retrieving a Resource Collection</h4>
<p>To retrieve all Resources in a Resource Collection, an HTTP <code>GET</code> MAY be used.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">GET /GROUPS/gID/RESOURCES
</code></pre>
<p>A successful response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Link: &lt;URL&gt;;rel=next;count=UINTEGER ?

{
  &quot;KEY&quot;: {                                    # The Resource ID
    &quot;RESOURCEid&quot;: &quot;STRING&quot;,                   # The Resource ID
    &quot;versionid&quot;: &quot;STRING&quot;,                    # Default Version ID
    &quot;self&quot;: &quot;URL&quot;,                            # URL to the Resource
    &quot;shortself&quot;: &quot;URL&quot;, ?
    &quot;xid&quot;: &quot;XID&quot;,                             # Relative URI to the Resource
    &quot;epoch&quot;: UINTEGER,                        # Start of Default Ver attribs
    &quot;name&quot;: &quot;STRING&quot;, ?
    &quot;isdefault&quot;: true,
    &quot;description&quot;: &quot;STRING&quot;, ?
    &quot;documentation&quot;: &quot;URL&quot;, ?
    &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
    &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
    &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,
    &quot;ancestor&quot;: &quot;STRING&quot;,
    &quot;contenttype&quot;: &quot;STRING&quot;, ?

    &quot;RESOURCEurl&quot;: &quot;URL&quot;, ?                  # If not local
    &quot;RESOURCE&quot;: ... Resource document ..., ? # If inlined &amp; JSON
    &quot;RESOURCEbase64&quot;: &quot;STRING&quot;, ?            # If inlined &amp; ~JSON

    # Resource level helper attributes
    &quot;metaurl&quot;: &quot;URL&quot;,
    &quot;meta&quot;: {                                # If inlined
      &quot;RESOURCEid&quot;: &quot;STRING&quot;,                # Resource ID
      &quot;self&quot;: &quot;URL&quot;,                         # URL to &quot;meta&quot;
      &quot;shortself&quot;: &quot;URL&quot;, ?
      &quot;xid&quot;: &quot;XID&quot;,                          # Relative URI to &quot;meta&quot;
      &quot;xref&quot;: &quot;URL&quot;, ?                       # Ptr to linked Resource
      &quot;epoch&quot;: UINTEGER,                     # Resource's epoch
      &quot;createdat&quot;: &quot;TIMESTAMP&quot;,              # Resource's
      &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,             # Resource's
      &quot;readonly&quot;: BOOLEAN,                   # Default=false
      &quot;compatibility&quot;: &quot;STRING&quot;,             # Default=none
      &quot;compatibilityauthority&quot;: &quot;STRING&quot;, ?  # Default=external
      &quot;deprecated&quot;: { ... }, ?

      &quot;defaultversionid&quot;: &quot;STRING&quot;,
      &quot;defaultversionurl&quot;: &quot;URL&quot;,
      &quot;defaultversionsticky&quot;: BOOLEAN
    }
    &quot;versionsurl&quot;: &quot;URL&quot;,
    &quot;versionscount&quot;: UINTEGER,
    &quot;versions&quot;: { Versions collection } ?    # If inlined
  } *
}
</code></pre>
<p>Where:</p>
<ul>
<li>The key of each item in the map MUST be the <code>RESOURCEid</code> of the respective
Resource.</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Retrieve all <code>messages</code> of an <code>endpoint</code> whose <code>RESOURCEid</code> is <code>ep1</code>:</p>
<pre><code class="language-yaml">GET /endpoints/ep1/messages
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Link: &lt;https://example.com/endpoints/ep1/messages&amp;page=2&gt;;rel=next;count=100

{
  &quot;msg1&quot;: {
    &quot;messageid&quot;: &quot;msg1&quot;,
    &quot;versionid&quot;: &quot;1.0&quot;,
    &quot;self&quot;: &quot;https://example.com/endpoints/ep1/messages/msg1&quot;,
    &quot;xid&quot;: &quot;/endpoints/ep1/messages/msg1&quot;,
    &quot;epoch&quot;: 1,
    &quot;name&quot;: &quot;Blob Created&quot;,
    &quot;isdefault&quot;: true,
    &quot;createdat&quot;: &quot;2024-04-30T12:00:00Z&quot;,
    &quot;modifiedat&quot;: &quot;2024-04-30T12:00:01Z&quot;,
    &quot;ancestor&quot;: &quot;1.0&quot;,

    &quot;metaurl&quot;: &quot;https://example.com/endpoints/ep1/messages/msg1/meta&quot;,
    &quot;versionsurl&quot;: &quot;https://example.com/endpoints/ep1/messages/msg1/versions&quot;,
    &quot;versionscount&quot;: 1
  }
}
</code></pre>
<h4 id="creating-or-updating-resources-and-versions"><a class="anchor" href="#creating-or-updating-resources-and-versions">☍</a> Creating or Updating Resources and Versions</h4>
<p>These APIs follow the overall pattern described in the <a href="#creating-or-updating-entities">Creating or Updating
Entities</a> section. Any variations will be
called out.</p>
<p>Creating and updating of Resources via HTTP MAY be done using the HTTP <code>POST</code>,
<code>PUT</code> or <code>PATCH</code> methods as described below:</p>
<p><code>POST /GROUPS/gID</code></p>
<p>Where:</p>
<ul>
<li>This API MUST create or update one or more Resources, of varying Resource
types, within the specified Group.</li>
<li>The HTTP body MUST contain a map of Resource types, where the value of each
map entry is a map of Resources of that type to be created or updated,
serialized as xRegistry metadata.</li>
</ul>
<p>For example:</p>
<pre><code class="language-yaml">{
  &quot;schemas&quot;: {
    &quot;schema1&quot;: { ... Resource schema1's xRegistry metadata ... },
    &quot;schema2&quot;: { ... Resource schema1's xRegistry metadata ... }
  },
  &quot;messages&quot;: {
    &quot;message1&quot;: { ... Resource message1's xRegistry metadata ... },
    &quot;message2&quot;: { ... Resource message2's xRegistry metadata ... }
  }
}
</code></pre>
<p>Notice the format is almost the same as what a <code>PUT /GROUPS/gID</code> would look
like if the request wanted to update the Group's attributes and define a set
of Resources, but without the Group's attributes. This allows for an update of
the specified Resources without modifying the Group's attributes.</p>
<p>The response in this case MUST be a map of the Resource types with just the
Resources that were processed as part of the request.</p>
<p><code>POST  /GROUPS/gID/RESOURCES</code><br>
<code>PATCH /GROUPS/gID/RESOURCES</code></p>
<p>Where:</p>
<ul>
<li>This API MUST create or update one or more Resources within the specified
Group.</li>
<li>The HTTP body MUST contain a map of Resources to be created or updated,
serialized as xRegistry metadata.</li>
</ul>
<p><code>PUT   /GROUPS/gID/RESOURCES/rID[$details]</code><br>
<code>PATCH /GROUPS/gID/RESOURCES/rID[$details]</code></p>
<p>Where:</p>
<ul>
<li>These APIs MUST create or update a single Resource in the Group.</li>
<li>When <code>$details</code> is present, the HTTP body MUST be an xRegistry
serialization of the Resource.</li>
<li>When <code>$details</code> is absent, the HTTP body MUST contain the Resource's
document (an empty body means the document is to be empty).</li>
</ul>
<p><code>POST  /GROUPS/gID/RESOURCES/rID[$details][?setdefaultversionid=vID]</code><br>
<code>PATCH /GROUPS/gID/RESOURCES/rID[$details][?setdefaultversionid=vID]</code></p>
<p>Where:</p>
<ul>
<li>This API MUST create, or update, a single Version of the specified
Resource.</li>
<li>When the Resource has the <code>hasdocument</code> aspect set to <code>true</code>:
<ul>
<li>If <code>$details</code> is present in the URL, then the HTTP body MUST be an
xRegistry serialization of the Version that is to be created or updated.</li>
<li>If <code>$details</code> is absent in the URL, then the HTTP body MUST contain
the Version's document (an empty body means the document is to be empty).
Note that the xRegistry metadata (e.g. the Version's <code>versionid</code>) MAY be
included as HTTP headers.</li>
</ul>
</li>
<li>When the Resource has the <code>hasdocument</code> aspect set to <code>false</code> then the
HTTP body MUST be an xRegistry serialization of the Version that is to be
created or updated.</li>
</ul>
<p><code>PUT   /GROUPS/gID/RESOURCES/rID/meta</code><br>
<code>PATCH /GROUPS/gID/RESOURCES/rID/meta</code>
Where:</p>
<ul>
<li>This API MUST update the <code>meta</code> sub-object of the specified Resource.</li>
<li>As with all update operations, if the incoming request includes an <code>epoch</code>
value that does not match the existing <code>meta</code> <code>epoch</code> value then an
error (<a href="#mismatched_epoch">mismatched_epoch</a>) MUST be generated.</li>
</ul>
<p><code>POST  /GROUPS/gID/RESOURCES/rID/versions[?setdefaultversionid=vID]</code><br>
<code>PATCH /GROUPS/gID/RESOURCES/rID/versions[?setdefaultversionid=vID]</code></p>
<p>Where:</p>
<ul>
<li>This API MUST create or update one or more Versions of the Resource.</li>
<li>The HTTP body MUST contain a map of Versions to be created or updated,
serialized as xRegistry metadata. Note that the map key of each entry
MUST be the Version's <code>versionid</code> not the Resource's.</li>
<li>If the Resource does not exist prior to this operation, it MUST be implicitly
created, the following rules apply:
<ul>
<li>If there is only one Version created, then it MUST become the default
Version, and use of the <code>?setdefaultversionid</code> query parameter is OPTIONAL.</li>
<li>If there is more than one Version created, then use of the
<code>?setdefaultversionid</code> query parameter is RECOMMENDED.</li>
<li>There MUST be at least one Version specified in the HTTP body. In other
words, an empty collection MUST generate an error
(<a href="#missing_versions">missing_versions</a>) since creating a Resource
with no Versions would immediately delete that Resource.</li>
</ul>
</li>
</ul>
<p>See <a href="#default-version-of-a-resource">Default Version of a Resource</a> for more
information about the <code>?setdefaultversionid</code> query parameter.</p>
<p><code>PUT   /GROUPS/gID/RESOURCES/rID/versions/vID[$details][?setdefaultversionid=vID]</code><br>
<code>PATCH /GROUPS/gID/RESOURCES/rID/versions/vID[$details][?setdefaultversionid=vID]</code></p>
<p>Where:</p>
<ul>
<li>This API MUST create or update a single Version in the Resource.</li>
<li>When the Resource has the <code>hasdocument</code> aspect set to <code>true</code>:
<ul>
<li>If <code>$details</code> is present in the URL, then the HTTP body MUST be an
xRegistry serialization of the Version that is to be created or updated.</li>
<li>If <code>$details</code> is absent in the URL, then the HTTP body MUST contain
the Version's document (an empty body means the document is to be empty).
Note that the xRegistry metadata (e.g. the Version's <code>versionid</code>) MAY be
included as HTTP headers.</li>
</ul>
</li>
<li>When the Resource has the <code>hasdocument</code> aspect set to <code>false</code> then the
HTTP body MUST be an xRegistry serialization of the Version that is to be
created or updated.</li>
</ul>
<p>See <a href="#default-version-of-a-resource">Default Version of a Resource</a> for more
information about the <code>?setdefaultversionid</code> query parameter.</p>
<hr>
<p>To reduce the number of interactions needed, these APIs are designed to allow
for the implicit creation of all parent entities specified in the PATH. And
each entity not already present with the specified <code>SINGULARid</code> MUST be
created with that value. Note: if any of those entities have REQUIRED
attributes, then they cannot be implicitly created, and would need to be
created directly.</p>
<p>When specified as an xRegistry JSON object, each individual Resource or Version
in the request MUST adhere to the following:</p>
<pre><code class="language-yaml">{
  &quot;RESOURCEid&quot;: &quot;STRING&quot;, ?
  &quot;versionid&quot;: &quot;STRING&quot;, ?
  &quot;epoch&quot;: UINTEGER,
  &quot;name&quot;: &quot;STRING&quot;, ?                      # Version-level attributes
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;, ?
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;, ?
  &quot;ancestor&quot;: &quot;STRING&quot;,
  &quot;contenttype&quot;: &quot;STRING&quot;, ?

  &quot;RESOURCEurl&quot;: &quot;URL&quot;, ?                  # If not local
  &quot;RESOURCE&quot;: ... Resource document ..., ? # If inlined &amp; JSON
  &quot;RESOURCEbase64&quot;: &quot;STRING&quot;, ?            # If inlined &amp; ~JSON

  &quot;meta&quot;: {                                # Resource-only attributes
    &quot;RESOURCEid&quot;: &quot;STRING&quot;, ?
    &quot;xref&quot;: &quot;URL&quot;, ?
    &quot;epoch&quot;: UINTEGER, ?
    &quot;createdat&quot;: &quot;TIMESTAMP&quot;, ?
    &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;, ?
    &quot;compatibility&quot;: &quot;STRING&quot;, ?
    &quot;compatibilityauthority&quot;: &quot;STRING&quot;, ?
    &quot;deprecated&quot;: { ... }, ?

    &quot;defaultversionid&quot;: &quot;STRING&quot;,
    &quot;defaultversionsticky&quot;: BOOLEAN
  }, ?
  &quot;versions&quot;: { Versions collection } ?
}
</code></pre>
<p>When the HTTP body contains the Resource's (or Version's) document, then any
xRegistry scalar metadata MUST appear as HTTP headers and the request MUST
adhere to the following:</p>
<pre><code class="language-yaml">[METHOD] [PATH]
Content-Type: STRING ?
xRegistry-RESOURCEid: STRING ?
xRegistry-versionid: STRING ?
xRegistry-epoch: UINTEGER ?
xRegistry-name: STRING ?
xRegistry-description: STRING ?
xRegistry-documentation: URL ?
xRegistry-labels-KEY: STRING *
xRegistry-createdat: TIMESTAMP ?
xRegistry-modifiedat: TIMESTAMP ?
xRegistry-ancestor: STRING ?
xRegistry-RESOURCEurl: URL ?

... entity document ... ?
</code></pre>
<p>Where:</p>
<ul>
<li>
<p>In the cases where xRegistry metadata appears as HTTP headers, if the
<code>RESOURCEurl</code> attribute is present with a non-null value, the HTTP body
MUST be empty. If the <code>RESOURCEurl</code> attribute is absent, then the contents
of the HTTP body (even if empty) are to be used as the entity's document.</p>
</li>
<li>
<p>If the Resource's <code>hasdocument</code> model attribute has a value of <code>false</code> then
the following rules apply:</p>
<ul>
<li>Only the first form (serialization as a JSON Object) MUST be used.</li>
<li>Use of the <code>$details</code> suffix on the request URL is OPTIONAL, and if used
the Resource/Version <code>self</code> URL MUST NOT include <code>$details</code>.</li>
<li>Any request that includes the xRegistry HTTP headers MUST generate an
error (<a href="#extra_xregistry_headers">extra_xregistry_headers</a>).</li>
<li>An update request with an empty HTTP body MUST be interpreted as a request
to delete all xRegistry mutable attributes - in essence, resetting the
entity back to its default state.</li>
</ul>
</li>
<li>
<p>If the <code>versionid</code> attribute is present, but it does not match the existing
&quot;default&quot; Version's <code>versionid</code> (after any necessary processing of the
<code>defaultversionid</code> attribute), then an error
(<a href="#mismatched_id">mismatched_id</a>) MUST be generated. Also see
<a href="#default-version-of-a-resource">Default Version of a Resource</a>.</p>
<p>If the <code>versionid</code> attribute is present while creating a new Resource, but
a <code>versions</code> collection is not included, rather than the server generating
the <code>versionid</code> of the newly created &quot;default&quot; Version, the server MUST use
the passed-in <code>versionid</code> attribute value. This is done as a convenience
for clients to avoid them having to include a <code>versions</code> collection just
to set the initial default Version's <code>SINGULARid</code>. In other words, when
the <code>versions</code> collection is absent on a create, but <code>versionid</code> is
present, there is an implied <code>&quot;versions&quot;: { &quot;vID&quot;: {} }</code> (where <code>vID</code>
is the <code>versionid</code> value).</p>
</li>
<li>
<p>When the xRegistry metadata is serialized as a JSON object, the processing
of the 3 <code>RESOURCE</code> attributes MUST follow these rules:</p>
<ul>
<li>At most, only one of the 3 attributes MAY be present in the request, and the
presence of any one of them MUST delete the other 2 attributes.</li>
<li>If the entity already exists and has a document (not a <code>RESOURCEurl</code>),
then absence of all 3 attributes MUST leave all 3 unchanged.</li>
<li>An explicit value of <code>null</code> for any of the 3 attributes MUST delete all
3 attributes (and any associated data).</li>
<li>When <code>RESOURCE</code> is present, the server MAY choose to modify non-semantic
significant characters. For example, to remove (or add) whitespace. In
other words, there is no requirement for the server to persist the
document in the exact byte-for-byte format in which it was provided. If
that is desired then <code>RESOURCEbase64</code> MUST be used instead.</li>
<li>On a <code>PUT</code> or <code>POST</code>, when <code>RESOURCE</code> is present, if no <code>contenttype</code>
value is provided then the server MUST set it to same type as the incoming
request, e.g. <code>application/json</code>, even if the entity previous had a
<code>contenttype</code> value.</li>
<li>On a <code>PATCH</code>, when <code>RESOURCE</code> or <code>RESOURCEbase64</code> is present, if no
<code>contenttype</code> value is provided then the server MUST set it to the same
type as the incoming request, e.g. <code>application/json</code>, only if the entity
does not already have a value. Otherwise, the existing value remains
unchanged.</li>
</ul>
</li>
</ul>
<p>A successful response MUST include the current representation of the entities
created or updated and be in the same format (<code>$details</code> variant or not) as
the request.</p>
<p>If the request used the <code>PUT</code> or <code>PATCH</code> variants directed at a single entity,
and a new Version was created, then a successful response MUST include a
<code>Content-Location</code> HTTP header to the newly created Version entity, and if
present, it MUST be the same as the Version's <code>self</code> attribute.</p>
<p>Note that the response MUST NOT include any inlinable attributes (such as
<code>RESOURCE</code>, <code>RESOURCEbase64</code> or nested objects/collections).</p>
<p><strong>Examples:</strong></p>
<p>Create a new Resource:</p>
<pre><code class="language-yaml">PUT /endpoints/ep1/messages/msg1
Content-Type: application/json; charset=utf-8
xRegistry-name: Blob Created

{
  # Definition of a &quot;Blob Created&quot; event (document) excluded for brevity
}
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 201 Created
Content-Type: application/json; charset=utf-8
xRegistry-messageid: msg1
xRegistry-versionid: 1.0
xRegistry-self: https://example.com/endpoints/ep1/messages/msg1
xRegistry-xid: /endpoints/ep1/messages/msg1
xRegistry-epoch: 1
xRegistry-name: Blob Created
xRegistry-isdefault: true
xRegistry-metaurl: https://example.com/endpoints/ep1/messages/msg1/meta
xRegistry-versionsurl: https://example.com/endpoints/ep1/messages/msg1/versions
xRegistry-versionscount: 1
Location: https://example.com/endpoints/ep1/messages/msg1
Content-Location: https://example.com/endpoints/ep1/messages/msg1/versions/1.0
Content-Disposition: msg1

{
  # Definition of a &quot;Blob Created&quot; event (document) excluded for brevity
}
</code></pre>
<p>Updates the default Version of a Resource as xRegistry metadata:</p>
<pre><code class="language-yaml">PUT /endpoints/ep1/messages/msg1$details
Content-Type: application/json; charset=utf-8

{
  &quot;epoch&quot;: 1,
  &quot;name&quot;: &quot;Blob Created&quot;,
  &quot;description&quot;: &quot;a cool event&quot;,

  &quot;message&quot;: {
    # Updated definition of a &quot;Blob Created&quot; event excluded for brevity
  }
}
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Location: https://example.com/endpoints/ep1/messages/msg1/versions/1.0

{
  &quot;messageid&quot;: &quot;msg1&quot;,
  &quot;versionid&quot;: &quot;1.0&quot;,
  &quot;self&quot;: &quot;https://example.com/endpoints/ep1/messages/msg1&quot;,
  &quot;xid&quot;: &quot;/endpoints/ep1/messages/msg1&quot;,
  &quot;epoch&quot;: 2,
  &quot;name&quot;: &quot;Blob Created&quot;,
  &quot;isdefault&quot;: true,
  &quot;description&quot;: &quot;a cool event&quot;,
  &quot;createdat&quot;: &quot;2024-04-30T12:00:00Z&quot;,
  &quot;modifiedat&quot;: &quot;2024-04-30T12:00:01Z&quot;,
  &quot;ancestor&quot;: &quot;1.0&quot;,

  &quot;message&quot;: {
    # Updated definition of a &quot;Blob Created&quot; event excluded for brevity
  },

  &quot;metaurl&quot;: &quot;https://example.com/endpoints/ep1/messages/msg1/meta&quot;,
  &quot;versionsurl&quot;: &quot;https://example.com/endpoints/ep1/messages/msg1/versions&quot;,
  &quot;versionscount&quot;: 1
}
</code></pre>
<p>Update several Versions (adding a label):</p>
<pre><code class="language-yaml">PATCH /endpoints/ep1/messages/msg1/versions
Content-Type: application/json; charset=utf-8

{
  &quot;1.0&quot;: {
    &quot;labels&quot;: { &quot;customer&quot;: &quot;abc&quot; },
  },
  &quot;2.0&quot;: {
    &quot;labels&quot;: { &quot;customer&quot;: &quot;abc&quot; },
  },
  &quot;3.0&quot;: {
    &quot;labels&quot;: { &quot;customer&quot;: &quot;abc&quot; },
  }
}
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;1.0&quot;: {
    &quot;messageid&quot;: &quot;msg1&quot;,
    &quot;versionid&quot;: &quot;1.0&quot;,
    &quot;labels&quot;: { &quot;customer&quot;: &quot;abc&quot; },
    # Remainder of xRegistry metadata excluded for brevity
  },
  &quot;2.0&quot;: {
    &quot;messageid&quot;: &quot;msg1&quot;,
    &quot;versionid&quot;: &quot;2.0&quot;,
    &quot;labels&quot;: { &quot;customer&quot;: &quot;abc&quot; },
    # Remainder of xRegistry metadata excluded for brevity
  },
  &quot;3.0&quot;: {
    &quot;messageid&quot;: &quot;msg1&quot;,
    &quot;versionid&quot;: &quot;3.0&quot;,
    &quot;labels&quot;: { &quot;customer&quot;: &quot;abc&quot; },
    # Remainder of xRegistry metadata excluded for brevity
  }
]
</code></pre>
<p>Note that in this case, the new &quot;label&quot; replaces all existing labels, it is
not a &quot;merge&quot; operation because all attributes need to be specified in their
entirety.</p>
<h4 id="retrieving-a-resource"><a class="anchor" href="#retrieving-a-resource">☍</a> Retrieving a Resource</h4>
<p>To retrieve a Resource, an HTTP <code>GET</code> MAY be used.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">GET /GROUPS/gID/RESOURCES/rID
</code></pre>
<p>This MUST retrieve the default Version of a Resource. Note that <code>rID</code> will be
the <code>SINGULARid</code> of the Resource and not the <code>versionid</code> of the underlying
Version (see <a href="#resources">Resources</a>).</p>
<p>A successful response MUST either be:</p>
<ul>
<li><code>200 OK</code> with the Resource document in the HTTP body.</li>
<li><code>303 See Other</code> with the location of the Resource's document being
returned in the HTTP <code>Location</code> header if the Resource has a <code>RESOURCEurl</code>
value, and the HTTP body MUST be empty.</li>
</ul>
<p>In both cases the Resource's default Version attributes, along with the
<code>meta</code> and <code>versions</code> related scalar attributes, MUST be serialized as HTTP
<code>xRegistry-</code> headers when the Resource's <code>hasdocument</code> model attribute has a
value of <code>true</code>.</p>
<p>Note that if the Resource's <code>hasdocument</code> model attribute has a value of
<code>false</code> then the &quot;Resource document&quot; will be the xRegistry metadata for the
default Version - same as in the <a href="#retrieving-a-resource-as-metadata">Retrieving a Resource as
Metadata</a> section but without the explicit
usage of <code>$details</code>.</p>
<p>When <code>hasdocument</code> is <code>true</code>, the response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK|303 See Other
Content-Type: STRING ?
xRegistry-RESOURCEid: STRING
xRegistry-versionid: STRING
xRegistry-self: URL
xRegistry-xid: URI
xRegistry-epoch: UINT
xRegistry-name: STRING ?
xRegistry-description: STRING ?
xRegistry-documentation: URL ?
xRegistry-labels-KEY: STRING *
xRegistry-createdat: TIME
xRegistry-modifiedat: TIME
xRegistry-ancestor: STRING
xRegistry-RESOURCEurl: URL ?    # If Resource is not in body
xRegistry-metaurl: URL
xRegistry-versionsurl: URL
xRegistry-versionscount: UINTEGER
Location: URL ?                 # If Resource is not in body
Content-Location: URL ?
Content-Disposition: STRING

... Resource document ...       # If RESOURCEurl is not set
</code></pre>
<p>Where:</p>
<ul>
<li><code>RESOURCEid</code> MUST be the <code>SINGULARid</code> of the Resource, not of the default
Version of the Resource.</li>
<li><code>self</code> MUST be a URL to the Resource, not to the default Version of the
Resource.</li>
<li><code>shortself</code>, if present, MUST be an alternative URL for <code>self</code>.</li>
<li><code>xid</code> MUST be a relative URI to the Resource, not to the default Version of
the Resource.</li>
<li>If <code>RESOURCEurl</code> is present then it MUST have the same value as <code>Location</code>.</li>
<li>If <code>Content-Location</code> is present then it MUST be a URL to the Version of the
Resource in the <code>versions</code> collection - same as <code>defaultversionurl</code>.</li>
<li><code>Content-Disposition</code> SHOULD be present and if so, MUST be the <code>RESOURCEid</code>
value. This allows for HTTP tooling that is not aware of xRegistry to know
the desired filename to use if the HTTP body were to be written to a file.</li>
</ul>
<h4 id="retrieving-a-resource-as-metadata"><a class="anchor" href="#retrieving-a-resource-as-metadata">☍</a> Retrieving a Resource as Metadata</h4>
<p>When a Resource has the <code>hasdocument</code> model attribute set to <code>true</code>, to
retrieve a Resource's metadata (Resource attributes) as a JSON object, an
HTTP <code>GET</code> with <code>$details</code> appended to its URL path MAY be used.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">GET /GROUPS/gID/RESOURCES/rID[$details]
</code></pre>
<p>A successful response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Location: URL ?

{
  &quot;RESOURCEid&quot;: &quot;STRING&quot;,
  &quot;versionid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,                           # URL to Resource, not default Ver
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,                            # Relative URI to Resource
  &quot;epoch&quot;: UINTEGER,                       # Start of Default Ver attribs
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,
  &quot;ancestor&quot;: &quot;STRING&quot;,
  &quot;contenttype&quot;: &quot;STRING&quot;, ?

  &quot;RESOURCEurl&quot;: &quot;URL&quot;, ?                  # If not local
  &quot;RESOURCE&quot;: ... Resource document ..., ? # If inlined &amp; JSON
  &quot;RESOURCEbase64&quot;: &quot;STRING&quot;, ?            # If inlined &amp; ~JSON

  &quot;metaurl&quot;: &quot;URL&quot;,
  &quot;meta&quot;: {
    &quot;RESOURCEid&quot;: &quot;STRING&quot;, ?
    &quot;self&quot;: &quot;URL&quot;,                         # URL to &quot;meta&quot; sub-object
    &quot;shortself&quot;: &quot;URL&quot;, ?
    &quot;xid&quot;: &quot;XID&quot;,                          # Relative URI to &quot;meta&quot; sub-object
    &quot;xref&quot;: &quot;URL&quot;, ?
    &quot;epoch&quot;: UINTEGER,
    &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
    &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,
    &quot;readonly&quot;: BOOLEAN,
    &quot;compatibility&quot;: &quot;STRING&quot;,
    &quot;compatibilityauthority&quot;: &quot;STRING&quot;, ?
    &quot;deprecated&quot;: { ... }, ?

    &quot;defaultversionid&quot;: &quot;STRING&quot;,
    &quot;defaultversionurl&quot;: &quot;URL&quot;,
    &quot;defaultversionsticky&quot;: BOOLEAN
  },
  &quot;versionsurl&quot;: &quot;URL&quot;,
  &quot;versionscount&quot;: UINTEGER,
  &quot;versions&quot;: { Versions collection } ?    # If inlined
}
</code></pre>
<p>Where:</p>
<ul>
<li>The use of the <code>$details</code> suffix is REQUIRED when the Resource's
<code>hasdocument</code> aspect is <code>true</code>.</li>
<li><code>RESOURCEid</code> MUST be the Resource's <code>SINGULARid</code>, not the <code>versionid</code> of
the default Version.</li>
<li><code>self</code> is a URL to the Resource (with <code>$details</code> suffix if <code>hasdocument</code>
is <code>true</code>), not to the default Version of the Resource.</li>
<li><code>shortself</code>, if present, MUST be an alternative URL for <code>self</code>.</li>
<li><code>xid</code> is a relative URI to the Resource (without <code>$details</code>), not to the
default Version of the Resource.</li>
<li><code>RESOURCE</code>, or <code>RESOURCEbase64</code>, MUST only be included if requested via use
of the <code>?inline</code> feature and <code>RESOURCEurl</code> is not set.</li>
<li>If <code>Content-Location</code> is present then it MUST be a URL to the Version of the
Resource in the <code>versions</code> collection - same as <code>defaultversionurl</code>.</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Retrieve a <code>message</code> Resource as xRegistry metadata:</p>
<pre><code class="language-yaml">GET /endpoints/ep1/messages/msg1$details
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Location: https://example.com/endpoints/ep1/messages/msg1/versions/1.0

{
  &quot;messageid&quot;: &quot;msg1&quot;,
  &quot;versionid&quot;: &quot;1.0&quot;,
  &quot;self&quot;: &quot;https://example.com/endpoints/ep1/messages/msg1&quot;,&quot;
  &quot;xid&quot;: &quot;/endpoints/ep1/messages/msg1&quot;,
  &quot;epoch&quot;: 1,
  &quot;name&quot;: &quot;Blob Created&quot;,
  &quot;isdefault&quot;: true,
  &quot;createdat&quot;: &quot;2024-04-30T12:00:00Z&quot;,
  &quot;modifiedat&quot;: &quot;2024-04-30T12:00:01Z&quot;,
  &quot;ancestor&quot;: &quot;1.0&quot;,

  &quot;metaurl&quot;: &quot;https://example.com/endpoints/ep1/messages/msg1/meta&quot;,
  &quot;versionsurl&quot;: &quot;https://example.com/endpoints/ep1/messages/msg1/versions&quot;,
  &quot;versionscount&quot;: 1
}
</code></pre>
<h4 id="deleting-resources"><a class="anchor" href="#deleting-resources">☍</a> Deleting Resources</h4>
<p>To delete one or more Resources, and all of their Versions, an HTTP <code>DELETE</code>
MAY be used:</p>
<ul>
<li><code>DELETE /GROUPS/gID/RESOURCES/rID[?epoch=UINTEGER]</code></li>
<li><code>DELETE /GROUPS/gID/RESOURCES</code></li>
</ul>
<p>The processing of these two APIs is defined in the <a href="#deleting-entities-in-a-registry-collection">Deleting Entities in a
Registry Collection</a>
section.</p>
<p>Deleting a Resource MUST delete all Versions within the Resource.</p>
<hr>
<h3 id="versions"><a class="anchor" href="#versions">☍</a> Versions</h3>
<p>Versions represent historical instances of a Resource. When a Resource is
updated, there are two actions that might take place. First, the update can
completely replace an existing Version of the Resource. This is most typically
done when the previous state of the Resource is no longer needed, and there
is no reason to allow people to reference it. The second situation is when
both the old and new Versions of a Resource are meaningful and both might need
to be referenced. In this case, the update will cause a new Version of the
Resource to be created and will have a unique <code>versionid</code> within the scope
of the owning Resource.</p>
<p>For example, updating the data of Resource without creating a new Version
would make sense if there is a typo in the <code>description</code> field. But, adding
additional data to the document of a Resource might require a new Version and
a new <code>versionid</code> (e.g. changing it from &quot;1.0&quot; to &quot;1.1&quot;).</p>
<p>This specification does not mandate a particular versioning algorithm or
Version identification (<code>versionid</code>) scheme.</p>
<p>When serialized as a JSON object, the Version entity adheres to this form:</p>
<pre><code class="language-yaml">{
  &quot;RESOURCEid&quot;: &quot;STRING&quot;,                  # SINGULARid of Resource
  &quot;versionid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,
  &quot;epoch&quot;: UINTEGER,
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;isdefault&quot;: BOOLEAN,
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,
  &quot;ancestor&quot;: &quot;STRING&quot;,
  &quot;contenttype&quot;: &quot;STRING&quot;, ?

  &quot;RESOURCEurl&quot;: &quot;URL&quot;, ?                  # If not local
  &quot;RESOURCE&quot;: ... Resource document ..., ? # If inlined &amp; JSON
  &quot;RESOURCEbase64&quot;: &quot;STRING&quot; ?             # If inlined &amp; ~JSON
}
</code></pre>
<p>Version extension attributes would also appear as additional top-level JSON
attributes.</p>
<p>Versions include the following
<a href="#common-attributes">common attributes</a>:</p>
<ul>
<li><a href="#singularid-id-attribute"><code>RESOURCEid</code></a> - REQUIRED in API and document
views. OPTIONAL in requests.</li>
<li>MUST be the <code>RESOURCEid</code> of the owning Resource.</li>
<li><a href="#versionid-attribute"><code>versionid</code></a> - REQUIRED in API and document views.
OPTIONAL in requests.</li>
<li><a href="#self-attribute"><code>self</code></a> - REQUIRED in API and document views.
OPTIONAL in requests. MUST be a URL to this Version, not the owning Resource.</li>
<li><a href="#shortself-attribute"><code>shortself</code></a> - OPTIONAL in API and document view,
based on the <code>shortself</code> capability. OPTIONAL in requests.</li>
<li><a href="#xid-attribute"><code>xid</code></a> - REQUIRED in API and document views. OPTIONAL
in requests. MUST be the <code>xid</code> of this Version, not the owning Resource.</li>
<li><a href="#epoch-attribute"><code>epoch</code></a> - REQUIRED in API and document views. OPTIONAL
in requests. MUST be the <code>epoch</code> value of this Version, not the owning
Resource.</li>
<li><a href="#name-attribute"><code>name</code></a> - OPTIONAL.</li>
<li><a href="#description-attribute"><code>description</code></a> - OPTIONAL.</li>
<li><a href="#documentation-attribute"><code>documentation</code></a> - OPTIONAL.</li>
<li><a href="#labels-attribute"><code>labels</code></a> - OPTIONAL.</li>
<li><a href="#createdat-attribute"><code>createdat</code></a> - REQUIRED in API and document views.
OPTIONAL in requests.</li>
<li><a href="#modifiedat-attribute"><code>modifiedat</code></a> - REQUIRED in API and document views.
OPTIONAL in requests.</li>
<li><a href="#ancestor-attribute"><code>ancestor</code></a> - REQUIRED in API and document views.
OPTIONAL in requests.</li>
<li><a href="#contenttype-attribute"><code>contenttype</code></a> - OPTIONAL.</li>
</ul>
<p>and the following Version level attributes:</p>
<ul>
<li><a href="#isdefault-attribute"><code>isdefault</code></a> - REQUIRED in API and document views
when <code>true</code>, OPTIONAL when <code>false</code>. OPTIONAL in requests.</li>
<li><a href="#resourceurl-attribute"><code>RESOURCEurl</code></a> - OPTIONAL.</li>
<li><a href="#resource-attribute"><code>RESOURCE</code></a> - OPTIONAL.</li>
<li><a href="#resourcebase64-attribute"><code>RESOURCEbase64</code></a> - OPTIONAL.</li>
</ul>
<p>as defined below:</p>
<h5 id="versionid-attribute"><a class="anchor" href="#versionid-attribute">☍</a> <code>versionid</code> Attribute</h5>
<ul>
<li>
<p>Type: String</p>
</li>
<li>
<p>Description: An immutable unique identifier of the Version.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>See <a href="#singularid-id-attribute">SINGULARid</a>.</li>
<li>MUST NOT use a value of <code>null</code> or <code>request</code> due to these being reserved
for use by the <code>?setdefaultversionid</code> feature.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>1.0</code></li>
<li><code>v2</code></li>
<li><code>v3-rc</code></li>
</ul>
</li>
</ul>
<h5 id="isdefault-attribute"><a class="anchor" href="#isdefault-attribute">☍</a> <code>isdefault</code> Attribute</h5>
<ul>
<li>
<p>Type: Boolean</p>
</li>
<li>
<p>Description: indicates whether this Version is the &quot;default&quot; Version of the
owning Resource. This value is different from other attributes in that it
might often be a calculated value rather than persisted in a datastore.
Thus, when its value changes due to the default Version of a Resource
changing, the Version itself does not change - meaning attributes such as
<code>modifiedat</code> remains unchanged.</p>
<p>See <a href="#creating-or-updating-resources-and-versions">Creating or Updating Resources and
Versions</a> for additional
information about this attribute.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>MUST be a read-only attribute.</li>
<li>When not specified, the default value MUST be <code>false</code>.</li>
<li>When specified, MUST be either <code>true</code> or <code>false</code>, case-sensitive.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>true</code></li>
<li><code>false</code></li>
</ul>
</li>
</ul>
<h5 id="ancestor-attribute"><a class="anchor" href="#ancestor-attribute">☍</a> <code>ancestor</code> Attribute</h5>
<ul>
<li>
<p>Type: String</p>
</li>
<li>
<p>Description: The <code>versionid</code> of this Version's ancestor.</p>
<p>The <code>ancestor</code> attribute MUST be set to the <code>versionid</code> of this Version's
ancestor If this Version is a root of an ancestor hierarchy tree then it
MUST be set to its own <code>versionid</code> value.</p>
<p>When creating a Version without explicitly setting the <code>ancestor</code>
attribute, the server MUST set the <code>ancestor</code> to the most recent Version's
<code>versionid</code> attribute. If no Versions exist, the <code>ancestor</code> attribute MUST
be set to the <code>versionid</code> of the Version being created, making it a root.
If there are existing Versions, the strategy for finding the most recent
Version is as follows:</p>
<ol>
<li>Find all Versions that are not referenced as an <code>ancestor</code> in other
Versions.</li>
<li>If many exist, find the Version with the most recent <code>createdat</code> date.</li>
<li>If many exist, select the first Version sorting all Versions in
descending case-insensitive alphabetical order based on the <code>versionid</code>
attribute.</li>
</ol>
<p>If a write operation contains multiple Versions with the <code>ancestor</code> attribute
omitted, or set to a value of <code>null</code>, the server MUST order all of those
Versions based on the <code>createdat</code> attribute and then alphabetically
(ascending) based on the <code>versionid</code>. The first Version will have the most
recent Version's <code>versionid</code> as its <code>ancestor</code> as clarified above.</p>
<p>When deleting a Version, the server MUST update the <code>ancestor</code> attribute
of any Version that points to the deleted Version to point to itself,
making it a new root.</p>
<p>If a create operation asks the server to choose the <code>versionid</code> when
creating a root Version, the <code>versionid</code> is not yet known and therefore
cannot be assigned the value in the <code>ancestor</code> attribute. In those cases a
value of <code>request</code> MUST be used as a way to reference the Version being
processed in the current request.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED.</li>
<li>The <code>ancestor</code> attribute MUST NOT be set to a value that
creates circular references between Versions and it is STRONGLY RECOMMENDED
that the server generate an error
(<a href="#ancestor_circular_reference">ancestor_circular_reference</a>) if a request
attempts to do so. For example, an operation that makes Version A's
ancestor B, and Version B's ancestor A, would generate an error.</li>
<li>When absent in a write operation request, it MUST be interpreted as the
same as if it were present with its existing value.</li>
<li>Any attempt to set an <code>ancestor</code> attribute to a non-existing <code>versionid</code>
MUST generate an error (<a href="#invalid_data">invalid_data</a>).</li>
<li>For clarity, any modification to the <code>ancestor</code> attribute MUST result in
the owning Version's <code>epoch</code> and <code>modifiedat</code> attributes be updated
appropriately.</li>
</ul>
</li>
</ul>
<h5 id="contenttype-attribute"><a class="anchor" href="#contenttype-attribute">☍</a> <code>contenttype</code> Attribute</h5>
<ul>
<li>
<p>Type: String</p>
</li>
<li>
<p>Description: The media type of the entity as defined by
<a href="https://datatracker.ietf.org/doc/html/rfc9110#media.type">RFC9110</a>.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>OPTIONAL.</li>
<li>SHOULD be compliant with
<a href="https://datatracker.ietf.org/doc/html/rfc9110#media.type">RFC9110</a>.</li>
<li>When serialized as an HTTP header, it MUST be named <code>Content-Type</code> not
<code>xRegistry-contenttype</code> like other xRegistry headers.</li>
<li>On an update request when the xRegistry metadata appears in HTTP headers,
unlike other attributes that will remain unchanged when not specified,
this attribute MUST be erased if the incoming request does not include
the <code>Content-Type</code> HTTP header.</li>
<li>This attribute MAY be specified even for Resources that use the
<code>RESOURCEurl</code> attribute. While this specification cannot guarantee that
this attribute's value will match the <code>Content-Type</code> returned by an
HTTP <code>GET</code> to the <code>RESOURCEurl</code>, it is expected that they will match.</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li><code>application/json</code></li>
</ul>
</li>
</ul>
<h5 id="resourceurl-attribute"><a class="anchor" href="#resourceurl-attribute">☍</a> <code>RESOURCEurl</code> Attribute</h5>
<ul>
<li>
<p>Type: URI</p>
</li>
<li>
<p>Description: if the Resources document is stored outside of the
current Registry, then this attribute MUST contain a URL to the
location where it can be retrieved. If the value of this attribute
is a well-known identifier that is readily understood by registry
users and resolves to a common representation of the Resource, or
an item in some private store/cache, rather than a networked document
location, then it is RECOMMENDED for the value to be a uniform resource
name (<a href="https://datatracker.ietf.org/doc/html/rfc8141">URN</a>).</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>REQUIRED if the Resource's document is not stored inside of the current
Registry.</li>
<li>If the document is stored in a network-accessible endpoint then the
referenced URL MUST support an HTTP(s) <code>GET</code> to retrieve the contents.</li>
<li>MUST NOT be present if the Resource's <code>hasdocument</code> model attribute is
set to <code>false</code>.</li>
</ul>
</li>
</ul>
<h5 id="resource-attribute"><a class="anchor" href="#resource-attribute">☍</a> <code>RESOURCE</code> Attribute</h5>
<ul>
<li>
<p>Type: Resource Document</p>
</li>
<li>
<p>Description: This attribute is a serialization of the corresponding
Resource document's contents. If the document bytes &quot;as is&quot; allow for them to
appear as the value of this JSON attribute, then this attribute MUST be used
if the request asked for the document to be inlined in the response.</p>
</li>
<li>
<p>Constraints</p>
<ul>
<li>MUST NOT be present when the Resource's Registry metadata is being
serialized as HTTP headers.</li>
<li>If the Resource's document is to be serialized and is not empty,
then either <code>RESOURCE</code> or <code>RESOURCEbase64</code> MUST be present.</li>
<li>MUST only be used if the Resource document (bytes) is in the same
format as the Registry Resource entity.</li>
<li>MUST NOT be present if <code>RESOURCEbase64</code> is also present.</li>
<li>MUST NOT be present if the Resource's <code>hasdocument</code> model attribute is
set to `false.</li>
</ul>
</li>
</ul>
<h5 id="resourcebase64-attribute"><a class="anchor" href="#resourcebase64-attribute">☍</a> <code>RESOURCEbase64</code> Attribute</h5>
<ul>
<li>
<p>Type: String</p>
</li>
<li>
<p>Description: This attribute is a base64 serialization of the corresponding
Resource document's contents. If the Resource document (which is stored as
an array of bytes) is not conformant with the format being used to serialize
with the Resource object (i.e. as a JSON value), then this attribute MUST be
used in instead of the <code>RESOURCE</code> attribute.</p>
</li>
<li>
<p>Constraints:</p>
<ul>
<li>MUST NOT be present when the Resource's Registry metadata is being
serialized as HTTP headers.</li>
<li>If the Resource's document is to be serialized and it is not empty,
then either <code>RESOURCE</code> or <code>RESOURCEbase64</code> MUST be present.</li>
<li>MUST be a base64 encoded string of the Resource's document.</li>
<li>MUST NOT be present if <code>RESOURCE</code> is also present.</li>
<li>MUST NOT be present if the Resource's <code>hasdocument</code> model attribute is
set to `false.</li>
</ul>
</li>
</ul>
<h4 id="version-ids"><a class="anchor" href="#version-ids">☍</a> Version IDs</h4>
<p>If a server does not support client-side specification of the <code>versionid</code> of a
new Version (see the <code>setversionid</code> attribute in the <a href="#registry-model">Registry
Model</a>), or if a client chooses to not specify the <code>versionid</code>,
then the server MUST assign new Version an <code>versionid</code> that is unique within
the scope of its owning Resource.</p>
<p>Servers MAY have their own algorithm for the creation of new Version
<code>versionid</code> values, but the default algorithm is as follows:</p>
<ul>
<li><code>versionid</code> MUST be a string serialization of a monotonically increasing
(by <code>1</code>) unsigned integer starting with <code>1</code> and is scoped to the owning
Resource.</li>
<li>Each time a new <code>versionid</code> is needed, if an existing Version already has
that <code>versionid</code> then the server MUST generate the next <code>versionid</code> value
and try again.</li>
<li>The search for the next value does not restart with <code>1</code> each time, it MUST
continue from the highest previously generated value.</li>
</ul>
<p>With this default versioning algorithm, when semantic versioning is needed,
it is RECOMMENDED to include a major version identifier in the Resource
<code>RESOURCEid</code>, like <code>&quot;com.example.event.v1&quot;</code> or <code>&quot;com.example.event.2024-02&quot;</code>,
so that incompatible, but historically related Resources can be more easily
identified by users and developers. The Version's <code>versionid</code> then functions
as the semantic minor version identifier.</p>
<h4 id="default-version-of-a-resource"><a class="anchor" href="#default-version-of-a-resource">☍</a> Default Version of a Resource</h4>
<p>As Versions of a Resource are added or removed, there needs to be a mechanism
by which the &quot;default&quot; one is determined. There are two options for how this
might be done:</p>
<ol>
<li>
<p>Newest = Default. The newest Version created (based on <code>createdat</code> timestamp)
is always the &quot;default&quot; Version. This is the default choice. If more than
one Version has the same &quot;newest&quot; <code>createdat</code> timestamp, then the choice
the Version with the highest alphabetical <code>versionid</code> value using
case-insensitive compares MUST be chosen. For example, if there are 3
Versions with <code>versionid</code> values of <code>v10</code>, <code>z1</code> and <code>V2</code>, then ordering
of the Versions from oldest to newest would be: <code>v10</code>, <code>V2</code>, <code>z1</code>.</p>
</li>
<li>
<p>Client explicitly chooses the &quot;default&quot;. In this option, a client has
explicitly chosen which Version is the &quot;default&quot; and it will not change
until a client chooses another Version, or that Version is deleted (in
which case the server MUST revert back to option 1 (newest = default), if
the client did not use <code>?setdefaultversionid</code> to choose the next &quot;default&quot;
Version - see below). This is referred to as the default Version being
&quot;sticky&quot; as it will not change until explicitly requested by a client.</p>
</li>
</ol>
<p>If supported (as determined by the <code>setdefaultversionsticky</code> model aspect),
a client MAY choose the &quot;default&quot; Version two ways:</p>
<ol>
<li>Via the Resource <code>defaultversionsticky</code> and <code>defaultversionid</code> attributes
in its <code>meta</code> sub-object. See <a href="#resource-attributes">Resource Attributes</a>
for more information about these attributes.</li>
<li>Via the <code>?setdefaultversionid</code> query parameter that is available on certain
APIs, as defined below.</li>
</ol>
<p>The <code>?setdefaultversionid</code> query parameter is defined as:</p>
<pre><code class="language-yaml">...?setdefaultversionid=vID
</code></pre>
<p>Where:</p>
<ul>
<li><code>vID</code> is the <code>versionid</code> of the Version that is to become the &quot;default&quot;
Version of the referenced Resource. A value of <code>null</code> indicates that the
client wishes to switch to the &quot;newest = default&quot; algorithm, in other words,
the &quot;sticky&quot; aspect of the current default Version will be removed. It is
STRONGLY RECOMMENDED that clients provide an explicit value when possible.
However, if a Version create operation asks the server to choose the <code>vID</code>,
then including that value in the query parameter is not possible. In those
cases a value of <code>request</code> MAY be used as a way to reference the Version
being processed in the current request, and if the request creates more than
one Version, then an error (<a href="#too_many_versions">too_many_versions</a>) MUST be
generated.</li>
<li>If a non-<code>null</code> and non-<code>request</code> <code>vID</code> does not reference an existing
Version of the Resource, after all Version processing is completed, then an
error (<a href="#unknown_id">unknown_id</a>) MUST be generated.</li>
</ul>
<p>Any use of this query parameter on a Resource that has the
<code>setdefaultversionsticky</code> aspect set to <code>false</code> MUST generate an error
(<a href="#bad_flag">bad_flag</a>).</p>
<p>Updating a Resource's <code>defaultversionid</code>, regardless of the mechanism used to
do so, MUST adhere to the following rules:</p>
<ul>
<li>Aside from the special values of <code>null</code> and <code>request</code>, its value MUST be
the <code>versionid</code> of a Version for the specified Resource after all Version
processing is completed (i.e. after any Versions are added or removed). Its
value is not limited to the Versions involved in the current operation.</li>
<li>When the operation also involves updating a Resource's &quot;default&quot; Version's
attributes, the update to the default Version pointer MUST be done before
the attributes are updated. In other words, the Version updated is the new
default Version, not the old one.</li>
<li>Choosing a new default Version for a Resource MUST NOT change any attributes
in any Resource's Versions, for example, attributes such as <code>modifiedat</code>
remain unchanged.</li>
</ul>
<h4 id="retrieving-all-versions"><a class="anchor" href="#retrieving-all-versions">☍</a> Retrieving all Versions</h4>
<p>To retrieve all Versions of a Resource, an HTTP <code>GET</code> MAY be used.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">GET /GROUPS/gID/RESOURCES/rID/versions
</code></pre>
<p>A successful response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Link: &lt;URL&gt;;rel=next;count=UINTEGER ?

{
  &quot;KEY&quot;: {                                    # The versionid
    &quot;RESOURCEid&quot;: &quot;STRING&quot;,                   # ID of Resource
    &quot;versionid&quot;: &quot;STRING&quot;,
    &quot;self&quot;: &quot;URL&quot;,
    &quot;shortself&quot;: &quot;URL&quot;, ?
    &quot;xid&quot;: &quot;XID&quot;,
    &quot;epoch&quot;: UINTEGER,
    &quot;name&quot;: &quot;STRING&quot;, ?
    &quot;isdefault&quot;: BOOLEAN,
    &quot;description&quot;: &quot;STRING&quot;, ?
    &quot;documentation&quot;: &quot;URL&quot;, ?
    &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
    &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
    &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,
    &quot;ancestor&quot;: &quot;STRING&quot;,
    &quot;contenttype&quot;: &quot;STRING&quot;, ?

    &quot;RESOURCEurl&quot;: &quot;URL&quot;, ?                  # If not local
    &quot;RESOURCE&quot;: ... Resource document ..., ? # If inlined &amp; JSON
    &quot;RESOURCEbase64&quot;: &quot;STRING&quot; ?             # If inlined &amp; ~JSON
  } *
}
</code></pre>
<p>Where:</p>
<ul>
<li>The key of each item in the map MUST be the <code>versionid</code> of the respective
Version.</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Retrieve all Version of a <code>message</code> Resource:</p>
<pre><code class="language-yaml">GET /endpoints/ep1/messages/msg1/versions
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Link: &lt;https://example.com/endpoints/ep1/messages/msg1/versions&amp;page=2&gt;;rel=next;count=100

{
  &quot;1.0&quot;: {
    &quot;messageid&quot;: &quot;msg1&quot;,
    &quot;versionid&quot;: &quot;1.0&quot;,
    &quot;self&quot;: &quot;https://example.com/endpoints/ep1/messages/msg1&quot;,
    &quot;xid&quot;: &quot;/endpoints/ep1/messages/msg1&quot;,
    &quot;epoch&quot;: 1,
    &quot;name&quot;: &quot;Blob Created&quot;,
    &quot;isdefault&quot;: true,
    &quot;createdat&quot;: &quot;2024-04-30T12:00:00Z&quot;,
    &quot;modifiedat&quot;: &quot;2024-04-30T12:00:01Z&quot;,
    &quot;ancestor&quot;: &quot;1.0&quot;
  }
}
</code></pre>
<h4 id="creating-or-updating-versions"><a class="anchor" href="#creating-or-updating-versions">☍</a> Creating or Updating Versions</h4>
<p>See <a href="#creating-or-updating-resources-and-versions">Creating or Updating Resources and
Versions</a>.</p>
<h4 id="retrieving-a-version"><a class="anchor" href="#retrieving-a-version">☍</a> Retrieving a Version</h4>
<p>To retrieve a particular Version of a Resource, an HTTP <code>GET</code> MAY be used.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">GET /GROUPS/gID/RESOURCES/rID/versions/vID
</code></pre>
<p>A successful response MUST either return the Version or an HTTP redirect to
the <code>RESOURCEurl</code> value if set.</p>
<p>In the case of returning the Version's document, the response MUST be of the
form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: STRING ?
xRegistry-RESOURCEid: STRING
xRegistry-versionid: STRING
xRegistry-self: URL
xRegistry-xid: URI
xRegistry-epoch: UINT
xRegistry-name: STRING ?
xRegistry-isdefault: BOOLEAN ?
xRegistry-description: STRING ?
xRegistry-documentation: URL ?
xRegistry-labels-KEY: STRING *
xRegistry-createdat: TIME
xRegistry-modifiedat: TIME
xRegistry-ancestor: STRING
Content-Disposition: STRING

... Version document ...
</code></pre>
<p>Where:</p>
<ul>
<li><code>RESOURCEid</code> MUST be the <code>SINGULARid</code> of the owning Resource.</li>
<li><code>versionid</code> MUST be the <code>SINGULARid</code> of the Version.</li>
<li><code>self</code> MUST be a URL to the Version, not to the owning Resource.</li>
<li><code>xid</code> MUST be a relative URI to the Version, not to the owning Resource.</li>
<li><code>Content-Disposition</code> SHOULD be present and if so, MUST be the <code>RESOURCEid</code>
value. This allows for HTTP tooling that is not aware of xRegistry to know
the desired filename to use if the HTTP body were to be written to a file.</li>
</ul>
<p>In the case of a redirect, the response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 303 See Other
Content-Type: STRING ?
xRegistry-RESOURCEid: STRING
xRegistry-versionid: STRING
xRegistry-self: URL
xRegistry-xid: URI
xRegistry-epoch: UINT
xRegistry-name: STRING ?
xRegistry-isdefault: BOOLEAN ?
xRegistry-description: STRING ?
xRegistry-documentation: URL ?
xRegistry-labels-KEY: STRING *
xRegistry-createdat: TIME
xRegistry-modifiedat: TIME
xRegistry-ancestor: STRING
xRegistry-RESOURCEurl: URL
Location: URL
Content-Disposition: STRING
</code></pre>
<p>Where:</p>
<ul>
<li><code>Location</code> and <code>RESOURCEurl</code> MUST have the same value.</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Retrieve a specific Version (<code>1.0</code>) of a <code>message</code> Resource:</p>
<pre><code class="language-yaml">GET /endpoints/ep1/messages/msg1/versions/1.0
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
xRegistry-messageid: msg1
xRegistry-versionid: 1.0
xRegistry-self: https://example.com/endpoints/ep1/messages/msg1/versions/1.0
xRegistry-xid: /endpoints/ep1/messages/msg1/versions/1.0
xRegistry-epoch: 2
xRegistry-name: Blob Created
xRegistry-isdefault: true
xRegistry-createdat: TIMESTAMP
xRegistry-modifiedat: TIMESTAMP
xRegistry-ancestor: 1.0
Content-Disposition: msg1

{
  # Definition of a &quot;Blob Created&quot; event excluded for brevity
}
</code></pre>
<h4 id="retrieving-a-version-as-metadata"><a class="anchor" href="#retrieving-a-version-as-metadata">☍</a> Retrieving a Version as Metadata</h4>
<p>To retrieve a particular Version's metadata, an HTTP <code>GET</code> with <code>$details</code>
appended to its <code>RESOURCEid</code> MAY be used. Note that in cases where the
Resource's <code>hasdocument</code> is <code>false</code> then the <code>$details</code> suffix is OPTIONAL.</p>
<p>The request MUST be of the form:</p>
<pre><code class="language-yaml">GET /GROUPS/gID/RESOURCES/rID/versions/vID[$details]
</code></pre>
<p>A successful response MUST be of the form:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;RESOURCEid&quot;: &quot;STRING&quot;,
  &quot;versionid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,
  &quot;epoch&quot;: UINTEGER,
  &quot;name&quot;: &quot;STRING&quot;, ?
  &quot;isdefault&quot;: BOOLEAN,
  &quot;description&quot;: &quot;STRING&quot;, ?
  &quot;documentation&quot;: &quot;URL&quot;, ?
  &quot;labels&quot;: { &quot;STRING&quot;: &quot;STRING&quot; * }, ?
  &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
  &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,
  &quot;ancestor&quot;: &quot;STRING&quot;,
  &quot;contenttype&quot;: &quot;STRING&quot;, ?

  &quot;RESOURCEurl&quot;: &quot;URL&quot;, ?                  # If not local
  &quot;RESOURCE&quot;: ... Resource document ..., ? # If inlined &amp; JSON
  &quot;RESOURCEbase64&quot;: &quot;STRING&quot; ?             # If inlined &amp; ~JSON
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>RESOURCEid</code> MUST be the <code>SINGULARid</code> of the owning Resource.</li>
<li><code>versionid</code> MUST be the <code>SINGULARid</code> of the Version.</li>
<li><code>self</code> MUST be a URL to the Version, not to the owning Resource.</li>
<li><code>xid</code> MUST be a relative URI to the Version, not to the owning Resource.</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Retrieve a specific Version of a <code>message</code> Resource as xRegistry metadata:</p>
<pre><code class="language-yaml">GET /endpoints/ep1/messages/msg1/versions/1.0$details
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  &quot;messageid&quot;: &quot;msg1&quot;,
  &quot;versionid&quot;: &quot;1.0&quot;,
  &quot;self&quot;: &quot;https://example.com/endpoints/ep1/messages/msg1/versions/1.0&quot;,
  &quot;xid&quot;: &quot;/endpoints/ep1/messages/msg1/versions/1.0&quot;,
  &quot;epoch&quot;: 2,
  &quot;name&quot;: &quot;Blob Created&quot;,
  &quot;isdefault&quot;: true,
  &quot;createdat&quot;: &quot;2024-04-30T12:00:00Z&quot;,
  &quot;modifiedat&quot;: &quot;2024-04-30T12:00:01Z&quot;,
  &quot;ancestor&quot;: &quot;1.0&quot;
}
</code></pre>
<h4 id="deleting-versions"><a class="anchor" href="#deleting-versions">☍</a> Deleting Versions</h4>
<p>To delete one or more Versions of a Resource, an HTTP <code>DELETE</code> MAY be used:</p>
<ul>
<li><code>DELETE /GROUPS/gID/RESOURCES/rID/versions/vid[?epoch=UINTEGER&amp;setdefaultversionid=vID]</code></li>
<li><code>DELETE /GROUPS/gID/RESOURCES/rID/versions[?setdefaultversionid=vID]</code></li>
</ul>
<p>The processing of these two APIs is defined in the <a href="#deleting-entities-in-a-registry-collection">Deleting Entities in a
Registry Collection</a>
section. For more information about the <code>?setdefaultversionid</code> query
parameter see the <a href="#default-version-of-a-resource">Default Version of a
Resource</a> section.</p>
<p>If as a result of one of these operations a Resource has no Versions, then the
Resource MUST also be deleted.</p>
<p>A successful response MUST return either:</p>
<pre><code class="language-yaml">HTTP/1.1 204 No Content
</code></pre>
<p>with an empty HTTP body, or:</p>
<pre><code class="language-yaml">HTTP/1.1 200 OK
</code></pre>
<p>If, as an extension, the server chooses to return additional data in the
HTTP body.</p>
<p><strong>Examples:</strong></p>
<p>Delete a single Version of a <code>message</code> Resource:</p>
<pre><code class="language-yaml">DELETE /endpoints/ep1/messages/msg1/versions/1.0
</code></pre>
<pre><code class="language-yaml">HTTP/1.1 204 No Content
</code></pre>
<hr>
<h3 id="configuring-responses"><a class="anchor" href="#configuring-responses">☍</a> Configuring Responses</h3>
<p>Any request MAY include a set of query parameters (flags) to control how the
response is to be generated. The following sections will define the following
flags:</p>
<ul>
<li><a href="#collections-flag"><code>?collections</code></a></li>
<li><a href="#doc-flag"><code>?doc</code></a></li>
<li><a href="#filter-flag"><code>?filter</code></a></li>
<li><a href="#inline-flag"><code>?inline</code></a></li>
</ul>
<p>Implementations of this specification SHOULD support all 3 flags.</p>
<p>Note: If the Registry cannot return all expected data in one response because
it is too large then it MUST generate an error (<a href="#too_large">too_large</a>). In
those cases, the client will need to query the individual inlinable attributes
in isolation so the Registry can leverage
<a href="../pagination/spec.md">pagination</a> of the response.</p>
<h4 id="collections-flag"><a class="anchor" href="#collections-flag">☍</a> Collections Flag</h4>
<p>The <code>?collections</code> query parameter (flag) MAY be used on requests directed
to the Registry itself or to Group instance to indicate that the response
message MUST NOT include any attributes from the top-level entity (Registry
or Group), but instead MUST include only all of the nested Collection maps
that are defined at that level. Specifying it on a request directed to
some other part of the Registry MUST generate an error (<a href="#bad_flag">bad_flag</a>).
Use of this flag MUST implicitly turn on inlining - <code>?inline=*</code>.</p>
<p>Servers MAY choose include, or exclude, the sibling <code>COLLECTIONSurl</code> and
<code>COLLECTIONScount</code> attributes for those top-level collections.</p>
<p>Note that this feature only applies to the root entity of the response and not
to any nested entities/collections.</p>
<p>This feature is meant to be used when the Collections of the Registry, or
Group, are of interest but not the top-level metadata. For example, this could
be used to export one or more Group types from a Registry where the resulting
JSON document is then used to import them into another Registry. If the
Registry-level attributes were present in the output then they would need to
be removed prior to the import, otherwise they would override the target
Registry's values.</p>
<p>The resulting JSON, when using this feature, is designed to be used on a
future <code>POST /</code> operation to either a Registry entity or to a Group instance
as appropriate.</p>
<h4 id="doc-flag"><a class="anchor" href="#doc-flag">☍</a> Doc Flag</h4>
<p>The <code>?doc</code> query parameter (flag) MAY be used to indicate that the response
MUST use &quot;document view&quot; when serializing entities and MUST be modified to do
the following:</p>
<ul>
<li>Remove the default Version attributes from a Resource's serialization.</li>
<li>When a Resource (source) uses the <code>xref</code> feature, the target Resource's
attributes are excluded from the source's serialization.</li>
<li>Convert the following attributes into relative URLs if, and only if, the
entities that they reference are included in the response output:
<code>self</code>, <code>COLLECTIONSurl</code>, <code>metaurl</code>, <code>defaultversionurl</code>.</li>
</ul>
<p>All of the relative URLs mentioned in the last bullet MUST begin with <code>#</code>
and be followed by a
<a href="https://datatracker.ietf.org/doc/html/rfc6901">JSON Pointer</a> reference to the
entity within the response, e.g. <code>#/endpoints/e1</code>. This means that they are
relative to the root of the document (response) generated, and not necessarily
relative to the root of the Registry. Additionally, when those URLs are
relative and reference a Resource or Version, the <code>$details</code> suffix MUST NOT
be present despite the semantics of the suffix being applied (as noted below).</p>
<p>For clarity, if a Registry has a Schema Resource at
<code>/schemagroups/g1/schemas/s1</code>, then this entity's <code>self</code> URL (when serialized
in document view) would change based on the path specified on the <code>GET</code>
request:</p>
<table>
<thead>
<tr>
<th>GET Path</th>
<th><code>self</code> URL</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>http://example.com/myreg</code></td>
<td><code>#/schemagroups/g1/schemas/s1</code></td>
</tr>
<tr>
<td><code>http://example.com/myreg/schemagroups</code></td>
<td><code>#/g1/schemas/s1</code></td>
</tr>
<tr>
<td><code>http://example.com/myreg/schemagroups/g1/ </code></td>
<td><code>#/schemas/s1</code></td>
</tr>
<tr>
<td><code>http://example.com/myreg/schemagroups/g1/schemas </code></td>
<td><code>#/s1</code></td>
</tr>
<tr>
<td><code>http://example.com/myreg/schemagroups/g1/schemas/s1</code></td>
<td><code>#/</code></td>
</tr>
</tbody>
</table>
<p>This feature is useful when a client wants to minimize the amount of data
returned by a server because the duplication of that data (typically used for
human readability purposes) isn't necessary. For example, if tooling would
ignore the duplication, or if the data will be used to populate a new
Registry, then this feature might be used. It also makes the output more of a
&quot;stand-alone&quot; document that minimizes external references.</p>
<p>For clarity, the serialization of a Resource in document view will adhere to
the following:</p>
<pre><code class="language-yaml">{
  &quot;RESOURCEid&quot;: &quot;STRING&quot;,
  &quot;self&quot;: &quot;URL&quot;,
  &quot;shortself&quot;: &quot;URL&quot;, ?
  &quot;xid&quot;: &quot;XID&quot;,

  &quot;metaurl&quot;: &quot;URL&quot;,
  &quot;meta&quot;: {
    &quot;RESOURCEid&quot;: &quot;STRING&quot;,
    &quot;self&quot;: URL&quot;,
    &quot;shortself&quot;: &quot;URL&quot;, ?
    &quot;xid&quot;: &quot;XID&quot;,
    &quot;xref&quot;: &quot;URL&quot; ?
    # The following attributes are absent if 'xref' is set
    &quot;epoch&quot;: UINTEGER&quot;,
    &quot;createdat&quot;: &quot;TIMESTAMP&quot;,
    &quot;modifiedat&quot;: &quot;TIMESTAMP&quot;,
    &quot;ancestor&quot;: &quot;STRING&quot;,
    &quot;readonly&quot;: BOOLEAN,
    &quot;compatibility&quot;: &quot;STRING&quot;,
    &quot;compatibilityauthority&quot;: &quot;STRING&quot;, ?
    &quot;deprecated&quot;: { ... }, ?

    &quot;defaultversionid&quot;: &quot;STRING&quot;,
    &quot;defaultversionurl&quot;: &quot;URL&quot;
    &quot;defaultversionsticky&quot;: BOOLEAN
  }
}
</code></pre>
<p>Note that the attributes <code>epoch</code> through <code>defaultversionsticky</code> MUST be
excluded if <code>xref</code> is set because those would be picked-up from the target
Resource's <code>meta</code> sub-object.</p>
<p>If <code>?doc</code> is used on a request directed to a Resource, or Version,
that has the <code>hasdocument</code> model aspect set to <code>true</code>, then the processing
of the request MUST take place as if the <code>$details</code> suffix was specified
in the URL. Meaning, the response MUST be the xRegistry metadata view of the
Resource and not the Resource's &quot;document&quot;.</p>
<p>If <code>?doc</code> is used on a request directed to a Resource's <code>versions</code>
collection, or to one of its Versions, but the Resource is defined as an
<code>xref</code> to another Resource, then the server MUST generate an error
(<a href="#cannot_doc_xref">cannot_doc_xref</a>) and SHOULD indicate that using <code>?doc</code>
on this part of the hierarchy is not valid - due to it not technically existing
in document view.</p>
<h4 id="filter-flag"><a class="anchor" href="#filter-flag">☍</a> Filter Flag</h4>
<p>The <code>?filter</code> query parameter (flag) on a request indicates that the response
MUST include only those entities that match the specified filter criteria.
This means that any Registry Collection's attributes MUST be modified
to match the resulting subset. In particular:</p>
<ul>
<li>If the collection is inlined, it MUST only include entities that match the
filter expression(s).</li>
<li>The collection <code>url</code> attribute MUST include the appropriate filter
expression(s) in its query parameters such that an HTTP <code>GET</code> to that URL
would return the same subset of entities.</li>
<li>The collection <code>count</code> attribute MUST only count the entities that match the
filter expression(s).</li>
</ul>
<p>The format of the <code>?filter</code> query parameter is:</p>
<pre><code class="language-yaml">filter=EXPRESSION[,EXPRESSION]
</code></pre>
<p>Where:</p>
<ul>
<li>All <code>EXPRESSION</code> values within the scope of one <code>?filter</code> query parameter
MUST be evaluated as a logical <code>AND</code> and any matching entities MUST satisfy
all of the specified expressions within that <code>?filter</code> query parameter.</li>
<li>The <code>?filter</code> query parameter can appear multiple times and if so MUST
be evaluated as a logical <code>OR</code> with the other <code>?filter</code> query parameters that
appear and the response MUST include all entities that match any of the
individual <code>?filter</code> query parameters.</li>
</ul>
<p>The abstract processing logic would be:</p>
<ul>
<li>For each <code>?filter</code> query parameter, find all entities that satisfy all
expressions for that <code>?filter</code>. Each will result in a sub-tree of entities.</li>
<li>After processing all individual <code>?filter</code> query parameters, combine those
sub-trees into one result set and remove any duplicates - adjusting any
collection <code>url</code> and <code>count</code> values as needed.</li>
</ul>
<p>The format of <code>EXPRESSION</code> is one of:</p>
<pre><code class="language-yaml">[PATH.]ATTRIBUTE
[PATH.]ATTRIBUTE=null
[PATH.]ATTRIBUTE=[VALUE]
[PATH.]ATTRIBUTE!=[VALUE]
</code></pre>
<p>Where:</p>
<ul>
<li><code>PATH</code> MUST be a dot (<code>.</code>) notation traversal of the Registry to the entity
of interest, or absent if at the top of the Registry request. Note that
the <code>PATH</code> value is based on the requesting URL and not the root of the
Registry. See the examples below. To reference an attribute with a dot as
part of its name, the JSONPath escaping mechanism MUST be used:
<code>['my.name']</code>. For example, <code>prop1.my.name.prop2</code> would be specified as
<code>prop1['my.name'].prop2</code> if <code>my.name</code> is the name of one attribute.</li>
<li><code>PATH</code> MUST only consist of valid <code>GROUPS</code>, <code>RESOURCES</code> or <code>versions</code>,
otherwise an error (<a href="#invalid_data">invalid_data</a>) MUST be generated.</li>
<li><code>ATTRIBUTE</code> MUST be the attribute in the entity to be examined.</li>
<li>Complex attributes (e.g. <code>labels</code>) MUST use dot (<code>.</code>) to reference nested
attributes. For example: <code>labels.stage=dev</code> for a filter.</li>
<li>A reference to a nonexistent attribute SHOULD NOT generate an error and
SHOULD be treated the same as a non-matching situation. For example,
<code>?filter=myobj.myattr=5</code> would not match if: <code>myobj</code> is missing, <code>myattr</code> is
missing, or <code>myattr</code> is not <code>5</code>.</li>
<li>The operators are processed as follows:
<ul>
<li>No operator:
<ul>
<li>When no operator is specified then the response MUST include
all entities that have the <code>ATTRIBUTE</code> present with any non-<code>null</code> value.</li>
</ul>
</li>
<li><code>=</code> operator:
<ul>
<li>When <code>VALUE</code> is <code>null</code> then only entities without the specified
<code>ATTRIBUTE</code> MUST be included in the response.</li>
<li>When a non-<code>null</code> <code>VALUE</code> is specified then <code>VALUE</code> MUST be the desired
value of the attribute being examined. Only entities whose specified
<code>ATTRIBUTE</code> with this <code>VALUE</code> MUST be included in the response.</li>
<li>When <code>VALUE</code> is absent then the implied <code>VALUE</code> is an empty string and
the matching MUST be done as specified in the previous bullet.</li>
</ul>
</li>
<li><code>!=</code> operator:
<ul>
<li>When <code>VALUE</code> is <code>null</code> then it MUST have the same semantics as
<code>?filter=ATTRIBUTE</code> as specified above (present with any non-<code>null</code>
value).</li>
<li>When <code>VALUE</code> is non-<code>null</code> then only entities without the specified
<code>ATTRIBUTE</code> and <code>VALUE</code> MUST be included in the response. This MUST be
semantically equivalent to <code>NOT(ATTRIBUTE=VALUE)</code>, and this also means
that if <code>ATTRIBUTE</code> is missing then that attribute will match the filter.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>When comparing an <code>ATTRIBUTE</code> to the specified <code>VALUE</code> the following rules
MUST apply for an entity to be considered a match of the filter expression:</p>
<ul>
<li>For boolean attributes, its value MUST be an exact case-sensitive match
(<code>true</code> or <code>false</code>).</li>
<li>For numeric attributes, it MUST be an exact match.</li>
<li>For string attributes, it MUST be an exact match (case-insensitive) when no
wildcard (<code>*</code>) character appears in the <code>VALUE</code>. The presence of a wildcard
indicates that any number of characters can appear at that location in the
<code>VALUE</code>. The wildcard MAY be escaped via the use of a backslash (<code>\\</code>)
character (e.g. <code>abc\*def</code>) to mean that the <code>*</code> is to be interpreted as
a normal character and not as a wildcard. Note that a <code>VALUE</code> of <code>*</code> MUST
be equivalent to checking for the existence of the attribute, with any
value (even an empty string). In other words, the filter will only fail if
the attribute has no value at all.</li>
</ul>
<p>If the request references an entity (not a collection), and the <code>EXPRESSION</code>
references an attribute in that entity (i.e. there is no <code>PATH</code>), then if the
<code>EXPRESSION</code> does not match the entity, that entity MUST NOT be returned. In
other words, a <code>404 Not Found</code> would be generated in the HTTP protocol case.</p>
<p><strong>Examples:</strong></p>
<table>
<thead>
<tr>
<th>Request PATH</th>
<th>Filter query</th>
<th>Commentary</th>
</tr>
</thead>
<tbody>
<tr>
<td>/</td>
<td><code>?filter=endpoints.description=*cool*</code></td>
<td>Only endpoints with the word <code>cool</code> in the description</td>
</tr>
<tr>
<td>/endpoints</td>
<td><code>?filter=description=*CooL*</code></td>
<td>Similar results as previous, with a different request URL</td>
</tr>
<tr>
<td>/</td>
<td><code>?filter=endpoints.messages.versions.versionid=1.0</code></td>
<td>Only versions (and their owning parents) that have a versionid of <code>1.0</code></td>
</tr>
<tr>
<td>/</td>
<td><code>?filter=endpoints.name=myendpoint,endpoints.description=*cool*&amp; filter=schemagroups.labels.stage=dev</code></td>
<td>Only endpoints whose name is <code>myendpoint</code> and whose description contains the word <code>cool</code>, as well as any schemagroups with a <code>label</code> name/value pair of <code>stage/dev</code></td>
</tr>
<tr>
<td>/</td>
<td><code>?filter=description=no-match</code></td>
<td>Returns a 404 if the Registry's <code>description</code> doesn't equal <code>no-match</code></td>
</tr>
<tr>
<td>/</td>
<td><code>?filter=endpoints.messages.meta.readonly=true</code></td>
<td>Only messages that are <code>readonly</code></td>
</tr>
</tbody>
</table>
<p>Specifying a filter does not imply inlining. However, inlining can be used at
the same time but MUST NOT result in additional entities being included in
the results unless they are children of a matching leaf entity.</p>
<p>For example, in the following entity URL paths representing a Registry:</p>
<pre><code class="language-yaml">mygroups/g1/myresources/r1/versions/v1
mygroups/g1/myresources/r1/versions/v2
mygroups/g1/myresources/r2/versions/v1
mygroups/g2/myresources/r3/versions/v1
</code></pre>
<p>This request:</p>
<pre><code class="language-yaml">GET /?filter=mygroups.myresources.myresourceid=r1&amp;inline=*
</code></pre>
<p>would result in the following entities (and their parents along the specified
paths) being returned:</p>
<pre><code class="language-yaml">mygroups/g1/myresources/r1/versions/v1  # versions are due to inlining
mygroups/g1/myresources/r1/versions/v2
</code></pre>
<p>However, this request:</p>
<pre><code class="language-yaml">GET /?filter=mygroups.mygroupid=g2&amp;filter=mygroups.myresources.myresourceid=r1&amp;inline=*
</code></pre>
<p>would result in the following returned:</p>
<pre><code class="language-yaml">mygroups/g1/myresources/r1/versions/v1   # from 2nd ?filter
mygroups/g1/myresources/r1/versions/v2   # from 2nd ?filter
mygroups/g2/myresources/r3/versions/v1   # from 1nd ?filter
</code></pre>
<p>And, this request:</p>
<pre><code class="language-yaml">GET /?filter=mygroups.mygroupid=g1&amp;filter=mygroups.myresources.myresourceid=r1&amp;inline=*
</code></pre>
<p>would result in the following being returned:</p>
<pre><code class="language-yaml">mygroups/g1/myresources/r1/versions/v1   # from 2nd ?filter
mygroups/g1/myresources/r1/versions/v2   # from 2nd ?filter
mygroups/g1/myresources/r2/versions/v1   # from 1st ?filter
</code></pre>
<p>And, finally this request:</p>
<pre><code class="language-yaml">GET /?filter=mygroups.mygroupid=g1,mygroups.myresources.myresourceid=r1&amp;inline=*
</code></pre>
<p>would result in the following being returned:</p>
<pre><code class="language-yaml">mygroups/g1/myresources/r1/versions/v1
mygroups/g1/myresources/r1/versions/v2
</code></pre>
<p>Notice the first part of the <code>?filter</code> expression (to the left of the &quot;and&quot;
(<code>,</code>)) has no impact on the results because the list of resulting leaves in
that subtree is not changed by that search criteria.</p>
<h4 id="inline-flag"><a class="anchor" href="#inline-flag">☍</a> Inline Flag</h4>
<p>The <code>?inline</code> query parameter (flag) MAY be used on requests to indicate whether
nested collections/objects, or certain (potentially large) attributes, are to
be included in the response message.</p>
<p>The <code>?inline</code> query parameter on a request indicates that the response
MUST include the contents of all specified inlinable attributes. Inlinable
attributes include:</p>
<ul>
<li>The <code>model</code> attribute on the Registry entity.</li>
<li>The <code>capabilities</code> attribute on the Registry entity.</li>
<li>All <a href="#registry-collections">Registry Collection</a> types - e.g. <code>GROUPS</code>,
<code>RESOURCES</code> and <code>versions</code>.</li>
<li>The <code>RESOURCE</code> attribute in a Resource or Version.</li>
<li>The <code>meta</code> attribute in a Resource.</li>
</ul>
<p>While the <code>RESOURCE</code> and <code>RESOURCEbase64</code> attributes are defined as two
separate attributes, they are technically two separate &quot;views&quot; of the same
underlying data. As such, the usage of each will be based on the content type
of the Resource, specifying <code>RESOURCE</code> in the <code>?inline</code> query parameter MUST
be interpreted as a request for the appropriate attribute. In other words,
<code>RESOURCEbase64</code> is not a valid inlinable attribute name.</p>
<p>Use of this feature is useful for cases where the contents of the Registry are
to be represented as a single (self-contained) document.</p>
<p>Some examples:</p>
<ul>
<li><code>GET /?inline=model</code>                 # Just 'model'</li>
<li><code>GET /?inline=model,endpoints</code>       # Model and one level under <code>endpoints</code></li>
<li><code>GET /?inline=*</code>                     # Everything except 'model'</li>
<li><code>GET /?inline=model,*</code>               # Everything, including 'model'</li>
<li><code>GET /?inline=endpoints.messages</code>    # One level below 'endpoints.messages'</li>
<li><code>GET /?inline=endpoints.*</code>           # Everything below 'endpoints'</li>
<li><code>GET /endpoints/ep1/?inline=messages.message</code>     # Just 'message'</li>
<li><code>GET /endpoints/ep1/messages/msg1?inline=message</code> # Just 'message'</li>
</ul>
<p>The format of the <code>?inline</code> query parameter is:</p>
<pre><code class="language-yaml">?inline[=PATH[,...]]
</code></pre>
<p>Where <code>PATH</code> is a string indicating which inlinable attributes to show in
the response. References to nested attributes are represented using a
dot (<code>.</code>) notation where the xRegistry collections names along the hierarchy
are concatenated. For example: <code>endpoints.messages.versions</code> will inline all
Versions of Messages. Non-leaf parts of the <code>PATH</code> MUST only reference
xRegistry collection names and not any specific entity IDs since <code>PATH</code> is
meant to be an abstract traversal of the model.</p>
<p>To reference an attribute with a dot as part of its name, the JSONPath
escaping mechanism MUST be used: <code>['my.name']</code>. For example,
<code>prop1.my.name.prop2</code> would be specified as <code>prop1['my.name'].prop2</code> if
<code>my.name</code> is the name of an attribute.</p>
<p>There MAY be multiple <code>PATH</code>s specified, either as comma separated values on
a single <code>?inline</code> query parameter or via multiple <code>?inline</code> query parameters.</p>
<p>The <code>*</code> value MAY be used to indicate that all nested inlinable attributes
at that level in the hierarchy (and below) MUST be inlined - except <code>model</code>
and <code>capabilities</code> at the root of the Registry. These two are excluded since
the data associated with them are configuration related. To include their data
the request MUST include <code>PATH</code> values of <code>model</code> or <code>capabilities</code>. Use of
<code>*</code> MUST only be used as the last part of the <code>PATH</code> (in its entirety). For
example, <code>foo*</code> and <code>*.foo</code> are not valid <code>PATH</code> values, but <code>*</code> and
<code>endpoints.*</code> are.</p>
<p>An <code>?inline</code> query parameter without any value MAY be supported and if so it
MUST have the same semantic meaning as <code>?inline=*</code>.</p>
<p>The specific value of <code>PATH</code> will vary based on where the request is directed.
For example, a request to the root of the Registry MUST start with a <code>GROUPS</code>
name, while a request directed at a Group would start with a <code>RESOURCES</code> name.</p>
<p>For example, given a Registry with a model that has <code>endpoints</code> as a Group and
<code>messages</code> as a Resource within <code>endpoints</code>, the table below shows some
<code>PATH</code> values and a description of the result:</p>
<table>
<thead>
<tr>
<th>HTTP <code>GET</code> Path</th>
<th>Example ?inline=PATH values</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>/</td>
<td>?inline=endpoints</td>
<td>Inlines the <code>endpoints</code> collection, but just one level of it, not any nested inlinable attributes</td>
</tr>
<tr>
<td>/</td>
<td>?inline=endpoints.messages.versions</td>
<td>Inlines the <code>versions</code> collection of all messages. Note that this implicitly means the parent attributes (<code>messages</code> and <code>endpoints</code> would also be inlined - however any other <code>GROUPS</code> or <code>RESOURCE</code>s types would not be</td>
</tr>
<tr>
<td>/endpoints</td>
<td>?inline=messages</td>
<td>Inlines just <code>messages</code> and not any nested attributes. Note we don't need to specify the parent <code>GROUP</code> since the URL already included it</td>
</tr>
<tr>
<td>/endpoints/ep1</td>
<td>?inline=messages.versions</td>
<td>Similar to the previous <code>endpoints.messages.version</code> example</td>
</tr>
<tr>
<td>/endpoints/ep1</td>
<td>?inline=messages.message</td>
<td>Inline the Resource itself</td>
</tr>
<tr>
<td>/endpoints/ep1</td>
<td>?inline=endpoints</td>
<td>Invalid, already in <code>endpoints</code> and there is no <code>RESOURCE</code> called <code>endpoints</code></td>
</tr>
<tr>
<td>/</td>
<td>?inline=endpoints.messages.meta</td>
<td>Inlines the <code>meta</code> attributes/sub-object of each <code>message</code> returned.</td>
</tr>
<tr>
<td>/</td>
<td>?inline=endpoints.*</td>
<td>Inlines everything for all <code>endpoints</code>.</td>
</tr>
</tbody>
</table>
<p>Note that asking for an attribute to be inlined will implicitly cause all of
its parents to be inlined as well, but just the parent's collections needed to
show the child. In other words, just the collection in the parent in which the
child appears, not all collections in the parent.</p>
<p>When specifying a collection to be inlined, it MUST be specified using the
plural name for the collection in its defined case.</p>
<p>A request to inline an unknown, or non-inlinable, attribute MUST generate an
error (<a href="#invalid_data">invalid_data</a>).</p>
<h3 id="http-header-values"><a class="anchor" href="#http-header-values">☍</a> HTTP Header Values</h3>
<p>Some attributes can contain arbitrary UTF-8 string content,
and per <a href="https://tools.ietf.org/html/rfc7230#section-3">RFC7230, section 3</a>, HTTP headers MUST only use
printable characters from the US-ASCII character set, and are terminated by a
CRLF sequence with OPTIONAL whitespace around the header value.</p>
<p>When encoding an attribute's value as an HTTP header, it MUST be
percent-encoded as described below. This is compatible with <a href="https://tools.ietf.org/html/rfc3986#section-2.1">RFC3986, section
2.1</a> but is more specific about what needs
encoding. The resulting string SHOULD NOT be further encoded.
(Rationale: quoted string escaping is unnecessary when every space
and double-quote character is already percent-encoded.)</p>
<p>When decoding an HTTP header into an attribute's value, any HTTP header
value MUST first be unescaped with respect to double-quoted strings,
as described in <a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">RFC7230, section 3.2.6</a>. A single
round of percent-decoding MUST then be performed as described
below. HTTP headers for attribute values do not support
parenthetical comments, so the initial unescaping only needs to handle
double-quoted values, including processing backslash escapes within
double-quoted values. Header values produced via the
percent-encoding described here will never include double-quoted
values, but they MUST be supported when receiving events, for
compatibility with older versions of this specification which did
not require double-quote and space characters to be percent-encoded.</p>
<p>Percent encoding is performed by considering each Unicode character
within the attribute's canonical string representation. Any
character represented in memory as a [Unicode surrogate
pair][surrogate-pair] MUST be treated as a single Unicode character.
The following characters MUST be percent-encoded:</p>
<ul>
<li>Space (U+0020).</li>
<li>Double-quote (U+0022).</li>
<li>Percent (U+0025).</li>
<li>Any characters outside the printable ASCII range of U+0021-U+007E
inclusive.</li>
</ul>
<p>Space and double-quote are encoded to avoid requiring any further
quoting. Percent is encoded to avoid ambiguity with percent-encoding
itself.</p>
<p>Steps to encode a Unicode character:</p>
<ul>
<li>Encode the character using UTF-8, to obtain a byte sequence.</li>
<li>Encode each byte within the sequence as <code>%xy</code> where <code>x</code> is a
hexadecimal representation of the most significant 4 bits of the byte,
and <code>y</code> is a hexadecimal representation of the least significant 4
bits of the byte.</li>
</ul>
<p>Percent-encoding SHOULD be performed using upper-case for values A-F,
but decoding MUST accept lowercase values.</p>
<p>When performing percent-decoding, values that have been unnecessarily
percent-encoded MUST be accepted, but encoded byte sequences which are
invalid in UTF-8 MUST generate an error
(<a href="#header_decoding_error">header_decoding_error</a>). For example, &quot;%C0%A0&quot; is an
overlong encoding of U+0020, and would be rejected.</p>
<p>Example: a header value of &quot;Euro € 😀&quot; SHOULD be encoded as
follows:</p>
<ul>
<li>The characters, 'E', 'u', 'r', 'o' do not require encoding.</li>
<li>Space, the Euro symbol, and the grinning face emoji require encoding.
They are characters U+0020, U+20AC and U+1F600 respectively.</li>
<li>The encoded HTTP header value is therefore &quot;Euro%20%E2%82%AC%20%F0%9F%98%80&quot;
where &quot;%20&quot; is the encoded form of space, &quot;%E2%82%AC&quot; is the encoded form
of the Euro symbol, and &quot;%F0%9F%98%80&quot; is the encoded form of the
grinning face emoji.</li>
</ul>
<h3 id="error-processing"><a class="anchor" href="#error-processing">☍</a> Error Processing</h3>
<p>If an error occurs during the processing of a request, even if the error was
during the creation of the response (e.g. an invalid <code>?inline</code> value was
provided), then an error MUST be generated and the entire request MUST be
undone.</p>
<p>In general, when an error is generated, it SHOULD be sent back to the client.
However, this MAY not happen if the server determines there is a good reason
to not do so - such as due to security concerns.</p>
<p>Most of the error conditions mentioned in this specification will include a
reference to one of the errors listed in this section. While it is RECOMMENDED
that implementations use those errors (for consistency), they MAY choose to use
a more appropriate one (or a custom one).</p>
<p>When an error is transmitted back to clients, it SHOULD adhere to the format
specified in this section - which references the <a href="https://datatracker.ietf.org/doc/html/rfc9457">Problem Details for HTTP
APIs</a> specification, and when
used MUST be of the following form:</p>
<pre><code class="language-yaml">HTTP/1.1 CODE
Content-Type: application/json; charset=utf-8

{
  &quot;type&quot;: &quot;URI&quot;,
  &quot;instance&quot;: &quot;URL&quot;,
  &quot;title&quot;: &quot;STRING&quot;,
  &quot;detail&quot;: &quot;STRING&quot;, ?
  ... error specific fields ...
}
</code></pre>
<p>Where:</p>
<ul>
<li><code>CODE</code> is the HTTP response code and status text (e.g. <code>404 Not Found</code>).</li>
<li>&quot;type&quot; is a URI to the error definition.</li>
<li>&quot;instance&quot; is a URL to the entity being processed when the error occurred.</li>
<li>&quot;title&quot; is a human-readable summary of the error.</li>
<li>&quot;detail&quot; is human-readable detailed information about the error. Typically
will include suggestions for how to fix the error.</li>
</ul>
<p><code>CODE</code>, <code>&quot;type&quot;</code>, <code>&quot;instance&quot;</code> and <code>title</code> fields are REQUIRED. All other
fields are OPTIONAL unless overwise stated as part of the error definition. Any
substitutable information defined as part of an error MUST be populated
appropriately.</p>
<p>HTTP response codes and status text are defined in the <a href="https://datatracker.ietf.org/doc/html/rfc9110#name-status-codes">HTTP
Semantics</a>
specification.</p>
<p>In the following list of errors, the <code>Code</code>, <code>Type</code> and <code>Instance</code> values MUST
be as specified. The other field values are recommendations and MAY be modified
as appropriate, including being specified in a language other than English.</p>
<!-- start-err-def -->
<h4 id="ancestor-circular-reference"><a class="anchor" href="#ancestor-circular-reference">☍</a> ancestor_circular_reference</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#ancestor_circular_reference</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the Version being processed</li>
<li>Title: <code>The assigned &quot;ancestor&quot; value ({ancestor_value}) creates a circular reference</code></li>
<li>Data:  n/a</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="api-not-found"><a class="anchor" href="#api-not-found">☍</a> api_not_found</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#api_not_found</code></li>
<li>Code: <code>404 Not Found</code></li>
<li>Instance: Request URL</li>
<li>Title: <code>The specified path ({invalid path}) is not supported</code></li>
<li>Data: {the unsupported path}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="bad-flag"><a class="anchor" href="#bad-flag">☍</a> bad_flag</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#bad_flag</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: Request URL</li>
<li>Title: <code>The specified query parameter ({query parameter}) is not allowed in this context</code></li>
<li>Data:  {query parameter name and value}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="bad-request"><a class="anchor" href="#bad-request">☍</a> bad_request</h4>
<p>This error is purposely generic and can be used when there isn't a more
condition-specific error that would be more appropriate. Implementations
SHOULD attempt to use a more specific error when possible.</p>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#bad_request</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: Request URL</li>
<li>Title: <code>The request can not be processed as provided</code></li>
<li>Data: {Short description of the problematic data or reason}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="cannot-doc-xref"><a class="anchor" href="#cannot-doc-xref">☍</a> cannot_doc_xref</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#cannot_doc_xref</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the Resource being retrieved</li>
<li>Title: <code>Retrieving the document view of an xref'd Resource's Versions is not possible</code></li>
<li>Data: {the Resource's URL}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="capability-error"><a class="anchor" href="#capability-error">☍</a> capability_error</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#capability_error</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the xRegistry server</li>
<li>Title: <code>There was an error in the capabilities provided</code></li>
<li>Data: {capability JSON snippet that caused the issue}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="compatibility-violation"><a class="anchor" href="#compatibility-violation">☍</a> compatibility_violation</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#compatibility_violation</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the Version being processed that caused the violation</li>
<li>Title: <code>The request would cause one or more Versions of this Resource to violate the Resource's compatibility rules ({compatibility attribute value})</code></li>
<li>Data: {list of &quot;Versionid&quot; values that would be in violation}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="data-retrieval-error"><a class="anchor" href="#data-retrieval-error">☍</a> data_retrieval_error</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#data_retrieval_error</code></li>
<li>Code: <code>500 Internal Server Error</code></li>
<li>Instance: Request URL</li>
<li>Title: <code>The server was unable to retrieve all of the requested data</code></li>
<li>Data: {Short description of the problematic data or reason}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="details-required"><a class="anchor" href="#details-required">☍</a> details_required</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#details_required</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>$details suffixed is needed when using PATCH for this Resource</code></li>
<li>Data:  n/a</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="extra-xregistry-headers"><a class="anchor" href="#extra-xregistry-headers">☍</a> extra_xregistry_headers</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#extra_xregistry_headers</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>xRegistry HTTP headers are not allowed on this request</code></li>
<li>Data: {list of xRegistry HTTP header names}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="header-decoding-error"><a class="anchor" href="#header-decoding-error">☍</a> header_decoding_error</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#header_decoding_error</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: Request URL</li>
<li>Title: <code>The value (&quot;{header value}&quot;) of the HTTP &quot;{header name}&quot; header can not be decoded</code></li>
<li>Data:  {the header value}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="invalid-character"><a class="anchor" href="#invalid-character">☍</a> invalid_character</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#invalid_character</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>An invalid character ({the character}) was specified an attribute's name ({full attribute name})</code></li>
<li>Data:  {invalid character}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="invalid-data"><a class="anchor" href="#invalid-data">☍</a> invalid_data</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#invalid_data</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>The data provided for &quot;{attribute/parameter name}&quot; is invalid</code></li>
<li>Data:  {invalid data}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="invalid-data-type"><a class="anchor" href="#invalid-data-type">☍</a> invalid_data_type</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#invalid_data_type</code></li>
<li>Code: <code>405 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>A value of an incorrect data-type was specified</code></li>
<li>Data: ... The invalid data ...</li>
<li>Detail: ... Information specific to the processing details ...</li>
</ul>
<h4 id="method-not-allowed"><a class="anchor" href="#method-not-allowed">☍</a> method_not_allowed</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#method_not_allowed</code></li>
<li>Code: <code>405 Method Not Allowed</code></li>
<li>Instance: Request URL</li>
<li>Title: <code>The specified HTTP method ({invalid method}) is not supported for: {request URL}</code></li>
<li>Data: {the unsupported HTTP method}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="mismatched-epoch"><a class="anchor" href="#mismatched-epoch">☍</a> mismatched_epoch</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#mismatched_epoch</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>The specified epoch value ({invalid epoch}) does not match its current value ({current epoch})</code></li>
<li>Data: {the invalid epoch value}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="mismatched-id"><a class="anchor" href="#mismatched-id">☍</a> mismatched_id</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#mismatched_id</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>The specified {singular type name} ID value ({invalid id}) needs to be &quot;{expected id}&quot;</code></li>
<li>Data: {the invalid ID value}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="misplaced-epoch"><a class="anchor" href="#misplaced-epoch">☍</a> misplaced_epoch</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#misplaced_epoch</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>The specified &quot;epoch&quot; value needs to be within a &quot;meta&quot; sub-object</code></li>
<li>Data:  n/a</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="missing-versions"><a class="anchor" href="#missing-versions">☍</a> missing_versions</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#missing_versions</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>At least one Version needs to be included in the request</code></li>
<li>Data: {URL to entity being processed}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="model-compliance-error"><a class="anchor" href="#model-compliance-error">☍</a> model_compliance_error</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#model_compliance_error</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the xRegistry server</li>
<li>Title: <code>The model provided would cause one or more entities in the Registry to become non-compliant</code></li>
<li>Data: {list of XIDs of non-compliant entities}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="model-error"><a class="anchor" href="#model-error">☍</a> model_error</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#model_error</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the xRegistry server</li>
<li>Title: <code>There was an error in the model definition provided</code></li>
<li>Data: {model JSON snippet that caused the issue}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="multiple-roots"><a class="anchor" href="#multiple-roots">☍</a> multiple_roots</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#multiple_roots</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the Resource being processed</li>
<li>Title: <code>The operation would result in multiple root Versions which is not allowed by this Registry</code></li>
<li>Data:  n/a</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="not-found"><a class="anchor" href="#not-found">☍</a> not_found</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#not_found</code></li>
<li>Code: <code>404 Not Found</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>The specified entity can not be found</code></li>
<li>Data: {URL to the entity requested}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="readonly"><a class="anchor" href="#readonly">☍</a> readonly</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#readonly</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>Updating a read-only entity ({XID of entity}) is not allowed</code></li>
<li>Data: {URL to entity being processed}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="required-attribute-missing"><a class="anchor" href="#required-attribute-missing">☍</a> required_attribute_missing</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#required_attribute_missing</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>One or more mandatory attributes are missing</code></li>
<li>Data: {list of mandatory attributes}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="server-error"><a class="anchor" href="#server-error">☍</a> server_error</h4>
<p>This error MAY be used when it appears that the incoming request was valid but
something unexpected happened in the server that caused an error condition.</p>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#server_error</code></li>
<li>Code: <code>500 Internal Server Error</code></li>
<li>Instance: Request URL</li>
<li>Title: <code>An unexpected error occurred, please try again later</code></li>
<li>Data:  n/a</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="too-large"><a class="anchor" href="#too-large">☍</a> too_large</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#too_large</code></li>
<li>Code: <code>406 Not Acceptable</code></li>
<li>Instance: Request URL</li>
<li>Title: <code>The size of the response is too large to return in a single response</code></li>
<li>Data: {the names of the fields/attributes that are too large}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="too-many-versions"><a class="anchor" href="#too-many-versions">☍</a> too_many_versions</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#too_many_versions</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>The request is only allowed to have one Version specified</code></li>
<li>Data: {the URL to the entity being processed}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="unknown-attribute"><a class="anchor" href="#unknown-attribute">☍</a> unknown_attribute</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#unknown_attribute</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>An unknown attribute ({attribute name}) was specified</code></li>
<li>Data:  {unknown attribute name}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="unknown-id"><a class="anchor" href="#unknown-id">☍</a> unknown_id</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#unknown_id</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: URL to the entity being processed</li>
<li>Title: <code>The &quot;{singular name of the entity type}&quot; with the ID &quot;{the unknown ID}&quot; can not be found</code></li>
<li>Data: {URL to entity being processed}</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<h4 id="unsupported-specversion"><a class="anchor" href="#unsupported-specversion">☍</a> unsupported_specversion</h4>
<ul>
<li>Type: <code>https://github.com/xregistry/spec/blob/main/core/spec.md#unsupported_specversion</code></li>
<li>Code: <code>400 Bad Request</code></li>
<li>Instance: The request URL</li>
<li>Title: <code>The specified &quot;specversion&quot; value is not supported</code></li>
<li>Data:  n/a</li>
<li>Detail: {information specific to the processing details}</li>
</ul>
<!-- end-err-def -->
<hr>
